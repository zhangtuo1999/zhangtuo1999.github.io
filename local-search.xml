<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【精通CSS】04.可见格式化模型</title>
    <link href="/archives/df6a6ae1.html"/>
    <url>/archives/df6a6ae1.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1 盒模型"></a>1 盒模型</h1><p>页面中的所有元素都可以看作是一个矩形盒子，这个盒子包含元素的内容、内边距、边框和外边距。</p><p><img src="/../images/%E3%80%90CSS%E3%80%9104_%E5%8F%AF%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B/image-20221118113721964.png" alt="image-20221118113721964"></p><p>内边距（padding）是内容区周围的空间。给元素设置背景通常会作用于元素的内容和内边距，内边距通常用于分割内容使其不至于散布到背景的边界。</p><p>边框（border）是内边距外侧的一条框线。这条框线可以是实线、虚线或者点划线。</p><p>外边距（margin）在边框的外部，用于控制元素在页面之间的距离。</p><p>有一个和边框类似的属性叫轮廓线（outline）。这个属性可以在边框外围画出一条线，但是不会影响布局。</p><p><img src="/../images/%E3%80%90%E7%B2%BE%E9%80%9ACSS%E3%80%9104_%E5%8F%AF%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B/image-20230228115425080.png" alt="image-20230228115425080"></p><h2 id="1-1-box-sizing-宽高计算方式"><a href="#1-1-box-sizing-宽高计算方式" class="headerlink" title="1.1 box-sizing 宽高计算方式"></a>1.1 box-sizing 宽高计算方式</h2><p>box-sizing 的默认值是 content-box。此时，元素盒子的 width 和 height 属性应用到内容盒子，添加内边距和边框不会影响到内容盒子的大小。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;&#125;</code></pre></div><p><img src="/../images/%E3%80%90CSS%E3%80%9104_%E5%8F%AF%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B/image-20221118120210574.png" alt="image-20221118120210574"></p><p>如果将 box-sizing 属性的值设置成 border-box，那么 width 和 height 属性的值将包括内边距和边框。此时，添加内边距和边框会挤占内容盒子的大小。这种方法计算盒子大小更直观。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">box-sizing</span>: border-box;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;&#125;</code></pre></div><p><img src="/../images/%E3%80%90CSS%E3%80%9104_%E5%8F%AF%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B/image-20221118120256744.png" alt="image-20221118120256744"></p><blockquote><p>注意：如果内容、内边距、边框或者外边距的 width 和 height 使用的是百分比，那么这里的百分比是基于<strong>包含块</strong>的<strong>宽度</strong>（上面这里指父元素宽度）。 </p></blockquote><h2 id="1-2-min-width-最小宽度"><a href="#1-2-min-width-最小宽度" class="headerlink" title="1.2 min-width 最小宽度"></a>1.2 min-width 最小宽度</h2><p>min-width 和 max-width 可以设置盒子的最小宽度和最大宽度。min-height 和 max-height 可以设置盒子的最小高度和最大高度。</p><blockquote><p>注意：在 CSS 中任何设定<em>高度值</em>的时候都应该慎重。元素的高度通常取决于元素的内容，不需要我们去设定。不然，一旦内容增多或者字号变大，内容就跑到盒子外边去了。</p></blockquote><h1 id="2-可见格式化模型"><a href="#2-可见格式化模型" class="headerlink" title="2 可见格式化模型"></a>2 可见格式化模型</h1><h2 id="2-1-块级盒子和行内盒子"><a href="#2-1-块级盒子和行内盒子" class="headerlink" title="2.1 块级盒子和行内盒子"></a>2.1 块级盒子和行内盒子</h2><h3 id="2-1-1-块级盒子"><a href="#2-1-1-块级盒子" class="headerlink" title="2.1.1 块级盒子"></a>2.1.1 块级盒子</h3><p>p、h1、article 是块级元素，作为元素，显示为内容块或者<strong>块级盒子</strong>（block）的形式。</p><p>块级盒子会沿着垂直方向堆叠，在垂直方向的间距由它们的上下外边距决定。</p><h3 id="2-1-2-行内盒子"><a href="#2-1-2-行内盒子" class="headerlink" title="2.1.2 行内盒子"></a>2.1.2 行内盒子</h3><p>strong、span、time 是行内元素，内容以<strong>行内盒子</strong>（inline）的形式显示。</p><p>行内盒子沿文本流水平排列，随着文本的换行而换行。行内盒子的水平间距可以通过水平方向的内边距、边框和外边距来调节。但是，行内盒子的高度不受垂直方向的内边距、边框和外边距影响。而且，给行内盒子明确设置高度和宽度也不会起作用。</p><h4 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h4><p><strong>常规文本流中块级盒子</strong>在<strong>垂直方向</strong>上存在外边距折叠机制：多个垂直外边距相遇时会折叠成一个外边距，折叠后的外边距按较大的那个计算。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-id">#div1</span>&#123;</span><span class="language-css">        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">30px</span>;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-id">#div2</span>&#123;</span><span class="language-css">        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span>div1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span>div2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><img src="/../images/%E3%80%90%E7%B2%BE%E9%80%9ACSS%E3%80%9104_%E5%8F%AF%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B/image-20230228093602693.png" alt="image-20230228093602693"></p><h3 id="2-1-3-display-盒子类型"><a href="#2-1-3-display-盒子类型" class="headerlink" title="2.1.3 display 盒子类型"></a>2.1.3 display 盒子类型</h3><p>可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display">display</a> 属性改变盒子类型：</p><ul><li><p>display 属性设置为 block，元素表现为块级盒子。</p></li><li><p>display 属性设置为 inline，元素表现为行内盒子。</p></li><li><p>display 属性设置为 inline-block，元素像行内盒子一样水平排列，但是内部像块级盒子一样，可以设置宽高、垂直内外边距。</p></li><li><p>display 属性设置为 none，元素不显示。</p></li></ul><h3 id="2-1-4-匿名盒子"><a href="#2-1-4-匿名盒子" class="headerlink" title="2.1.4 匿名盒子"></a>2.1.4 匿名盒子</h3><p>不明确元素会生成<strong>匿名块盒子</strong>。不能给匿名盒子添加样式。</p><h2 id="2-2-position-定位类型"><a href="#2-2-position-定位类型" class="headerlink" title="2.2 position 定位类型"></a>2.2 position 定位类型</h2><p>CSS 中有几种不同的定位模型，包括静态定位 static，相对定位 relative，绝对定位 absolute，固定定位 fixed。</p><p>默认情况下，position 属性的值是 static，所有元素盒子都在常规文档流中。</p><img src="../images/【精通CSS】04_可见格式化模型/image-20230228094220475.png" alt="image-20230228094220475" style="zoom:67%;" /><h3 id="2-2-1-相对定位-relative"><a href="#2-2-1-相对定位-relative" class="headerlink" title="2.2.1 相对定位 relative"></a>2.2.1 相对定位 relative</h3><p>设置为相对定位后，元素仍然待在原位置，但是可以通过 top、right、bottom 和 left 使元素相对于原位置平移。无论是否平移，元素都会占据文档流中的初始位置。</p><img src="../images/【精通CSS】04_可见格式化模型/image-20230228094621606.png" alt="image-20230228094621606" style="zoom:67%;" /><h3 id="2-2-2-绝对定位-absolute"><a href="#2-2-2-绝对定位-absolute" class="headerlink" title="2.2.2 绝对定位 absolute"></a>2.2.2 绝对定位 absolute</h3><p>设置绝对定位后，元素脱离文档流，不会再占据原位置，因此其他元素会重新定位。</p><img src="../images/【精通CSS】04_可见格式化模型/image-20230228095013331.png" alt="image-20230228095013331" style="zoom:67%;" /><h4 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h4><p>绝对定位元素的<strong>包含块</strong>是距离最近的<strong>定位祖先</strong>，也就是除了 position 为 static 之外的任意祖先元素。如果找不到，那就相对于 html 元素来定位。</p><h4 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h4><p>绝对定位元素因为脱离了文档流，因此会遮盖其他元素。可以设置元素的 z-index 属性来控制 z 轴距离远近，z-index 越大的元素离人眼越近。</p><h3 id="2-2-3-固定定位-fixed"><a href="#2-2-3-固定定位-fixed" class="headerlink" title="2.2.3 固定定位 fixed"></a>2.2.3 固定定位 fixed</h3><p>固定定位与绝对定位类似，不同点在于固定定位元素的包含块是<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport">视口</a>（浏览器中可见内容的部分）。</p><h2 id="2-3-float-浮动模型"><a href="#2-3-float-浮动模型" class="headerlink" title="2.3 float 浮动模型"></a>2.3 float 浮动模型</h2><p>浮动盒子脱离常规文档流，可以向左或者向右移动，直到外边沿接触到包含块的外边沿，或者另一个浮动盒子的外边沿。</p><p>如果浮动元素后面跟着的是常规文档流中的元素，那么这个元素的盒子就当浮动盒子不存在。但是，这个盒子中的<strong>文本内容</strong>会记住浮动元素的大小，并在排版时避开，造成文本环绕浮动盒子的效果。 </p><img src="../images/【精通CSS】04_可见格式化模型/image-20230228105001060.png" alt="image-20230228105001060" style="zoom:67%;" /><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>使用 clear 属性可以清除浮动，使得元素移动到浮动元素的下方。</p><img src="../images/【精通CSS】04_可见格式化模型/image-20230228110423092.png" alt="image-20230228110423092" style="zoom:67%;" /><p>清除元素时，浏览器会给元素上方添加足够大的外边距，使得元素垂直向下移动到浮动元素下方。因此，如果给已清除浮动的元素添加外边距，除非值超出浏览器添加的值，否则看不到效果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【精通CSS】03.添加样式</title>
    <link href="/archives/34a04ea6.html"/>
    <url>/archives/34a04ea6.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-层叠"><a href="#1-层叠" class="headerlink" title="1 层叠"></a>1 层叠</h1><p>复杂的样式表中可能存在两条或者多条规则同时选择一个元素的情况。CSS 使用<strong>层叠机制</strong>来处理这种冲突。层叠机制的原理是为规则赋予不同的重要程度。</p><p>最重要的是<strong>作者样式表</strong>，即由网站开发者所写的样式。其次是<strong>用户样式表</strong>，用户可以通过浏览器的设置选项来应用自己的样式。排在最后的是<strong>浏览器</strong>（或用户代码）的<strong>默认样式表</strong>，它一般会被作者样式表覆盖掉。</p><p>为了给用户更高的优先权，CSS 允许用户使用 <code>!important</code>覆盖任何规则，包括网站作者使用的 <code>!important</code>标注的规则。<code>!important </code>需要放在属性声明的后面。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5em</span> <span class="hljs-meta">!important</span>;&#125;</code></pre></div><p>总结起来，层叠机制的<strong>重要性</strong>的级别从高到低如下：</p><ol><li>标注为 <code>!important</code> 的用户样式表</li><li>标注为 <code>!important</code> 的作者样式表</li><li>作者样式表</li><li>用户样式表</li><li>浏览器的默认样式</li></ol><p>在此基础上，规则再按选择器的<strong>特殊性</strong>排序。特殊性高的选择器会覆盖特殊性低的选择器。如果两条规则的特殊性相等，则<strong>后</strong>定义的规则优先。</p><h1 id="2-特殊性（优先级）"><a href="#2-特殊性（优先级）" class="headerlink" title="2 特殊性（优先级）"></a>2 特殊性（优先级）</h1><p>为了量化规则的特殊性，每种选择器都对应一个数值。一条规则的特殊性就是这些数值的累加值。这里的累加计算是基于位置的累加而不是基于数值的累加（如果一条规则所用的选择器不超过10个，也可以基于十进制数值计算特殊性）。选择器的特殊性对应以下4个级别（a b c d）：</p><ol><li>行内样式a&#x3D;1</li><li>b等于id选择器的数目</li><li>c等于类选择器、伪类选择器以及属性选择器的数目</li><li>d等于元素选择器和伪元素选择器的数目</li><li>通用选择器的特殊性是0</li></ol><p><img src="/../images/%E3%80%90CSS%E3%80%9103_%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F/image-20221118101023735.png" alt="image-20221118101023735"></p><p>本质上讲，行内样式的优先级最高。使用id属性的规则优先级高于未使用id属性的规则。hi用类选择器的规则优先级高于只通过元素选择器的规则。</p><h1 id="3-继承"><a href="#3-继承" class="headerlink" title="3 继承"></a>3 继承</h1><p>有些属性，像是颜色和字体大小，会被使用他们的元素的后代所继承．比如把body元素的文本颜色设置成黑色，那么body元素所有的后代元素文本颜色都会继承这个颜色。</p><p>继承机制可以避免给一个元素的所有后代元素重复设置相同的样式。</p><h1 id="4-为文档应用样式"><a href="#4-为文档应用样式" class="headerlink" title="4 为文档应用样式"></a>4 为文档应用样式</h1><h2 id="4-1-link-和-style-元素"><a href="#4-1-link-和-style-元素" class="headerlink" title="4.1 link 和 style 元素"></a>4.1 link 和 style 元素</h2><p>可以把样式放在style元素中，直接放在文档的head部分。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-tag">a</span>&#123;</span><span class="language-css">        <span class="hljs-attribute">color</span>:blueviolet;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>为了能够重用样式，通常需要将样式保存在一个外部文件中。有两种方法应用外部的样式表：</p><ol><li><p>使用 link 元素：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./style.css&quot;</span>/&gt;</span></code></pre></div></li><li><p>使用 @import 指令：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-keyword">@import</span> url(./style.css);</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ol><p>上面两种方法中，更推荐使用 link 元素。</p><p>使用 link 和style 添加样式时，声明的顺序就是在HTML源代码中出现的顺序。根据层叠机制，这些顺序决定了优先级。</p><h2 id="4-2-性能"><a href="#4-2-性能" class="headerlink" title="4.2 性能"></a>4.2 性能</h2><p>浏览器只有掌握了页面布局的全部 CSS 信息才能给出最佳相应。</p><h3 id="4-2-1-减少-HTTP-请求"><a href="#4-2-1-减少-HTTP-请求" class="headerlink" title="4.2.1 减少 HTTP 请求"></a>4.2.1 减少 HTTP 请求</h3><p>线上网页最好把需要加载的 CSS 文件数量控制在1-2个。如果使用 link 元素加载一个 CSS 文件并且在其中使用@import，并不能就将请求的数量控制在1个。因为 link 标签会进行一次请求，并且 link 请求下来的内容中如果有 @import，还会继续请求文件，所以线上的网页尽量不要使用@import。</p><h3 id="4-2-2-压缩和缓存内容"><a href="#4-2-2-压缩和缓存内容" class="headerlink" title="4.2.2 压缩和缓存内容"></a>4.2.2 压缩和缓存内容</h3><p>使用 GZIP 可以大幅度压缩 CSS 文件的大小。</p><p>理想情况下，浏览器应该只下载一个 CSS 文件，除非线上的文件出现变化。可以通过 HTTP 首部告诉浏览器把文件缓存一段时间。通过改变文件名的方式来告诉浏览器来清除缓存.</p><h3 id="4-2-3-使用async和defer"><a href="#4-2-3-使用async和defer" class="headerlink" title="4.2.3 使用async和defer"></a>4.2.3 使用async和defer</h3><p>如果在 HTML 中加入了 script 元素，那么浏览器会先将需要引入的 js 文件下载下来，下载并执行完毕后再继续渲染网页内容。这种渲染阻塞会严重拖慢网页的加载速度。一般的做法是，在 script 元素中添加 async 或者 defer 属性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【精通CSS】02.选择器</title>
    <link href="/archives/b27b9dc2.html"/>
    <url>/archives/b27b9dc2.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-CSS-选择器"><a href="#1-CSS-选择器" class="headerlink" title="1 CSS 选择器"></a>1 CSS 选择器</h1><h2 id="1-1-基本选择器"><a href="#1-1-基本选择器" class="headerlink" title="1.1 基本选择器"></a>1.1 基本选择器</h2><h3 id="1-1-1-元素选择器"><a href="#1-1-1-元素选择器" class="headerlink" title="1.1.1 元素选择器"></a>1.1.1 元素选择器</h3><p>用于选择特定类型的元素。比如段落或标题元素。例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>:black;&#125;</code></pre></div><p>元素选择器适合全面应用基础样式。更精准的选择目标应该使用 ID 选择器和类选择器。</p><h3 id="1-1-2-ID-选择器"><a href="#1-1-2-ID-选择器" class="headerlink" title="1.1.2 ID 选择器"></a>1.1.2 ID 选择器</h3><p>通过 HTML 元素的 id 属性来选择元素。由<code>#</code>开头，例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;p1&#x27;</span>&gt;</span>段落1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#p1</span>&#123;<span class="hljs-attribute">color</span>:black;&#125;</code></pre></div><h3 id="1-1-3-类选择器"><a href="#1-1-3-类选择器" class="headerlink" title="1.1.3 类选择器"></a>1.1.3 类选择器</h3><p>通过 HTML 元素的 class 属性来选择元素。由<code>.</code>开头，例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-p&quot;</span>&gt;</span>这是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.my-p</span>&#123;    <span class="hljs-attribute">color</span>:black;&#125;</code></pre></div><h2 id="1-2-组合器选择器"><a href="#1-2-组合器选择器" class="headerlink" title="1.2 组合器选择器"></a>1.2 组合器选择器</h2><h3 id="1-2-1-后代选择器"><a href="#1-2-1-后代选择器" class="headerlink" title="1.2.1 后代选择器"></a>1.2.1 后代选择器</h3><p>后代选择器用于选择某个或者某组元素的后代，写法是在两个<strong>基本选择器</strong>之间加上空格，例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>被div包裹的段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span>&#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#a6edb2</span>;&#125;</code></pre></div><p>上面的例子中，只有父元素是 div 的 p 元素才会被影响到样式，其它的 p 元素不会发生变化。</p><p>后代选择器会选择一个元素的<strong>所有</strong>层级的后代。并且，后代选择器中的<strong>基本选择器</strong>类型和数量不限，例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">background-color</span>: blue;&#125;</code></pre></div><p>两个段落都被应用了样式：<img src="/images/CSS.2.%E9%80%89%E6%8B%A9%E5%99%A8/image-20220523101342300.png" alt="image-20220523101342300"></p><h3 id="1-2-2-子选择器"><a href="#1-2-2-子选择器" class="headerlink" title="1.2.2 子选择器"></a>1.2.2 子选择器</h3><p>与后代选择器会选择一个元素的所有后代不同，子选择器只会选择一个元素的<strong>直接</strong>后代。写法是在两个基本选择器之间加上 <code>&gt;</code> 。比如：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">background-color</span>: skyblue;&#125;</code></pre></div><p>只有直接后代应用了样式，后代的后代没有应用到样式：</p><p><img src="/images/CSS.2.%E9%80%89%E6%8B%A9%E5%99%A8/image-20220523101556742.png" alt="image-20220523101556742"></p><h3 id="1-2-3-相邻同辈选择器"><a href="#1-2-3-相邻同辈选择器" class="headerlink" title="1.2.3 相邻同辈选择器"></a>1.2.3 相邻同辈选择器</h3><p>使用相邻同辈选择器可以选择位于某个元素后面，与其<strong>最相邻的同辈元素</strong>。写法是在两个基本选择器之间使用 <code>+</code> 。比如：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>段落1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span> + <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">background-color</span>: skyblue;&#125;</code></pre></div><p>在 span 后最相邻的同辈元素是 p，所以 p 被应用到样式：</p><p><img src="/images/CSS.2.%E9%80%89%E6%8B%A9%E5%99%A8/image-20220523102404149.png" alt="image-20220523102404149"></p><h3 id="1-2-4-通用同辈选择器"><a href="#1-2-4-通用同辈选择器" class="headerlink" title="1.2.4 通用同辈选择器"></a>1.2.4 通用同辈选择器</h3><p>与相邻同辈选择器不同，通用同辈选择器可以选择某个元素后面的<strong>所有同辈元素</strong>。写法是在两个基本选择器之间使用<code>~</code>。比如：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>段落1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落4<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span> ~ <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">background-color</span>: skyblue;&#125;</code></pre></div><p>span 后面的所有同辈元素都会被应用到样式：</p><p><img src="/images/CSS.2.%E9%80%89%E6%8B%A9%E5%99%A8/image-20220523102928742.png" alt="image-20220523102928742"></p><h2 id="1-3-通用选择器"><a href="#1-3-通用选择器" class="headerlink" title="1.3 通用选择器"></a>1.3 通用选择器</h2><p>通用选择器可以匹配任何元素。使用 <code>*</code> 表示通用选择器。</p><p>比如，删除所有元素的外边距：</p><div class="code-wrapper"><pre><code class="hljs css">*&#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;&#125;</code></pre></div><p>也可以和组合器选择器使用。比如，选择 span 元素下面的所有直接后代：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span> &gt; * &#123;<span class="hljs-comment">/* ... */</span>&#125;</code></pre></div><h2 id="1-4-属性选择器"><a href="#1-4-属性选择器" class="headerlink" title="1.4 属性选择器"></a>1.4 属性选择器</h2><p>属性选择器基于元素是否有某个属性或者属性是否有某个值来选择元素。写法是使用<code>[]</code>。</p><h3 id="1-4-1-元素是否有某个属性"><a href="#1-4-1-元素是否有某个属性" class="headerlink" title="1.4.1 元素是否有某个属性"></a>1.4.1 元素是否有某个属性</h3><p>根据元素是否有某个属性来应用样式。比如，给带有 title 属性的 attr 元素加上样式：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;北京化工大学&quot;</span>&gt;</span>BUCT<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">abbr</span><span class="hljs-selector-attr">[title]</span>&#123;    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> dotted <span class="hljs-number">#999</span>;&#125;</code></pre></div><p>效果：</p><p><img src="/images/CSS.2.%E9%80%89%E6%8B%A9%E5%99%A8/image-20220523110737253.png" alt="image-20220523110737253"></p><h3 id="1-4-2-属性值是否匹配"><a href="#1-4-2-属性值是否匹配" class="headerlink" title="1.4.2 属性值是否匹配"></a>1.4.2 属性值是否匹配</h3><p>除了可以根据某个属性来选择元素，还可以根据特定的属性值来应用样式。比如，所有 type 属性值为 submit 的input 元素在悬停时显示一个手状光标：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span> &#123;    <span class="hljs-attribute">cursor</span>: pointer;&#125;</code></pre></div><p>有时候，我们关心的是属性值是否匹配某个<strong>模式</strong>，而非特定的值。这时候，可以通过给属性选择符中的等号前面加上特殊字符。</p><ol><li><p>匹配以某些字符<strong>开头</strong>的属性值，在等号前面加上 <code>^</code>。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href^=<span class="hljs-string">&quot;http:&quot;</span>]</span></code></pre></div></li><li><p>匹配以某些字符的<strong>结尾</strong>的属性值，在等号前面加上<code>$</code>。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[src$=<span class="hljs-string">&quot;.jpg&quot;</span>]</span></code></pre></div></li><li><p>匹配<strong>包含</strong>某些字符的属性值，在等号前面加上<code>*</code>。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&quot;/about/&quot;</span>]</span></code></pre></div></li><li><p>要匹配以空格分割的字符串中的属性值，在等号前面加上<code>~</code>。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[rel~=next]</span>&#123;<span class="hljs-attribute">color</span>: skyblue;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prev next&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/images/CSS.2.%E9%80%89%E6%8B%A9%E5%99%A8/image-20220523112813211.png" alt="image-20220523112813211"></p></li><li><p>要匹配开头是指定值或者指定值后面连着一个短划线的情况，在等号前面加上<code>|</code>。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[lang|=en]</span></code></pre></div><p>这条规则可以匹配属性值为 en 和 en-us 等。</p></li></ol><h2 id="1-5-伪元素选择器"><a href="#1-5-伪元素选择器" class="headerlink" title="1.5 伪元素选择器"></a>1.5 伪元素选择器</h2><p>有时候，我们想选择的页面区域不是通过元素来表示的，而我们也不想为此给页面添加额外的标记。此时，可以使用<strong>伪元素选择器</strong>。伪元素使用<code>::</code>来表示。</p><p>比如，可以使用  <code>::first-letter</code> 伪元素来选择一段文本的第一个字符。使用 <code>::first-line</code> 来选择文本的第一行。使用 <code>::before</code> 和 <code>::after</code> 选择内容开头和末尾。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;chapter&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>this is a text.this is a text.this is a text.this is a text.this is a text.this is a text.this is a text.this is a text.this is a text.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.chapter</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span>&#123;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3em</span>;&#125;<span class="hljs-selector-class">.chapter</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span>&#123;    <span class="hljs-attribute">text-transform</span>: capitalize;&#125;</code></pre></div><p>效果：</p><p><img src="/images/CSS.2.%E9%80%89%E6%8B%A9%E5%99%A8/image-20220523145954542.png" alt="image-20220523145954542"></p><blockquote><p><strong>注意</strong>：为了和<strong>伪类</strong>区分开，伪元素应该使用<strong>双冒号</strong>语法。但是处于兼容性考虑，某些浏览器支持单冒号语法。</p></blockquote><h2 id="1-6-伪类选择器"><a href="#1-6-伪类选择器" class="headerlink" title="1.6 伪类选择器"></a>1.6 伪类选择器</h2><p>有时候，我们想基于文档结构以外的情形来为页面添加样式，比如基于超链接或表单元素的状态。此时可以使用伪类选择器。伪类使用<code>:</code>开头，用于选择元素特定的状态或者关系。</p><h3 id="1-6-1-用于超链接的伪类"><a href="#1-6-1-用于超链接的伪类" class="headerlink" title="1.6.1 用于超链接的伪类"></a>1.6.1 用于超链接的伪类</h3><p>最常见的用于超链接的伪类如下：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 未访问过的链接为蓝色 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;    <span class="hljs-attribute">color</span>: blue;&#125;<span class="hljs-comment">/* 访问过的链接为绿色 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;    <span class="hljs-attribute">color</span>: green;&#125;<span class="hljs-comment">/* 鼠标悬停及获取键盘焦点时为红色 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>,<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;    <span class="hljs-attribute">color</span>: red;&#125;<span class="hljs-comment">/* 活动状态时为紫色 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;    <span class="hljs-attribute">color</span>: purple;&#125;</code></pre></div><p>以上伪类的<strong>先后次序</strong>很重要。<code>:link</code> 和 <code>:visited</code> 应该排在前面，然后是与用户交互的那些。这样，当用户鼠标悬停或者获取键盘焦点时，<code>:hover</code> 和 <code>:focus</code> 会覆盖 <code>:link</code> 和 <code>:hover</code> 规则。</p><h3 id="1-6-2-目标伪类和反选伪类"><a href="#1-6-2-目标伪类和反选伪类" class="headerlink" title="1.6.2 目标伪类和反选伪类"></a>1.6.2 目标伪类和反选伪类</h3><p><strong>目标伪类</strong><code>:target</code>，匹配的元素有一个 ID 属性，而且该属性的值出现在当前页面 URL 末尾的 <code>#</code> 后面。比如，通过目标伪类选择一条评论：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.comment</span><span class="hljs-selector-pseudo">:target</span>&#123;<span class="hljs-comment">/* .. */</span>&#125;</code></pre></div><p><strong>反选伪类</strong><code>:not()</code> ，用于排除某些选择器。比如，选择 <code>comment</code> 类中不带 <code>comment-downvoted</code> 类名的元素：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.comment</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.comment-downvoted</span>)&#123;<span class="hljs-comment">/* .. */</span>&#125;</code></pre></div><p>反选伪类可以配合各种放到括号中的选择器使用，不过伪元素和自身除外。</p><h3 id="1-6-3-结构化伪类"><a href="#1-6-3-结构化伪类" class="headerlink" title="1.6.3 结构化伪类"></a>1.6.3 结构化伪类</h3><p>CSS3 新增了一大批与文档结构有关的新伪类。最常使用的是 <code>:nth-child</code> 选择器，可以用来交替地为表格行添加样式。</p><h4 id="nth-child"><a href="#nth-child" class="headerlink" title=":nth-child"></a>:nth-child</h4><p><code>:nth-child</code>可以接受 <code>odd</code>（奇数）或者 <code>even</code>（偶数）作为参数。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(odd) &#123;    <span class="hljs-attribute">background-color</span>: skyblue;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/images/CSS.2.%E9%80%89%E6%8B%A9%E5%99%A8/image-20220523160632700.png" alt="image-20220523160632700"></p><p><code>:nth-child</code>接收的参数还可以是数值，表示目标元素的序号位置。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 表格的第三行会应用样式 */</span><span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;    <span class="hljs-attribute">background-color</span>: skyblue;&#125;</code></pre></div><p><code>:nth-child</code>接收的参数还可以是数值表达式。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 表格的第4、7、10...行会应用样式*/</span><span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>n+<span class="hljs-number">4</span>) &#123;    <span class="hljs-attribute">background-color</span>: skyblue;&#125;</code></pre></div><h4 id="nth-last-child"><a href="#nth-last-child" class="headerlink" title=":nth-last-child"></a>:nth-last-child</h4><p><code>:nth-last-child</code> 选择器与<code>:nth-child</code>类似，只不过是从最后一个元素倒序计算。</p><h3 id="1-6-4-表单伪类"><a href="#1-6-4-表单伪类" class="headerlink" title="1.6.4 表单伪类"></a>1.6.4 表单伪类</h3><p>还有很多伪类专门用于选择表单元素。比如<code>:required</code>、<code>:optional</code>、<code>valid</code>、<code>invalid</code>等等。</p><p>为<strong>必填</strong>的表单元素添加高亮效果：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:required</span>&#123;    <span class="hljs-attribute">outline</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">required</span>&gt;</span></code></pre></div><p>此外还有针对<strong>有效</strong>和<strong>无效</strong>控件的伪类。比如，邮箱输入框中的内容有效和无效时添加效果：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;email&quot;</span>]</span><span class="hljs-selector-pseudo">:valid</span> &#123;    <span class="hljs-attribute">border-color</span>: green;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;email&quot;</span>]</span><span class="hljs-selector-pseudo">:invalid</span> &#123;    <span class="hljs-attribute">border-color</span>: red;&#125;</code></pre></div><p>此外，还有针对 type 值为 number 的 <code>:in-range</code>、<code>:out-of-range</code> 伪类，针对 readonly 属性的 <code>:read-only</code> 伪类，以及针对没有 readonly 属性的 <code>:read-write</code> 伪类。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【精通CSS】01.基础知识</title>
    <link href="/archives/364c3bce.html"/>
    <url>/archives/364c3bce.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-组织代码"><a href="#1-组织代码" class="headerlink" title="1 组织代码"></a>1 组织代码</h1><ul><li>可维护性是所有优秀代码<strong>最重要</strong>的特点。</li><li>CSS 的初衷是把跟 HTML 混在一起的表现性标记提取出来，使其自成体系，达到<strong>结构与表现分离</strong>的目的。</li><li>判断一个人是不是 CSS 大师，很大程度上要看他是否能游刃有余地处理<strong>向后兼容</strong>的代码与<strong>未来友好</strong>的代码。</li></ul><h2 id="1-1-渐进增强"><a href="#1-1-渐进增强" class="headerlink" title="1.1 渐进增强"></a>1.1 渐进增强</h2><p><strong>渐进增强</strong>策略：首先为最小公分母准备可用的内容，然后在为支持新特性的浏览器提供更多的交互优化。</p><p>CSS 的渐进增强策略反映在如何对待新属性上，任何浏览器无法识别的属性和值都会导致浏览器丢弃相应的声明。因此只要提供合理的后备声明，使用新属性就不会带来不良后果。</p><p>比如，使用 rgba 函数方式表示颜色值：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.overlay</span>&#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>);&#125;</code></pre></div><p>如果浏览器支持 rgba 函数，第二条声明会覆盖第一条。因此，即使不是所有浏览器都支持 rgba 函数，仍然可以使用它，只要在这之前声明后备代码。</p><h3 id="1-1-1-厂商前缀"><a href="#1-1-1-厂商前缀" class="headerlink" title="1.1.1 厂商前缀"></a>1.1.1 厂商前缀</h3><p>在标准名称前面加上特殊字符串，以便不同浏览器厂商引入<strong>实验性特性</strong>。</p><p>比如，给相应元素添加变换：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.myThing</span> &#123;    -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10px</span>);    -moz-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10px</span>);    -ms-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10px</span>);    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10px</span>);&#125;</code></pre></div><p>以  <code>-webkit-</code>  开头的适用于基于 WebKit 的浏览器：Safari、Chrome、Opera</p><p>以 <code>-moz-</code> 开头的适用于基于 Mozilla 的浏览器：Firefox</p><p>以 <code>-ms-</code> 开头的适用于 IE 浏览器</p><p>最后不带前缀的标准属性名称适用于所有支持它的浏览器。</p><h3 id="1-1-2-条件规则"><a href="#1-1-2-条件规则" class="headerlink" title="1.1.2 条件规则"></a>1.1.2 条件规则</h3><p>使用 <code>@supports</code> 根据浏览器是否支持某个 CSS 特性来提供不同的样式。比如：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@supports</span>(display:grid)&#123;    <span class="hljs-comment">/* 应用的规则 */</span>&#125;</code></pre></div><p>它会检查括号中的声明，只有浏览器支持该声明的前提下，才会应用块中的规则。</p><h1 id="2-创建结构化、语义化富-HTML"><a href="#2-创建结构化、语义化富-HTML" class="headerlink" title="2  创建结构化、语义化富 HTML"></a>2  创建结构化、语义化富 HTML</h1><ul><li><strong>语义</strong>指的是通过使用某个符号想要表达的含义。<strong>语义化标记</strong>指在正确的地方使用正确的元素。</li></ul><h2 id="2-1-ID-和-class-属性"><a href="#2-1-ID-和-class-属性" class="headerlink" title="2.1 ID 和 class 属性"></a>2.1 ID 和 class 属性</h2><ul><li><p>给元素添加类名的时候，只让类名体现出组件的<strong>类型</strong>，而不是体现出<strong>视觉效果</strong>。比如：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> // 推荐<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;large-centered-list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>// 不推荐</code></pre></div></li><li><p>一般来说 class 属性来定义<strong>一类</strong>事物，id 属性来标识<strong>特定实例</strong>。</p></li><li><p>一般不建议将 id 属性作为 CSS 的接入点。id 可以在文档中标识元素，但是通常不会用于样式。</p></li></ul><h2 id="2-2-结构化元素"><a href="#2-2-结构化元素" class="headerlink" title="2.2 结构化元素"></a>2.2 结构化元素</h2><p>HTML5 中新增的结构化元素：</p><ul><li>section</li><li>header</li><li>footer</li><li>nav</li><li>article</li><li>aside</li><li>main</li></ul><p>使用这些新元素来可以增强逻辑性，可以帮助机器人更好地理解文档。</p><h2 id="2-3-div-和-span"><a href="#2-3-div-和-span" class="headerlink" title="2.3 div 和 span"></a>2.3 div 和 span</h2><ul><li>确保真的不需要使用语义化元素时，才去使用 div。</li><li>与 div 不同，span 是<strong>文本级元素</strong>，可以用来在文本流中建立结构。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【TypeScript编程】4.类型进阶</title>
    <link href="/archives/ae2d1da8.html"/>
    <url>/archives/ae2d1da8.html</url>
    
    <content type="html"><![CDATA[<h2 id="类型进阶"><a href="#类型进阶" class="headerlink" title="类型进阶"></a>类型进阶</h2><h2 id="1-类型之间的关系"><a href="#1-类型之间的关系" class="headerlink" title="1. 类型之间的关系"></a>1. 类型之间的关系</h2><h3 id="1-1-子类型和超类型"><a href="#1-1-子类型和超类型" class="headerlink" title="1.1 子类型和超类型"></a>1.1 子类型和超类型</h3><img src="../images/【TypeScript编程】4-类型进阶/微信图片_20230421145958.jpg" alt="微信图片_20230421145958" style="zoom:50%;" /><p>子类型：如果 B 是 A 的子类型，那么在需要 A 的地方都可以放心使用 B。</p><p>超类型：如果 B 是 A 的超类型，那么在需要 B 的地方都可以放心使用 A。</p><p>举例：</p><ol><li>Array 是 Object 的子类型，Object 是 Array 的超类型。需要 Object 的地方都可以放心使用 Array。</li><li>如果 Bird 类扩展自 Animal 类，那么 Bird 是 Animal 的子类型，Animal 是 Bird 的超类型。需要 Animal 的地方都可以放心使用 Bird。</li></ol><h3 id="1-2-型变"><a href="#1-2-型变" class="headerlink" title="1.2 型变"></a>1.2 型变</h3><p>型变的四种方式：</p><ol><li>不变：只能传入 T 类型</li><li>协变：可以传入 T 类型或者是 T 的子类型</li><li>逆变：可以传入 T 类型或者是 T 的超类型</li><li>双变：可以传入 T 类型或者是 T 的子类型或者是 T 的超类型</li></ol><p>在 TS 中，对象、类、数组和函数返回类型的每个成员会进行<strong>协变</strong>；函数的参数类型会进行<strong>逆变</strong>。</p><h4 id="1-2-1-结构型变"><a href="#1-2-1-结构型变" class="headerlink" title="1.2.1 结构型变"></a>1.2.1 结构型变</h4><p>在 TS 中，对于预期的结构，可以传入属性的同类型或者子类型，但是不可以传入超类型。也就是说，如果想保证 A 对象可以赋值给 B 对象，A 对象中的每个属性必须 是 B 对象中对应属性的同类型或者子类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// foo预期传入参数的id属性为 number | undefined</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x: &#123; id?: <span class="hljs-built_in">number</span> &#125;</span>) &#123; &#125;<span class="hljs-keyword">type</span> A = &#123;    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">type</span> B = &#123;    id?: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: A = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: B = &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;001&#x27;</span> &#125;<span class="hljs-title function_">foo</span>(a)<span class="hljs-comment">// 可以，foo预期传入参数的id属性为 number | undefined，实际传入的是子类型 number</span><span class="hljs-title function_">foo</span>(b)<span class="hljs-comment">// 报错，，foo预期传入参数的id属性为 number | undefined，实际传入的是超类型 number | string | undefined</span></code></pre></div><h4 id="1-2-2-函数型变"><a href="#1-2-2-函数型变" class="headerlink" title="1.2.2 函数型变"></a>1.2.2 函数型变</h4><p>如果函数 A 的参数数量小于或等于函数 B 的参数数量，而且满足下面的条件，那么函数 A 是函数 B 的子类型：</p><ol><li>函数 A 的 this 类型没有指定，或者是函数 B 的 this 类型的同类型或超类型</li><li>函数 A 的各个参数的类型是函数 B 对应参数的同类型或者超类型</li><li>函数 A 的<strong>返回类型</strong>是函数 B 返回类型的同类型或者子类型</li></ol><p>函数返回类型的<strong>协变</strong>是指一个函数是另一个函数的子类型，也即一个函数的返回类型是另一个函数返回类型的同类型或者子类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 函数类型协变</span><span class="hljs-comment">// C 是 B 的子类型，B 是 A 的子类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> &#123;    <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;&#125; &#125;<span class="hljs-comment">// clone 接受一个函数参数，传入的函数接收一个B类型参数，返回一个B类型参数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">f: (b: B) =&gt; B</span>) &#123; &#125;<span class="hljs-comment">// 传入的函数接收B类型，返回B类型。显然可以</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">b2b</span>(<span class="hljs-params">b: B</span>): B &#123; <span class="hljs-keyword">return</span> b &#125;<span class="hljs-title function_">clone</span>(b2b)<span class="hljs-comment">// 传入的函数接收B类型，返回B的超类型。不可以</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">b2a</span>(<span class="hljs-params">b: B</span>): A &#123; <span class="hljs-keyword">return</span> b <span class="hljs-keyword">as</span> A &#125;<span class="hljs-title function_">clone</span>(b2a)<span class="hljs-comment">// 报错</span><span class="hljs-comment">// 传入的函数接收B类型，返回B的子类型。可以</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">b2c</span>(<span class="hljs-params">b: B</span>): C &#123; <span class="hljs-keyword">return</span> b <span class="hljs-keyword">as</span> C &#125;<span class="hljs-title function_">clone</span>(b2c)</code></pre></div><p>函数参数的<strong>逆变</strong>是指，为了保证一个函数可赋值给另一个函数，该函数的参数类型包括 this 类型，都要是另一个函数相应参数的同类型或者超类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 函数参数逆变</span><span class="hljs-comment">// 传入的函数参数接收 B 类型的超类型。可以</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">a2b</span>(<span class="hljs-params">a: A</span>): B &#123; <span class="hljs-keyword">return</span> a <span class="hljs-keyword">as</span> B &#125;<span class="hljs-title function_">clone</span>(a2b)<span class="hljs-comment">// 传入的函数参数接收 B 类型的子类型。不可以</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">c2b</span>(<span class="hljs-params">c: C</span>): B &#123; <span class="hljs-keyword">return</span> c <span class="hljs-keyword">as</span> B &#125;<span class="hljs-title function_">clone</span>(c2b)<span class="hljs-comment">// 报错</span></code></pre></div><h3 id="1-3-可赋值性"><a href="#1-3-可赋值性" class="headerlink" title="1.3 可赋值性"></a>1.3 可赋值性</h3><p>可赋值性是指：判断需要类型 B 的地方，是否可以用类型 A。也就是说，A 类型是否可以赋值给 B 类型。</p><p>规则如下：</p><p>首先判断 B 是不是枚举类型。如果不是枚举类型，比如：数组、对象、函数、类等等，满足下面任意条件时，A 类型可以赋值给 B 类型：</p><ol><li>A 是 B 的同类型或者子类型</li><li>A 是 any</li></ol><p>如果 B 是枚举类型，满足下面任意条件时，A 类型可以赋值给枚举类型 B：</p><ol><li><p>A 是枚举类型 B 的成员</p></li><li><p>B 至少有一个成员是 number 类型，而且 A 是 number 类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Foo</span> &#123;    X = <span class="hljs-number">1</span>,    Y = <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">let</span> a = <span class="hljs-number">3</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x: Foo</span>) &#123; &#125;<span class="hljs-title function_">fn</span>(a)</code></pre></div></li></ol><h3 id="1-4-类型拓宽"><a href="#1-4-类型拓宽" class="headerlink" title="1.4 类型拓宽"></a>1.4 类型拓宽</h3><p>声明可变的变量时，变量的类型会从字面值拓宽到基类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><span class="hljs-comment">// number</span><span class="hljs-keyword">let</span> b = <span class="hljs-literal">true</span><span class="hljs-comment">// boolean</span><span class="hljs-keyword">let</span> c = <span class="hljs-string">&#x27;c&#x27;</span><span class="hljs-comment">// string</span><span class="hljs-keyword">let</span> d = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;<span class="hljs-comment">// &#123;foo: string&#125;</span></code></pre></div><p>声明不可变的变量时，变量的类型不会拓宽：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-comment">// &#x27;a&#x27;</span><span class="hljs-keyword">const</span> b = <span class="hljs-number">0</span><span class="hljs-comment">// 0</span></code></pre></div><p>声明变量时显示注解字面值可以阻止 TS 进行类型拓宽：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> = <span class="hljs-number">10</span><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;foo&#x27;</span> = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span></code></pre></div><p>不声明类型，直接初始化为 null 或者 undefined，类型会被拓宽为 any：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">undefined</span><span class="hljs-comment">// any</span><span class="hljs-keyword">let</span> b = <span class="hljs-literal">null</span><span class="hljs-comment">// any</span></code></pre></div><p>但是该变量离开声明所在作用域时，会重新分配具体类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span><span class="hljs-comment">// any</span>    a = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-comment">// any</span>    <span class="hljs-keyword">return</span> a&#125;<span class="hljs-title function_">f</span>()<span class="hljs-comment">// 重新分配为 string 而不是 any</span></code></pre></div><h4 id="1-4-1-const-类型"><a href="#1-4-1-const-类型" class="headerlink" title="1.4.1 const 类型"></a>1.4.1 const 类型</h4><p>使用 const 类型作为类型断言，可以禁止类型拓宽：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span> &#125;   <span class="hljs-comment">// &#123;x: number&#125;</span><span class="hljs-keyword">let</span> b = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span> &#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>  <span class="hljs-comment">//&#123;readonly x: 10&#125;</span></code></pre></div><p>const 不仅会阻止类型拓宽，还会递归地把成员设置为 readonly。</p><h4 id="1-4-2-多余类型检查"><a href="#1-4-2-多余类型检查" class="headerlink" title="1.4.2 多余类型检查"></a>1.4.2 多余类型检查</h4><p><strong>多余属性检查</strong>：尝试将一个新鲜对象字面量类型 T 赋值给另一个类型 U 时，如果 T 中有不在 U 中的属性，TS 会报错。</p><p><strong>新鲜对象字面量</strong>：指 TS 从对象字面量中推导出的类型。如果对象字面量有类型断言，或者把对象字面量赋值给变量，那么新鲜对象字面量类型将会被拓宽到常规的对象类型，也就不能称其为新鲜对象字面量。</p><h3 id="1-5-细化"><a href="#1-5-细化" class="headerlink" title="1.5 细化"></a>1.5 细化</h3><p>TS 类型检查器在检查代码的过程中利用流程语句（if，？，||，…）和类型查询（typeof，instanceof，in）来<strong>细化</strong>类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 传入的 x 是 number|string|undefined 类型</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x?: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-comment">// 根据流程语句逐步细化</span><span class="hljs-comment">// 判断 x 是 undefined 的情况</span>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">undefined</span>) &#123;        <span class="hljs-keyword">return</span>    &#125;<span class="hljs-comment">// 判断 x 是 number 的情况</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x == <span class="hljs-string">&#x27;number&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">toPrecision</span>()    &#125;<span class="hljs-comment">// 这里的 x 只能是 string 类型</span>    <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>)&#125;</code></pre></div><h2 id="2-全面性检查"><a href="#2-全面性检查" class="headerlink" title="2. 全面性检查"></a>2. 全面性检查</h2><p>TS 类型检查器为确保所有情况被覆盖，会进行全面性检查。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// error TS2366: Function lacks ending return statement and return type does not include &#x27;undefined&#x27;.</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-string">&#x27;A&#x27;</span> | <span class="hljs-string">&#x27;B&#x27;</span> | <span class="hljs-string">&#x27;C&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">f: Foo</span>): <span class="hljs-title class_">Foo</span> &#123;    <span class="hljs-keyword">switch</span> (f) &#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>    &#125;    <span class="hljs-comment">// 这里缺少 return 返回语句</span>&#125;</code></pre></div><h2 id="3-断言"><a href="#3-断言" class="headerlink" title="3. 断言"></a>3. 断言</h2><p>当暂时无法向 TS 证明安全性时，可以使用断言来操作类型。</p><blockquote><p>断言不安全，应该尽量避免使用。</p></blockquote><h3 id="3-1-类型断言-as"><a href="#3-1-类型断言-as" class="headerlink" title="3.1 类型断言 as"></a>3.1 类型断言 as</h3><p>可以向类型检查器来断定一个类型是自身的超类型或者子类型，但是不能断定为不相关的类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> &#123;    <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; &#125;&#125;<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>()<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x: B</span>) &#123; &#125;<span class="hljs-title function_">fn</span>(b)<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">x: A</span>) &#123; &#125;<span class="hljs-title function_">fn1</span>(b <span class="hljs-keyword">as</span> A)<span class="hljs-comment">// 断言为超类型</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">x: C</span>) &#123; &#125;<span class="hljs-title function_">fn2</span>(b <span class="hljs-keyword">as</span> C)<span class="hljs-comment">// 断言为子类型</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123; &#125;<span class="hljs-title function_">fn3</span>(b <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>)<span class="hljs-comment">// 不能断言为不相关的类型</span></code></pre></div><p>另一种语法：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">fn1</span>(&lt;A&gt;b)<span class="hljs-comment">// 另一种语法</span><span class="hljs-title function_">fn2</span>(&lt;C&gt;b)<span class="hljs-comment">// 另一种语法</span></code></pre></div><h3 id="3-2-非空断言"><a href="#3-2-非空断言" class="headerlink" title="3.2 非空断言 !"></a>3.2 非空断言 !</h3><p>将可为空的类型断言为非空。比如将 T | undefined | null 断言为 T 而不是 undefined 或者 null。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 关闭对话框。通过 id 获取对话框 Dom，并将其从 Dom 树中移除</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Dialog</span> = &#123;    id?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">closeDialog</span>(<span class="hljs-params">dialog: Dialog</span>) &#123;    <span class="hljs-keyword">if</span> (!dialog) &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">removeFromDom</span>(            dialog,            <span class="hljs-comment">// 断言 dialog.id 非空</span>            <span class="hljs-comment">// 断言 document.getElementById() 一定返回非空值</span>            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(dialog.<span class="hljs-property">id</span>!)!        )    &#125;)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">removeFromDom</span>(<span class="hljs-params">dialog: Dialog, element: Element</span>) &#123;    <span class="hljs-comment">// 断言 element.parentNode 非空</span>    element.<span class="hljs-property">parentNode</span>!.<span class="hljs-title function_">removeChild</span>(element)    <span class="hljs-keyword">delete</span> dialog.<span class="hljs-property">id</span>&#125;</code></pre></div><h3 id="3-3-明确赋值断言"><a href="#3-3-明确赋值断言" class="headerlink" title="3.3 明确赋值断言 !"></a>3.3 明确赋值断言 !</h3><p>TS 通过明确赋值检查来确保使用变量时已经为其赋值。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>id.<span class="hljs-title function_">toLowerCase</span>()<span class="hljs-comment">// 报错</span></code></pre></div><p>如果通过 getID() 来给 id 赋值：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">id</span>:<span class="hljs-built_in">string</span><span class="hljs-title function_">getID</span>()<span class="hljs-comment">// 执行后， id 已有值</span>id.<span class="hljs-title function_">toLowerCase</span>()<span class="hljs-comment">// 不过，这里还是会报错</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getID</span>(<span class="hljs-params"></span>)&#123;    id = <span class="hljs-string">&#x27;001&#x27;</span>&#125;</code></pre></div><p>可以通过明确赋值断言来告诉 TS，在读取 id 的时候，肯定已经为其赋值了：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> id!:<span class="hljs-built_in">string</span><span class="hljs-comment">// 明确赋值断言</span><span class="hljs-title function_">getID</span>()id.<span class="hljs-title function_">toLowerCase</span>()<span class="hljs-comment">// 这里不会报错</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getID</span>(<span class="hljs-params"></span>)&#123;    id = <span class="hljs-string">&#x27;001&#x27;</span>&#125;</code></pre></div><h2 id="4-对象类型进阶"><a href="#4-对象类型进阶" class="headerlink" title="4. 对象类型进阶"></a>4. 对象类型进阶</h2><h3 id="4-1-对象类型的类型运算符"><a href="#4-1-对象类型的类型运算符" class="headerlink" title="4.1 对象类型的类型运算符"></a>4.1 对象类型的类型运算符</h3><p>类型运算符不只有并集 | 和交集 &amp; 两种。</p><h4 id="4-1-1-键入运算符"><a href="#4-1-1-键入运算符" class="headerlink" title="4.1.1 键入运算符 []"></a>4.1.1 键入运算符 []</h4><p>使用方括号表示法，可以在结构中查找类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyResponse</span> = &#123;    <span class="hljs-attr">user</span>: &#123;        <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>,        <span class="hljs-attr">friendList</span>: &#123;            <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>,            <span class="hljs-attr">friends</span>: &#123;                <span class="hljs-attr">bar</span>: <span class="hljs-built_in">string</span>,                <span class="hljs-attr">baz</span>: <span class="hljs-built_in">string</span>            &#125;[]        &#125;    &#125;&#125;<span class="hljs-comment">// 键入运算符，只能使用方括号语法，不能使用点语法</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">FriendList</span> = <span class="hljs-title class_">MyResponse</span>[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;friendList&#x27;</span>]</code></pre></div><h4 id="4-1-2-keyof-运算符"><a href="#4-1-2-keyof-运算符" class="headerlink" title="4.1.2 keyof 运算符"></a>4.1.2 keyof 运算符</h4><p>keyof 运算符可以获取对象所有键的类型，并合并为一个<strong>字符字面量</strong>类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyResponse</span> = &#123;    <span class="hljs-attr">user</span>: &#123;        <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>,        <span class="hljs-attr">friendList</span>: &#123;            <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>,            <span class="hljs-attr">friends</span>: &#123;                <span class="hljs-attr">bar</span>: <span class="hljs-built_in">string</span>,                <span class="hljs-attr">baz</span>: <span class="hljs-built_in">string</span>            &#125;[]        &#125;    &#125;&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyResponseKeys</span> = keyof <span class="hljs-title class_">MyResponse</span>      <span class="hljs-comment">// &#x27;user&#x27;</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">UserKeys</span> = keyof <span class="hljs-title class_">MyResponse</span>[<span class="hljs-string">&#x27;user&#x27;</span>]    <span class="hljs-comment">// &#x27;friendList&#x27; | &#x27;id&#x27;</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">FriendListLeys</span> = keyof <span class="hljs-title class_">MyResponse</span>[<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;friendList&#x27;</span>]    <span class="hljs-comment">// &#x27;count&#x27; | &#x27;friends&#x27;</span></code></pre></div><p>键入运算符和 keyof 运算符强大的地方在于，可以准确、安全地描述结构类型。</p><h3 id="4-2-映射类型"><a href="#4-2-映射类型" class="headerlink" title="4.2 映射类型"></a>4.2 映射类型</h3><p>TS 提供了类型更安全的映射类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Weekday</span> = <span class="hljs-string">&#x27;Mon&#x27;</span> | <span class="hljs-string">&#x27;Tue&#x27;</span> | <span class="hljs-string">&#x27;Wed&#x27;</span> | <span class="hljs-string">&#x27;Thu&#x27;</span> | <span class="hljs-string">&#x27;Fri&#x27;</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Day</span> = <span class="hljs-title class_">Weekday</span> | <span class="hljs-string">&#x27;Sat&#x27;</span> | <span class="hljs-string">&#x27;Sun&#x27;</span><span class="hljs-keyword">let</span> <span class="hljs-attr">nextDay</span>: &#123; [K <span class="hljs-keyword">in</span> <span class="hljs-title class_">Weekday</span>]: <span class="hljs-title class_">Day</span> &#125; = &#123;    <span class="hljs-title class_">Mon</span>: <span class="hljs-string">&#x27;Tue&#x27;</span>,    <span class="hljs-title class_">Tue</span>: <span class="hljs-string">&quot;Wed&quot;</span>,    <span class="hljs-title class_">Wed</span>: <span class="hljs-string">&quot;Thu&quot;</span>,    <span class="hljs-title class_">Thu</span>: <span class="hljs-string">&quot;Fri&quot;</span>,    <span class="hljs-title class_">Fri</span>: <span class="hljs-string">&quot;Sat&quot;</span>&#125;</code></pre></div><h4 id="内置的映射类型"><a href="#内置的映射类型" class="headerlink" title="内置的映射类型"></a>内置的映射类型</h4><p>TS 内置了一些映射类型：</p><ol><li>Record&lt; Keys, Values&gt;：键的类型为 Keys，值的类型为 Values 的对象。</li><li>Partial&lt; Object &gt;：把 Object 中的每个字段都标记为可选的。</li><li>Required&lt; Object &gt;：把 Object 中每个字段都标记为必须的。</li><li>Readonly&lt; Object &gt;：把 Object 中每个字段都标记成只读的。</li><li>Pick&lt; Object, Keys&gt;：返回 Object 的子类型，只含指定的 keys。</li></ol><p>举例：<strong>Record 类型</strong>。TS 内置的 Record 类型可以用来描述有映射关系的对象。</p><p>与常规的对象索引签名相比，Record 提供了更多的便利：使用常规的索引签名可以约束对象中值的类型，但是键只能用 string、number 或 symbol 类型；使用 Record 还可以约束对象的键为 string 和 number 的子类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Weekday</span> = <span class="hljs-string">&#x27;Mon&#x27;</span> | <span class="hljs-string">&#x27;Tue&#x27;</span> | <span class="hljs-string">&#x27;Wed&#x27;</span> | <span class="hljs-string">&#x27;Thu&#x27;</span> | <span class="hljs-string">&#x27;Fri&#x27;</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Day</span> = <span class="hljs-title class_">Weekday</span> | <span class="hljs-string">&#x27;Sat&#x27;</span> | <span class="hljs-string">&#x27;Sun&#x27;</span><span class="hljs-keyword">let</span> <span class="hljs-attr">nextDay</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Weekday</span>, <span class="hljs-title class_">Day</span>&gt; = &#123;    <span class="hljs-string">&#x27;Mon&#x27;</span>: <span class="hljs-string">&#x27;Tue&#x27;</span>,    <span class="hljs-string">&#x27;Tue&#x27;</span>: <span class="hljs-string">&#x27;Wed&#x27;</span>,    <span class="hljs-string">&#x27;Wed&#x27;</span>: <span class="hljs-string">&#x27;Thu&#x27;</span>,    <span class="hljs-string">&#x27;Thu&#x27;</span>: <span class="hljs-string">&#x27;Fri&#x27;</span>,    <span class="hljs-string">&#x27;Fri&#x27;</span>: <span class="hljs-string">&#x27;Sat&#x27;</span>&#125;</code></pre></div><h2 id="5-函数类型进阶"><a href="#5-函数类型进阶" class="headerlink" title="5. 函数类型进阶"></a>5. 函数类型进阶</h2><h3 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h3><p>类型细化的能力有限，只能细化当前作用域中变量的类型，一旦离开这个作用域，类型细化的能力不会带到新的作用域中：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">a: <span class="hljs-built_in">unknown</span></span>): <span class="hljs-built_in">boolean</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">string</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isString</span>(input)) &#123;        <span class="hljs-comment">// 报错，TS 无法推导出 input 是 string 类型</span>    <span class="hljs-comment">// isString 函数内部对类型的细化无法带到新的作用域</span>        res = input.<span class="hljs-title function_">toUpperCase</span>()    &#125;    res = input.<span class="hljs-title function_">toString</span>()    <span class="hljs-keyword">return</span> res&#125;</code></pre></div><p>可以自定义<strong>类型防护措施</strong>，来告诉类型检查器当返回 true 时，表明传给 isString() 的是字符串：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 类型防护措施</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">a: <span class="hljs-built_in">unknown</span></span>): a is <span class="hljs-built_in">string</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">string</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isString</span>(input)) &#123;        res = input.<span class="hljs-title function_">toUpperCase</span>()    &#125;    res = input.<span class="hljs-title function_">toString</span>()    <span class="hljs-keyword">return</span> res&#125;</code></pre></div><p>如果函数细化了参数的类型，而且返回一个布尔值。那么可以使用 is 运算符来自定义类型防护措施，确保类型的细化能在作用域之间转移，在使用该函数的任何地方都可以使用。</p><h2 id="6-条件类型"><a href="#6-条件类型" class="headerlink" title="6. 条件类型"></a>6. 条件类型</h2><p>条件类型的语法和三元表达式差不多，只是运算位于类型层面：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IsString</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><span class="hljs-keyword">type</span> A = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-built_in">string</span>&gt;<span class="hljs-comment">// true</span><span class="hljs-keyword">type</span> B = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-built_in">number</span>&gt;<span class="hljs-comment">// false</span></code></pre></div><h3 id="6-1-条件分配"><a href="#6-1-条件分配" class="headerlink" title="6.1 条件分配"></a>6.1 条件分配</h3><p>条件类型遵循分配率：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> T = <span class="hljs-built_in">number</span><span class="hljs-keyword">type</span> A = <span class="hljs-built_in">string</span><span class="hljs-keyword">type</span> B = <span class="hljs-built_in">boolean</span><span class="hljs-comment">// Foo 和 Bar 等价</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>) <span class="hljs-keyword">extends</span> T ? A : B<span class="hljs-keyword">type</span> <span class="hljs-title class_">Bar</span> = (<span class="hljs-built_in">string</span> <span class="hljs-keyword">extends</span> T ? A : B) | (<span class="hljs-built_in">number</span> <span class="hljs-keyword">extends</span> T ? A : B)</code></pre></div><h3 id="6-2-infer-关键字"><a href="#6-2-infer-关键字" class="headerlink" title="6.2 infer 关键字"></a>6.2 infer 关键字</h3><p>可以在条件中使用 infer 关键字来声明泛型。TS 可以根据传入的类型进行推断：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[] ? T[<span class="hljs-built_in">number</span>] : T<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-built_in">number</span>[]&gt; <span class="hljs-comment">// number</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> (infer U)[] ? U : T<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-built_in">number</span>[]&gt;<span class="hljs-comment">// number</span></code></pre></div><h3 id="6-3-内置的条件类型"><a href="#6-3-内置的条件类型" class="headerlink" title="6.3 内置的条件类型"></a>6.3 内置的条件类型</h3><ol><li>Exclude&lt;T, U&gt;：计算在 T 中而不在 U 中的类型</li><li>Extract&lt;T, U&gt;：计算 T 中可复制给 U 的类型</li><li>NonNullable&lt; T &gt;：从 T 中排除 null 和 undefined</li><li>ReturnType&lt; F &gt;：计算函数的返回类型</li><li>InstanceType&lt; C &gt;：计算类构造方法的实例</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【TypeScript编程】3.类和接口</title>
    <link href="/archives/8e137a64.html"/>
    <url>/archives/8e137a64.html</url>
    
    <content type="html"><![CDATA[<h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><h2 id="1-访问修饰符"><a href="#1-访问修饰符" class="headerlink" title="1. 访问修饰符"></a>1. 访问修饰符</h2><p>TS 中类的属性和方法支持三种访问修饰符：</p><ol><li>public。任何地方都可以访问。默认。</li><li>protected。可由当前类及其子类访问。</li><li>privite。只可由当前类的实例进行访问。</li></ol><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;    <span class="hljs-comment">// 在构造方法的参数列表中声明</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><span class="hljs-params">        <span class="hljs-keyword">private</span> x: <span class="hljs-built_in">string</span>,</span><span class="hljs-params">        <span class="hljs-keyword">protected</span> y: <span class="hljs-built_in">string</span>,</span><span class="hljs-params">        <span class="hljs-keyword">public</span> z: <span class="hljs-built_in">string</span></span><span class="hljs-params">    </span>) &#123; &#125;        <span class="hljs-title function_">sayX</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>)    &#125;&#125;<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>)<span class="hljs-comment">// error TS2341: Property &#x27;x&#x27; is private and only accessible within class &#x27;Foo&#x27;.</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">x</span>) <span class="hljs-comment">//  error TS2445: Property &#x27;y&#x27; is protected and only accessible within class &#x27;Foo&#x27; and its subclasses.</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">y</span>) <span class="hljs-comment">// 可访问</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">z</span>)</code></pre></div><p>实例属性可以在构造方法的参数中声明，也可以通过属性初始化语句来声明：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;    <span class="hljs-comment">// 在属性初始化语句中声明</span>    <span class="hljs-keyword">private</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>    <span class="hljs-keyword">protected</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;y&#x27;</span>    <span class="hljs-attr">z</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>&#125;</code></pre></div><h2 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h2><p>如果想定义一个类，但是不想让用户直接实例化，而是在此基础上进行扩展。可以使用 abstract 关键字：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;&#125;</code></pre></div><p>抽象类中可以有抽象属性和抽象方法：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;    <span class="hljs-keyword">abstract</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>    y = <span class="hljs-number">10</span>    <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">sayX</span>(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-comment">// 实现抽象类时，必须实现抽象属性和抽象方法</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Foo</span> &#123;    x = <span class="hljs-number">8</span>    <span class="hljs-title function_">sayX</span>(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>)    &#125;&#125;<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FooImpl</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">x</span>)<span class="hljs-comment">// 8</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">y</span>)<span class="hljs-comment">// 10</span></code></pre></div><h2 id="3-类中使用-this-作为返回类型"><a href="#3-类中使用-this-作为返回类型" class="headerlink" title="3. 类中使用 this 作为返回类型"></a>3. 类中使用 this 作为返回类型</h2><p>对于类来说，this 类型可以用作方法的返回类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 模拟 Set 类，其中 add 方法返回一个和该类相同的类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySet</span> &#123;    <span class="hljs-title function_">add</span>(<span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>): <span class="hljs-variable language_">this</span> &#123;    <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><p>这样子类对其继承时，无需覆盖掉方法签名：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 继承自 MySet 类后，如果不覆写 add 方法，那么不会返回该类型而是返回 MySet。</span><span class="hljs-comment">// 所以在 SubMySet 类中，必须覆写 add 方法</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySet</span> &#123;    <span class="hljs-title function_">add</span>(<span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">MySet</span> &#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubMySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">MySet</span> &#123;    <span class="hljs-title function_">add</span>(<span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">SubMySet</span> &#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 使用 this 可以解决这个问题</span><span class="hljs-comment">// 在 MySet 中，this 指向 MySet 的实例；在 SubMySet 中，this 指向 SubMySet 的实例</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySet</span> &#123;    <span class="hljs-title function_">add</span>(<span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>): <span class="hljs-variable language_">this</span> &#123;    <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-comment">// 无需覆写 add 方法</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubMySet</span> &#123;&#125;</code></pre></div><h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4. 接口"></a>4. 接口</h2><p>与<strong>类型别名</strong>相似，接口也是一种命名类型的方式。接口和类型别名算是一种概念的两种句法，稍稍有些差别：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = &#123;    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">z</span>: <span class="hljs-built_in">boolean</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span>&#123;    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">z</span>: <span class="hljs-built_in">boolean</span>&#125;</code></pre></div><p>类型别名和接口的区别：</p><ol><li><p>类型别名更通用，右边可以是任何类型；在接口声明中，右边必须是结构：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// A 和 B 无法使用接口声明</span><span class="hljs-keyword">type</span> A = <span class="hljs-built_in">number</span><span class="hljs-keyword">type</span> B = A &amp; <span class="hljs-built_in">string</span></code></pre></div></li><li><p>扩展接口时，TS 会检查扩展接口是否可以赋值给被扩展的接口，如果不可以会报错。</p><p>使用交集类型时不会出现这个问题。 使用交集运算符 &amp;，TS 会尽量将扩展和被扩展的类型组合到一起，结果是重载签名。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">interface</span> B <span class="hljs-keyword">extends</span> A &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span><span class="hljs-comment">// 报错</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> A = &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> B = A &amp; &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>&#125;</code></pre></div></li><li><p>同一作用域中的多个同名接口将自动合并；同一作用域中的多个同名类型别名会导致编译错误：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 同名接口自动合并</span><span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: A = &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>&#125;,    <span class="hljs-title function_">bar</span>(<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 同名类型别名，报错</span><span class="hljs-keyword">type</span> A = &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">//  error TS2300: Duplicate identifier &#x27;A&#x27;.</span><span class="hljs-keyword">type</span> A = &#123;    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>&#125;</code></pre></div></li></ol><h3 id="4-1-声明合并"><a href="#4-1-声明合并" class="headerlink" title="4.1 声明合并"></a>4.1 声明合并</h3><p>TS 会自动把多个同名声明组合到一起。</p><p>声明两个同名接口：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: A = &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>&#125;,    <span class="hljs-title function_">bar</span>(<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>&#125;&#125;</code></pre></div><p>但是，两个同名的接口不能有冲突：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span><span class="hljs-comment">// 报错</span>&#125;</code></pre></div><p>如果接口中声明了泛型，那么两个接口中要使用<strong>完全相同</strong>的方式来声明泛型，这样才能合并接口：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Uer</span>&lt;<span class="hljs-title class_">Age</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; &#123;    <span class="hljs-attr">age</span>: <span class="hljs-title class_">Age</span>&#125;<span class="hljs-comment">// 泛型的名字也必须一样</span><span class="hljs-comment">// error TS2428: All declarations of &#x27;Uer&#x27; must have identical type parameters.</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Uer</span>&lt;<span class="hljs-title class_">MyAge</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; &#123;    <span class="hljs-attr">age</span>: <span class="hljs-title class_">MyAge</span>&#125;</code></pre></div><h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h3><p>声明类时，可以使用 implements 关键字来指明该类实现某个接口。类必须实现接口中声明的<strong>所有</strong>属性和方法。在此基础上可以实现其他的属性和方法。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;    <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">FooImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Foo</span> &#123;    num = <span class="hljs-number">10</span>    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123; &#125;    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123; &#125;&#125;</code></pre></div><p>接口可以声明实例属性，但是不能带有可见性修饰符（private，protected，public），也不能使用 static 关键字。但是可以使用 readonly 将实例属性标记为已读。</p><p>一个类可以实现多个接口：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">interface</span> B &#123;    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> A, B &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123; &#125;    <span class="hljs-title function_">bar</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123; &#125;&#125;</code></pre></div><h2 id="5-类是结构化类型"><a href="#5-类是结构化类型" class="headerlink" title="5. 类是结构化类型"></a>5. 类是结构化类型</h2><p>TS 会根据<strong>结构</strong>比较类，与类的<strong>名称</strong>无关。两个类根据结构来决定是否兼容；对象如果定义了相同的属性或者方法，也会和类兼容。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x: A</span>) &#123;    x.<span class="hljs-title function_">foo</span>()&#125;<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>()<span class="hljs-title function_">bar</span>(a)<span class="hljs-title function_">bar</span>(b)</code></pre></div><p>但是，当类中有 private 和 protected 修饰的字段时，情况不同。检查一个结构是否可以赋值给一个类时，如果类中有 private 和 protected 修饰的字段，而且结构不是类或者子类的实例，那么结构就不能赋值给类：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;    <span class="hljs-keyword">private</span> x = <span class="hljs-number">1</span><span class="hljs-comment">// 属性 x 被 private 修饰</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123; &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a: A</span>) &#123; &#125;<span class="hljs-title function_">f</span>(<span class="hljs-keyword">new</span> A)<span class="hljs-title function_">f</span>(<span class="hljs-keyword">new</span> B)<span class="hljs-title function_">f</span>(&#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> &#125;)<span class="hljs-comment">// 报错</span></code></pre></div><h2 id="6-类和接口的泛型"><a href="#6-类和接口的泛型" class="headerlink" title="6. 类和接口的泛型"></a>6. 类和接口的泛型</h2><p>类和接口也支持泛型，泛型的作用域可以放在整个类或者接口中，也可以放在特定的方法中：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMap</span>&lt;K, V&gt;&#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initKey: K, initVal: V</span>) &#123;    <span class="hljs-comment">// 构造函数... </span>    &#125;    <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: K): V &#123;    <span class="hljs-comment">// 实例方法...</span>    &#125;    <span class="hljs-title function_">set</span>(<span class="hljs-params">key: K, val: V</span>) &#123;    <span class="hljs-comment">// ... </span>    &#125;    merge&lt;<span class="hljs-variable constant_">K1</span>, <span class="hljs-variable constant_">V1</span>&gt;(<span class="hljs-attr">map</span>: <span class="hljs-title class_">MyMap</span>&lt;<span class="hljs-variable constant_">K1</span>, <span class="hljs-variable constant_">V1</span>&gt;): <span class="hljs-title class_">MyMap</span>&lt;K | <span class="hljs-variable constant_">K1</span>, V | <span class="hljs-variable constant_">V1</span>&gt; &#123;     <span class="hljs-comment">// 实例方法...</span>    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>&lt;K, V&gt;(<span class="hljs-attr">k</span>:K, <span class="hljs-attr">v</span>:V): <span class="hljs-title class_">MyMap</span>&lt;K, V&gt;&#123;        <span class="hljs-comment">// 静态方法...</span>    &#125;&#125;</code></pre></div><p>当泛型的作用域是整个类时，泛型可以在每个实例方法和属性中使用。</p><p>构造函数中不能声明泛型，只能在类声明中声明泛型。</p><p>实例方法可以访问类一级的泛型，也可以自己声明泛型。</p><p>静态方法不能访问类的泛型，但是可以自己声明泛型。</p><p>接口绑定泛型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMap</span>&lt;K, V&gt; &#123;    <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: K): V    <span class="hljs-title function_">set</span>(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">val</span>: V): <span class="hljs-built_in">void</span>&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【TypeScript编程】2.函数</title>
    <link href="/archives/414e05a8.html"/>
    <url>/archives/414e05a8.html</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-声明与调用"><a href="#1-声明与调用" class="headerlink" title="1. 声明与调用"></a>1. 声明与调用</h2><p>显式注解函数参数类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-keyword">return</span> a + b&#125;</code></pre></div><p>TS 可以推导出返回类型，也可以对返回类型进行显式注解：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>):<span class="hljs-built_in">number</span> &#123;    <span class="hljs-keyword">return</span> a + b&#125;</code></pre></div><p>多种函数声明方法：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 具名函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-keyword">return</span> foo + <span class="hljs-string">&#x27;!&#x27;</span>&#125;<span class="hljs-comment">// 函数表达式</span><span class="hljs-keyword">let</span> fn2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">foo: <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-keyword">return</span> foo + <span class="hljs-string">&#x27;!&#x27;</span>&#125;<span class="hljs-comment">// 箭头函数</span><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn3</span> = (<span class="hljs-params">foo: <span class="hljs-built_in">number</span></span>) =&gt; &#123;    <span class="hljs-keyword">return</span> foo + <span class="hljs-string">&#x27;!&#x27;</span>&#125;<span class="hljs-comment">// 箭头函数简写形式</span><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn4</span> = (<span class="hljs-params">foo: <span class="hljs-built_in">number</span></span>) =&gt; foo + <span class="hljs-string">&#x27;!&#x27;</span></code></pre></div><h3 id="1-1-可选参数"><a href="#1-1-可选参数" class="headerlink" title="1.1 可选参数"></a>1.1 可选参数</h3><p>可以使用 ? 将参数标记为可选的。可选参数必须放在参数列表的末尾：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a:<span class="hljs-built_in">number</span>, b:<span class="hljs-built_in">number</span>, c?:<span class="hljs-built_in">number</span></span>)&#123;    <span class="hljs-keyword">return</span> a + b + (c || <span class="hljs-number">0</span>)&#125;</code></pre></div><h3 id="1-2-参数默认值"><a href="#1-2-参数默认值" class="headerlink" title="1.2 参数默认值"></a>1.2 参数默认值</h3><p>可以为参数提供默认值，这样调用时可以不用传入参数的值，达到可选参数的效果：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>, c = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-keyword">return</span> a + b + c&#125;</code></pre></div><p>带默认值的参数不要求放在参数列表的末尾：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a = <span class="hljs-number">1</span>, b: <span class="hljs-built_in">number</span>, c = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-keyword">return</span> a + b + c&#125;</code></pre></div><h3 id="1-3-剩余参数"><a href="#1-3-剩余参数" class="headerlink" title="1.3 剩余参数"></a>1.3 剩余参数</h3><p>使用 arguments 对象来接收数量不定的参数可能导致不安全：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 将数量不定的参数全放入一个数组</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) &#123;   <span class="hljs-comment">// 安全，TS 可以推导出 sum 和 n 都是 number</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(nums).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, n</span>) =&gt;</span> sum + n)&#125;<span class="hljs-comment">// 使用 arguments 来接收数量不定的参数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add2</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 不安全， TS 无法推导出 sum 和 n 的类型，只能推导出 any。</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, n</span>) =&gt;</span> sum + n)&#125;<span class="hljs-comment">// TS 会认为 add2 函数不需要参数，这里传参会报错。</span><span class="hljs-comment">// error TS2554: Expected 0 arguments, but got 3.</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))</code></pre></div><p><strong>剩余参数</strong>会将传入的不定长参数收集为一个数组，使用剩余参数可以保证函数的类型安全：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">...nums: <span class="hljs-built_in">number</span>[]</span>) &#123;    <span class="hljs-keyword">return</span> nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, n</span>) =&gt;</span> sum + n)&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment">// 6</span></code></pre></div><p>一个参数列表中最多出现一个剩余参数，而且必须放在参数列表的最后：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">init: <span class="hljs-built_in">number</span>, ...nums: <span class="hljs-built_in">number</span>[]</span>) &#123;    <span class="hljs-keyword">return</span> nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, n</span>) =&gt;</span> sum + n, init)&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment">// 106</span></code></pre></div><h3 id="1-4-注解-this-的类型"><a href="#1-4-注解-this-的类型" class="headerlink" title="1.4 注解 this 的类型"></a>1.4 注解 this 的类型</h3><p>安全起见，如果在函数中使用 this，需要在参数列表中声明 this 类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: &#123; bar: <span class="hljs-built_in">string</span> &#125;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>&#125;</code></pre></div><p>这里的 this 不是一般参数，而是保留字。</p><blockquote><p>TSC 配置项：noImplictThis</p><p>当 noImplictThis 为 true 时，必须显式注解 this。</p><p>noImplictThis 属于 strict 配置项。strict 为 true 时，无需单独配置 noImplictThis。</p></blockquote><h3 id="1-5-调用签名-x2F-函数类型"><a href="#1-5-调用签名-x2F-函数类型" class="headerlink" title="1.5 调用签名 &#x2F; 函数类型"></a>1.5 调用签名 &#x2F; 函数类型</h3><p>调用签名，也叫类型签名，是表示<strong>函数类型</strong>的句法：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fn</span> = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><span class="hljs-comment">// 此时，无需再次注解参数和返回值的类型</span><span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>: <span class="hljs-title class_">Fn</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> x - y &#125;</code></pre></div><p>调用签名只包含<strong>类型</strong>层面的代码，可以表示参数、this、返回值、剩余参数和可选参数的类型，但是无法表示默认值。调用签名必须显式注解。</p><p>上面的是简写形式，完整形式：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fn</span> = &#123;    (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>&#125;</code></pre></div><h3 id="1-6-上下文类型推导"><a href="#1-6-上下文类型推导" class="headerlink" title="1.6 上下文类型推导"></a>1.6 上下文类型推导</h3><p>TS 能从上下文中进行类型推导，比如使用调用签名后不必再次注解参数的类型。TS 会尽可能根据上下文来推导出缺失的类型标注。</p><h3 id="1-7-函数类型重载"><a href="#1-7-函数类型重载" class="headerlink" title="1.7 函数类型重载"></a>1.7 函数类型重载</h3><p>TS 支持动态重载函数声明，函数的输出类型取决于输入类型。</p><h2 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h2><p>泛型参数是在类型层面施加约束的占位类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义一个过滤函数的调用签名</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filter</span> = &#123;    &lt;T&gt;(<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">f</span>:<span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>): T[]&#125;</code></pre></div><p>T 就像一个占位类型，类型检查器将根据上下文来填充具体的类型。一般来说，从 T 开始对泛型类型进行命名：T、U、V。</p><p>每次调用函数都会对 T 进行重新绑定：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filter</span> = &#123;    &lt;T&gt;(<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">f</span>: <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>): T[]&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Filter</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">arr, f</span>) &#123;    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(f)&#125;<span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(arr1, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">3</span>))<span class="hljs-keyword">let</span> arr2 = [    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;,    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">5</span> &#125;,    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">7</span> &#125;,]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(arr2, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">age</span> &gt; <span class="hljs-number">6</span>))</code></pre></div><h3 id="2-1-泛型声明位置"><a href="#2-1-泛型声明位置" class="headerlink" title="2.1 泛型声明位置"></a>2.1 泛型声明位置</h3><p>声明泛型的位置限定了泛型的<strong>作用域</strong>以及什么时候给泛型绑定<strong>具体</strong>的类型。TS 会在<strong>使用</strong>泛型时为泛型绑定具体类型。</p><p><code>&lt;T&gt;</code> 在调用签名中声明，TS 会在调用函数时为 T 绑定具体类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filter</span> = &#123;    <span class="hljs-comment">// 调用签名中声明</span>    &lt;T&gt;(<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">f</span>: <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>): T[]&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Filter</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">arr, f</span>) &#123;    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(f)&#125;</code></pre></div><p><code>&lt;T&gt; </code> 在类型别名之后声明，TS 会要求在使用函数时显示绑定类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 在类型别名之后声明</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filter</span>&lt;T&gt; = &#123;    (<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">f</span>: <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>): T[]&#125;<span class="hljs-comment">// 显式绑定类型</span><span class="hljs-keyword">let</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Filter</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">arr, f</span>) &#123;    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(f)&#125;</code></pre></div><h3 id="2-2-调用签名中加入泛型"><a href="#2-2-调用签名中加入泛型" class="headerlink" title="2.2 调用签名中加入泛型"></a>2.2 调用签名中加入泛型</h3><p>所有调用签名都可以加入泛型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filter</span> = &#123;    &lt;T&gt;(<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">f</span>: <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>): T[]&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Filter</span> = <span class="hljs-comment">//...</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filter</span>&lt;T&gt; = &#123;    (<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">f</span>: <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>): T[]&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Filter</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-comment">//...</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filter</span> = &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">arr: T[], f: (item: T) =&gt; <span class="hljs-built_in">boolean</span></span>) =&gt;</span> T[]<span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>:<span class="hljs-title class_">Filter</span> = <span class="hljs-comment">//...</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filter</span>&lt;T&gt; = <span class="hljs-function">(<span class="hljs-params">arr: T[], f: (item: T) =&gt; <span class="hljs-built_in">boolean</span></span>) =&gt;</span> T[]<span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>:<span class="hljs-title class_">Filter</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-comment">//...</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> filter&lt;T&gt;(<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">f</span>: <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>): T[] &#123;    <span class="hljs-comment">//...</span>&#125;</code></pre></div><h3 id="2-3-泛型推导"><a href="#2-3-泛型推导" class="headerlink" title="2.3 泛型推导"></a>2.3 泛型推导</h3><p>多数情况下，TS 能够根据传入的参数推导出泛型的具体类型。也可以显式注解泛型，但是要么不注解，要么全注解：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> map&lt;T, U&gt;(<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">f</span>: <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> U): U[] &#123;    <span class="hljs-keyword">let</span> res = []    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;        res.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">f</span>(item))    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-comment">// 泛型可以推导出类型</span><span class="hljs-title function_">map</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span>)<span class="hljs-comment">// 也可以显式注解类型</span>map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span>)<span class="hljs-comment">// 不能只注解部分类型</span>map&lt;<span class="hljs-built_in">string</span>&gt;([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span>)<span class="hljs-comment">// error TS2558: Expected 2 type arguments, but got 1.</span></code></pre></div><h3 id="2-4-泛型别名"><a href="#2-4-泛型别名" class="headerlink" title="2.4 泛型别名"></a>2.4 泛型别名</h3><p>在类型别名中只有一个位置可以声明泛型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span>&lt;T&gt; = &#123;    <span class="hljs-attr">x</span>: T    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>&#125;</code></pre></div><p>使用这样的泛型时，必须要显式绑定类型参数，TS 无法推导出类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 显式绑定泛型</span><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-built_in">string</span>&gt; = &#123;    <span class="hljs-attr">x</span>: <span class="hljs-string">&#x27;x&#x27;</span>,    <span class="hljs-attr">y</span>: <span class="hljs-number">10</span>&#125;</code></pre></div><h3 id="2-5-泛型默认类型"><a href="#2-5-泛型默认类型" class="headerlink" title="2.5 泛型默认类型"></a>2.5 泛型默认类型</h3><p>可以为泛型指定一个默认类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyEvent</span>&lt;T = <span class="hljs-title class_">HTMLElement</span>&gt; = &#123;    <span class="hljs-attr">target</span>: T    <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>&#125;</code></pre></div><p>有默认值的泛型需要放在没有默认值的泛型后面：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyEvent</span>&lt;<span class="hljs-title class_">Type</span>, <span class="hljs-title class_">Target</span> = <span class="hljs-title class_">HTMLElement</span>&gt; = &#123;    <span class="hljs-attr">target</span>: <span class="hljs-title class_">Target</span>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Type</span>&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【TypeScript编程】1.类型全解</title>
    <link href="/archives/abde3393.html"/>
    <url>/archives/abde3393.html</url>
    
    <content type="html"><![CDATA[<h1 id="类型全解"><a href="#类型全解" class="headerlink" title="类型全解"></a>类型全解</h1><img src="../images/【TypeScript编程】1-类型全解/微信图片_20230421145958.jpg" alt="微信图片_20230421145958" style="zoom:50%;" /><h2 id="1-any"><a href="#1-any" class="headerlink" title="1. any"></a>1. any</h2><p>any 包含所有的值，而且可以对其做任何操作。当 TS 无法确定类型是什么时，默认为 any。</p><p>如果 TS 推导出值的类型为 any，会抛出运行时异常（编辑器中会显示红色波浪线）：</p><p><img src="/../images/%E3%80%90TypeScript%E7%BC%96%E7%A8%8B%E3%80%911-%E7%B1%BB%E5%9E%8B%E5%85%A8%E8%A7%A3/image-20230417155339885.png" alt="image-20230417155339885"></p><p>如果想使用 any，必须显示进行注解：</p><div class="code-wrapper"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a</span>: <span class="hljs-params">any</span>)&#123;&#125; <span class="hljs-comment">// 这样不会报错</span></code></pre></div><blockquote><p>TSC 配置项：noImplicitAny</p><p>当 noImplicitAny 为 true 时，不允许推导出隐式 any 类型。</p><p>noImplicitAny 属于 strict 配置项。strict 为 true 时，无需单独配置 noImplicitAny。</p></blockquote><h2 id="2-unknown"><a href="#2-unknown" class="headerlink" title="2. unknown"></a>2. unknown</h2><p>unknown 包含所有值，但是 TS 会要求对其检查并细化类型。unknown 可以比较、否定、使用 typeof 和 instanceof 进行细化类型。当确实无法预知一个值的类型时，应该使用 unknown，而不是 any。</p><p>TS 不会推导出 unknown 类型，必须显示注解：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">10</span></code></pre></div><p>执行操作时，不能假定 unknown 类型的值是某种特定类型，必须先细化类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">10</span><span class="hljs-keyword">let</span> b = a + <span class="hljs-number">10</span><span class="hljs-comment">// error TS18046: &#x27;a&#x27; is of type &#x27;unknown&#x27;.</span><span class="hljs-keyword">let</span> c = a <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span> + <span class="hljs-number">10</span> <span class="hljs-comment">// number</span></code></pre></div><h2 id="3-boolean"><a href="#3-boolean" class="headerlink" title="3. boolean"></a>3. boolean</h2><p>boolean 包含两个值：true 和 false。boolean 可以比较、否定。</p><p>可以让 TS 推导出值的类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x = <span class="hljs-literal">true</span> <span class="hljs-comment">// boolean</span></code></pre></div><p>一般<strong>不会</strong>将值的类型显示注解为 boolean：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// boolean</span></code></pre></div><p>可以让 TS 推导出值为某个具体的 boolean 值：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> a = <span class="hljs-literal">true</span><span class="hljs-comment">// true</span></code></pre></div><p>可以明确告诉 TS 值为某个具体的布尔值：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span><span class="hljs-comment">// true</span><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> = <span class="hljs-literal">false</span><span class="hljs-comment">// error TS2322: Type &#x27;false&#x27; is not assignable to type &#x27;true&#x27;.</span></code></pre></div><h3 id="类型字面量"><a href="#类型字面量" class="headerlink" title="类型字面量"></a>类型字面量</h3><p>上面的变量 a 和 b 不是普通的 boolean 类型，而是只为 true 的 boolean 类型。这种类型称为类型字面量，也就是仅仅表示一个值的类型。</p><h2 id="4-number"><a href="#4-number" class="headerlink" title="4. number"></a>4. number</h2><p>number 包括所有的数字：整数、浮点数、Infinity、NaN。可以进行算数运算。</p><p>类型声明上和 boolean 一样，一般让 TS 自动推导出 number 类型，不会将值显示注解为 number。也可以将值的类型限制为某个值。</p><h2 id="5-bigint"><a href="#5-bigint" class="headerlink" title="5. bigint"></a>5. bigint</h2><p>bigint 包括所有的大整数。可以进行算数运算。</p><p>类型声明和 boolean、number 一样。</p><h2 id="6-string"><a href="#6-string" class="headerlink" title="6. string"></a>6. string</h2><p>string 包括所有的字符串。可以进行拼接、切片等操作。</p><p>类型声明和 boolean、number、bigint 一样。</p><h2 id="7-symbol"><a href="#7-symbol" class="headerlink" title="7. symbol"></a>7. symbol</h2><p>symbol 包括所有的符号。</p><p>可以让 TS 推导出值的类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// symbol</span></code></pre></div><p>使用 const 声明的符号， TS 会推导出 unique symbol 类型。但是在编辑器中会显示 typeof xxx，而不是 unique symbol：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> b = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// typeof b</span></code></pre></div><p>可以显示注解 const 变量的类型为 unique symbol：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">c</span>:unique <span class="hljs-built_in">symbol</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment">// typeof c</span></code></pre></div><h2 id="8-对象-object"><a href="#8-对象-object" class="headerlink" title="8. 对象 object"></a>8. 对象 object</h2><p>TS 的对象类型表示对象的结构。</p><p>可以指明变量的类型为 object，但是不常用，因为 TS 更关心对象的结构：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">object</span> = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;</code></pre></div><p>可以让 TS 自动推导出对象的结构：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = &#123;    <span class="hljs-attr">foo</span>: &#123;        <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;baz&#x27;</span>    &#125;&#125;</code></pre></div><p>可以在花括号中明确描述：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span> &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">10</span> &#125;</code></pre></div><p>使用 const 声明对象时，TS 不会把推导的类型缩窄：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> b = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">10</span> &#125;<span class="hljs-comment">// &#123;foo: number&#125; 而不是 &#123;foo: 10&#125;</span></code></pre></div><p>不可以添加额外属性或者缺少属性：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: &#123; <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span> &#125;c = &#123;&#125; <span class="hljs-comment">// error TS2741: Property &#x27;foo&#x27; is missing in type &#x27;&#123;&#125;&#x27; but required in type &#x27;&#123; foo: number; &#125;&#x27;.</span>c = &#123;    <span class="hljs-attr">foo</span>: <span class="hljs-number">10</span>,    <span class="hljs-attr">bar</span>: <span class="hljs-number">8</span>&#125;<span class="hljs-comment">// error TS2322: Type &#x27;&#123; foo: number; bar: number; &#125;&#x27; is not assignable to type &#x27;&#123; foo: number; &#125;&#x27;.</span></code></pre></div><h3 id="8-1-明确赋值"><a href="#8-1-明确赋值" class="headerlink" title="8.1 明确赋值"></a>8.1 明确赋值</h3><p>如果先声明变量再进行初始化，TS 需要确保使用变量时已经明确为其赋值：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>:<span class="hljs-built_in">number</span><span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span><span class="hljs-comment">// error TS2454: Variable &#x27;i&#x27; is used before being assigned.</span></code></pre></div><p>当没有显式注解时，TS 会强制进行类型检查：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> i <span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span><span class="hljs-comment">// error TS18048: &#x27;i&#x27; is possibly &#x27;undefined&#x27;.</span></code></pre></div><h3 id="8-2-可选属性"><a href="#8-2-可选属性" class="headerlink" title="8.2 可选属性"></a>8.2 可选属性</h3><p>默认情况下，TS 对属性的要求非常严格。但是也可以告诉 TS 某个属性可选，或者实际属性多于计划：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: &#123;    <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>,    bar?: <span class="hljs-built_in">string</span>,<span class="hljs-comment">// 可选属性</span>    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">boolean</span><span class="hljs-comment">//索引签名</span>&#125;</code></pre></div><p>表示属性 foo 是必要的，bar 是可选的，还可以有<strong>任意多</strong>的数字属性。</p><p><code>myKey?: T </code>，表示类型为 T 的 myKey 这个属性是可选属性。</p><h3 id="8-3-索引签名"><a href="#8-3-索引签名" class="headerlink" title="8.3 索引签名"></a>8.3 索引签名</h3><p><code>[ key: T ]: U</code>，表示类型为 T 的键，对应值的类型为 U 。可以有任意多个 类型为 T 的键。不过，键的类型 T 必须可以赋值给 number 或者 string。</p><h3 id="8-4-只读属性"><a href="#8-4-只读属性" class="headerlink" title="8.4 只读属性"></a>8.4 只读属性</h3><p>可以使用 readonly 修饰符将某个属性标记为只读。指明为属性赋予初始值之后便无法修改。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: &#123;    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>&#125; = &#123;    <span class="hljs-attr">foo</span>: <span class="hljs-number">10</span>&#125;obj.<span class="hljs-property">foo</span> = <span class="hljs-number">8</span> <span class="hljs-comment">// error TS2540: Cannot assign to &#x27;foo&#x27; because it is a read-only property.</span></code></pre></div><h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9. 数组"></a>9. 数组</h2><p>TS  中数组是特殊类型的对象。可以对其拼接、搜索、切片等等。使用数组类型时，应尽量保证元素的类型相同。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">// number[]</span><span class="hljs-keyword">let</span> b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<span class="hljs-comment">// string[]</span><span class="hljs-keyword">let</span> c = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">// (string | number)[]</span><span class="hljs-keyword">let</span> <span class="hljs-attr">d</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">// 常用句法</span><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">&#x27;a&#x27;</span>] <span class="hljs-comment">// （长格式句法）两种声明数组类型的方法，无差别</span></code></pre></div><p>声明并初始化数组时，TS 会对数组中的元素类型进行判断：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>]<span class="hljs-comment">// number[]</span>a.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>)a.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">// error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>] <span class="hljs-comment">// (string | number)[]</span>a.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>)a.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;a&#x27;</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = []<span class="hljs-comment">// any[]</span>a.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>)a.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;a&#x27;</span>)a.<span class="hljs-title function_">push</span>(<span class="hljs-literal">true</span>)</code></pre></div><p>使用 const 声明数组时，TS 不会把推导的类型缩窄：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> x = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">// (string | number)[]</span>x[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>x[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span></code></pre></div><h2 id="10-元组"><a href="#10-元组" class="headerlink" title="10. 元组"></a>10. 元组</h2><p>元组是数组的子类型，表明数组长度固定，每个位置上元素的类型也固定。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]x[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span><span class="hljs-comment">// 可以就地修改元素</span>x[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-comment">// 报错，不可以改变该位置上的元素类型</span>x.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<span class="hljs-comment">// 可以新加元素</span>x.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;b&#x27;</span>)<span class="hljs-comment">// 报错，不可以新加不在声明中的元素类型</span></code></pre></div><p>为了避免和数组混淆，必须<strong>显示注解</strong>元组类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:[<span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>]<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>:[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">string</span>] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;a&#x27;</span>]</code></pre></div><p>元组支持可选元素：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>:[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>?][] = [    [<span class="hljs-number">1</span>],    [<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>],    [<span class="hljs-number">3</span>]]</code></pre></div><p>元组支持<strong>剩余元素</strong>，可以用来为元组定义最小长度：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">d</span>:[<span class="hljs-built_in">number</span>, ...<span class="hljs-built_in">number</span>[]] = [<span class="hljs-number">1</span>]<span class="hljs-comment">// 最少需要一个数字元素</span><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>:[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>, ...<span class="hljs-built_in">string</span>[]] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>] <span class="hljs-comment">// 最少需要一个数字，一个布尔值</span></code></pre></div><h3 id="只读数组"><a href="#只读数组" class="headerlink" title="只读数组"></a>只读数组</h3><p>只读数组类型用来创建<strong>不可变</strong>的数组。只读数组不能就地更改，如果想更改只读数组就必须使用非变型方法用其它变量接收（比如 .concat 和 .slice）。</p><p>必须<strong>显式注解</strong>只读数组：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-keyword">let</span> b = a.<span class="hljs-title function_">concat</span>(<span class="hljs-number">4</span>)<span class="hljs-keyword">let</span> c = a.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">// [1,2,3]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<span class="hljs-comment">// [1,2,3,4]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)<span class="hljs-comment">// [2,3]</span>a.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// error TS2339: Property &#x27;push&#x27; does not exist on type &#x27;readonly number[]&#x27;.</span></code></pre></div><p>长格式句法：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> A = <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">number</span>[]<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">number</span>&gt;<span class="hljs-keyword">type</span> C = <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-built_in">number</span>[]&gt;<span class="hljs-keyword">type</span> D = <span class="hljs-keyword">readonly</span> [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]<span class="hljs-keyword">type</span> E = <span class="hljs-title class_">Readonly</span>&lt;[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]&gt;</code></pre></div><h2 id="11-null-和-undefined"><a href="#11-null-和-undefined" class="headerlink" title="11. null 和 undefined"></a>11. null 和 undefined</h2><p>null 类型只有一个值 null；undefined 类型只有一个值 undefined。</p><h2 id="12-void-和-never"><a href="#12-void-和-never" class="headerlink" title="12. void 和 never"></a>12. void 和 never</h2><p>void 指函数没有显式返回值（比如 console.log），never 指函数根本不返回值（比如抛出异常或者死循环）。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">// 返回 void 的函数</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;&#125;&#125;<span class="hljs-comment">// 返回 never 的函数？</span></code></pre></div><h2 id="13-枚举"><a href="#13-枚举" class="headerlink" title="13. 枚举"></a>13. 枚举</h2><p>枚举用来列举类型中包含的各个值。可以看作把键映射到值上的无序数据结构，可以将字符串映射到字符串或者数字上。</p><blockquote><p>按约定，枚举名称使用大写单数形式，键也大写。</p></blockquote><p>举例：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Foo</span>,    <span class="hljs-title class_">Bar</span>,    <span class="hljs-title class_">Baz</span>&#125;</code></pre></div><p>TS 可以为枚举类型的成员自动推导出数字：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Foo</span> = <span class="hljs-number">0</span>,    <span class="hljs-title class_">Bar</span> = <span class="hljs-number">1</span>,    <span class="hljs-title class_">Baz</span> = <span class="hljs-number">2</span>&#125;</code></pre></div><p>也可以自己指定数字：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Foo</span> = <span class="hljs-number">100</span>,    <span class="hljs-title class_">Bar</span> = <span class="hljs-number">200</span>,    <span class="hljs-title class_">Baz</span> = <span class="hljs-number">201</span>&#125;</code></pre></div><p>是可以使用点或者方括号语法来访问枚举值：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Person</span>.<span class="hljs-property">Foo</span><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&#x27;Bar&#x27;</span>]</code></pre></div><p>可以分开声明枚举值。但是，由于 TS 只能推导出一部分值，最好给每个成员显式赋值：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Foo</span> = <span class="hljs-number">0</span>&#125;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Bar</span> = <span class="hljs-number">1</span>,    <span class="hljs-title class_">Baz</span> = <span class="hljs-number">2</span>&#125;</code></pre></div><p>可以只给部分成员赋值，TS 会<strong>尽力</strong>推导出值：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Foo</span> = <span class="hljs-number">100</span>,    <span class="hljs-title class_">Bar</span> = <span class="hljs-number">150</span>,    <span class="hljs-title class_">Baz</span><span class="hljs-comment">// TS 会推导出 151</span>&#125;</code></pre></div><p>值可以是字符串或者数字或者混用：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Foo</span> = <span class="hljs-string">&#x27;foo&#x27;</span>,    <span class="hljs-title class_">Bar</span> = <span class="hljs-number">150</span>,    <span class="hljs-title class_">Baz</span> = <span class="hljs-string">&#x27;baz&#x27;</span>&#125;</code></pre></div><p>不安全的访问操作：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Foo</span>,    <span class="hljs-title class_">Bar</span>,    <span class="hljs-title class_">Baz</span>&#125;<span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Person</span>[<span class="hljs-number">3</span>]<span class="hljs-comment">// string</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">// undefined</span></code></pre></div><p>可以使用 const enum 指定使用枚举的安全子集：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title class_">Foo</span>,    <span class="hljs-title class_">Bar</span>,    <span class="hljs-title class_">Baz</span>&#125;<span class="hljs-comment">// error TS2476: A const enum member can only be accessed using a string literal.</span><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Person</span>[<span class="hljs-number">3</span>]</code></pre></div><blockquote><p>枚举容易导致出现安全问题，建议远离枚举。</p></blockquote><h1 id="类型别名、并集和交集"><a href="#类型别名、并集和交集" class="headerlink" title="类型别名、并集和交集"></a>类型别名、并集和交集</h1><h2 id="1-类型别名-type"><a href="#1-类型别名-type" class="headerlink" title="1. 类型别名 type"></a>1. 类型别名 type</h2><p>使用 type 给类型声明别名：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Age</span> = <span class="hljs-built_in">number</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-title class_">Age</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span> = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>&#125;</code></pre></div><p>同一类型不能声明两次：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Age</span> = <span class="hljs-built_in">number</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Age</span> = <span class="hljs-built_in">number</span> <span class="hljs-comment">// error TS2300: Duplicate identifier &#x27;Age&#x27;.</span></code></pre></div><p>类型别名采用<strong>块级作用域</strong>：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-built_in">number</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-built_in">string</span>    <span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">Foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-title class_">Foo</span> = <span class="hljs-number">10</span></code></pre></div><h2 id="2-并集-amp-和交集"><a href="#2-并集-amp-和交集" class="headerlink" title="2. 并集 &amp; 和交集 |"></a>2. 并集 &amp; 和交集 |</h2><p>给定 A 和 B，并集指两者内容之和，交集指两者共有的内容。</p><p>TS 中类型的并集使用 | 表示，类型的交集使用 &amp; 表示：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>    <span class="hljs-attr">b</span>: <span class="hljs-built_in">boolean</span>    <span class="hljs-attr">c</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">Bar</span> = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>    <span class="hljs-attr">d</span>: <span class="hljs-built_in">boolean</span>    <span class="hljs-attr">e</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">FooOrBarOrBoth</span> = <span class="hljs-title class_">Foo</span> | <span class="hljs-title class_">Bar</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooAndBar</span> = <span class="hljs-title class_">Foo</span> &amp; <span class="hljs-title class_">Bar</span></code></pre></div><p>对于并集 FooOrBarOrBoth 来说，Foo 类型、 Bar 类型或者两者兼具的值都可以赋值给 FooOrBarOrBoth。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-title class_">FooOrBarOrBoth</span> = &#123;     <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,     <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span>,     <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>: <span class="hljs-title class_">FooOrBarOrBoth</span> = &#123;     <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,     <span class="hljs-attr">d</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">e</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">z</span>: <span class="hljs-title class_">FooOrBarOrBoth</span> = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,    <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;&#x27;</span>,    <span class="hljs-attr">d</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">e</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;</code></pre></div><p>对于交集 FooAndBar 来说，必须同时有 Foo 类型和 Bar 类型的所有属性：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">FooAndBar</span> = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,    <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;&#x27;</span>,    <span class="hljs-attr">d</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">e</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【图解HTTP】HTTP</title>
    <link href="/archives/4e55843c.html"/>
    <url>/archives/4e55843c.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-网络基础"><a href="#1-网络基础" class="headerlink" title="1. 网络基础"></a>1. 网络基础</h1><h2 id="1-1-TCP-x2F-IP-协议族"><a href="#1-1-TCP-x2F-IP-协议族" class="headerlink" title="1.1 TCP&#x2F;IP 协议族"></a>1.1 TCP&#x2F;IP 协议族</h2><p>TCP&#x2F;IP 协议族是与互联网相关的<strong>协议</strong>的集合。按照层次可以分为以下4层：应用层、传输层、网络层和数据链路层。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230322175412496.png" alt="image-20230322175412496"></p><h3 id="1-1-1-应用层"><a href="#1-1-1-应用层" class="headerlink" title="1.1.1 应用层"></a>1.1.1 应用层</h3><p>eg：FTP &#x2F; DNS &#x2F; HTTP</p><h3 id="1-1-2-传输层"><a href="#1-1-2-传输层" class="headerlink" title="1.1.2 传输层"></a>1.1.2 传输层</h3><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。</p><p>eg：TCP &#x2F; UDP</p><h3 id="1-1-3-网络层"><a href="#1-1-3-网络层" class="headerlink" title="1.1.3 网络层"></a>1.1.3 网络层</h3><p>网络层用来处理在网络上流动的数据包。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p><p>eg：IP</p><h3 id="1-1-4-数据链路层"><a href="#1-1-4-数据链路层" class="headerlink" title="1.1.4 数据链路层"></a>1.1.4 数据链路层</h3><p>用来处理网络连接的硬件部分。</p><p>eg：操作系统、驱动、网卡和光纤等。</p><h2 id="1-2-IP-协议"><a href="#1-2-IP-协议" class="headerlink" title="1.2 IP 协议"></a>1.2 IP 协议</h2><p>IP 协议（Internet Protocol，网际协议）位于网络层，作用是把各种数据包传送给对方。要保证确实传送到目标地址，两个重要的条件是 IP 地址和 MAC 地址。</p><p>IP 地址表明了网络节点被分配到的地址，MAC 地址指的是网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可以改变，MAC 地址基本不会改变。</p><h3 id="1-2-1-ARP-协议"><a href="#1-2-1-ARP-协议" class="headerlink" title="1.2.1 ARP 协议"></a>1.2.1 ARP 协议</h3><p>IP 之间的通信依赖 MAC 地址。网络上，通信的双方通常需要经过多台网络设备的中转才能联系到对方。进行中转时，会用到利用下一站网络设备的 MAC 地址来搜索下一个中转目标。此时采用的是 ARP 协议（Address Resolution Protocol，地址解析协议），根据通信方的 IP 地址来反查对应的 MAC 地址。</p><h2 id="1-3-TCP-协议"><a href="#1-3-TCP-协议" class="headerlink" title="1.3 TCP 协议"></a>1.3 TCP 协议</h2><p>TCP 协议（Transmission Control Protocol，传输控制协议）位于传输层。为了方便数据传输，网络会将大块的数据分割成以报文段为单位的数据包进行管理。TCP 可以可靠地将数据传送给目标。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230531163636203.png" alt="image-20230531163636203"></p><h3 id="1-3-1-三次握手策略"><a href="#1-3-1-三次握手策略" class="headerlink" title="1.3.1 三次握手策略"></a>1.3.1 三次握手策略</h3><p>为了可靠地传输数据，TCP 采用了三次握手的策略。握手过程中会使用 SYN（synchronize）和 ACK（acknowledgement）这两个标志。</p><p>首先，发送端会发送一个带有 SYN 标志的数据包。然后，接收端收到后会回传一个 带有 SYN&#x2F;ACK 标志的数据包，以表示确认收到信息。最后，发送端会再传一个带有 ACK 标志的数据包代表“握手”结束。</p><p>如果在握手的某个过程中断，会再次以相同的顺序发送相同的数据包。</p><h3 id="1-3-2-四次挥手策略"><a href="#1-3-2-四次挥手策略" class="headerlink" title="1.3.2 四次挥手策略"></a>1.3.2 四次挥手策略</h3><p>首先，发送端发送一个 FIN，表明不会再发送数据。然后接收端收到 FIN 后发送一个 ACK 表示确认。接收端再发送一个 FIN 表示不会再发送数据。最后发送端收到 FIN 后发送一个 ACK 给服务端。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230531170144010.png" alt="image-20230531170144010"></p><h2 id="1-4-DNS"><a href="#1-4-DNS" class="headerlink" title="1.4 DNS"></a>1.4 DNS</h2><p>DNS 协议（Domain Name System，域名系统）位于应用层，提供域名到 IP 地址之间的解析服务。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230322175649686.png" alt="image-20230322175649686"></p><h2 id="1-5-HTTP"><a href="#1-5-HTTP" class="headerlink" title="1.5 HTTP"></a>1.5 HTTP</h2><img src="../images/【图解HTTP】HTTP笔记/image-20230322175939734.png" alt="image-20230322175939734" style="zoom:150%;" /><h2 id="1-6-URL-和-URI"><a href="#1-6-URL-和-URI" class="headerlink" title="1.6 URL 和 URI"></a>1.6 URL 和 URI</h2><h3 id="1-6-1-URL-统一资源定位符"><a href="#1-6-1-URL-统一资源定位符" class="headerlink" title="1.6.1 URL 统一资源定位符"></a>1.6.1 URL 统一资源定位符</h3><p>URL（Uniform Resource Locator，统一资源定位符），用来表示资源在互联网上所处的位置。</p><h3 id="1-6-2-URI-统一资源标识符"><a href="#1-6-2-URI-统一资源标识符" class="headerlink" title="1.6.2 URI 统一资源标识符"></a>1.6.2 URI 统一资源标识符</h3><p>URI（Uniform Resource Identifier，统一资源标识符），用字符串来标识某个互联网资源。</p><h1 id="2-HTTP-协议"><a href="#2-HTTP-协议" class="headerlink" title="2. HTTP 协议"></a>2. HTTP 协议</h1><h2 id="2-1-请求报文和响应报文"><a href="#2-1-请求报文和响应报文" class="headerlink" title="2.1 请求报文和响应报文"></a>2.1 请求报文和响应报文</h2><p>HTTP 协议规定，请求从客户端发出，服务端响应该请求并返回。</p><p>请求报文由请求方法，请求 URI，协议版本、可选的请求首部字段和内容实体构成。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230323102923961.png" alt="image-20230323102923961"></p><blockquote><p>请求 URI 可以放在请求行中，也可以放在请求首部的 Host 中。</p><p>如果不是访问特定资源而是对服务器本身发起请求，可以用一个 * 来代替请求 URI。</p><p>eg：<code>OPTIONS * HTTP/1.1</code></p></blockquote><p>响应报文由协议版本、状态码、状态码的原因短语、可选的响应首部字段以及实体主体构成。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230323103048675.png" alt="image-20230323103048675"></p><h2 id="2-2-无状态"><a href="#2-2-无状态" class="headerlink" title="2.2 无状态"></a>2.2 无状态</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。HTTP&#x2F;1.1 虽然是无状态协议，但为了实现期望的保持状态功能， 于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p><h2 id="2-3-HTTP-方法"><a href="#2-3-HTTP-方法" class="headerlink" title="2.3 HTTP 方法"></a>2.3 HTTP 方法</h2><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230323110505024.png" alt="image-20230323110505024"></p><h2 id="2-4-持久连接和管线化"><a href="#2-4-持久连接和管线化" class="headerlink" title="2.4 持久连接和管线化"></a>2.4 持久连接和管线化</h2><p>使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开， 增加通信量的开销。</p><p>为解决上述 TCP 连接的问题，HTTP&#x2F;1.1 使用了<strong>持久连接</strong>的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>持久连接使得多数请求以<strong>管线化</strong>（pipelining）方式发送成为可能。 从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。 这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><h2 id="2-5-Cookie"><a href="#2-5-Cookie" class="headerlink" title="2.5 Cookie"></a>2.5 Cookie</h2><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会<strong>自动</strong>在请求报文中加入 Cookie 值后发送出去。</p><h1 id="3-HTTP-报文"><a href="#3-HTTP-报文" class="headerlink" title="3. HTTP 报文"></a>3. HTTP 报文</h1><h2 id="3-1-请求报文和响应报文"><a href="#3-1-请求报文和响应报文" class="headerlink" title="3.1 请求报文和响应报文"></a>3.1 请求报文和响应报文</h2><p>HTTP 报文可以分为报文首部和报文主体两块，并不一定需要报文主体。</p><p>请求报文和响应报文的结构：</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230323150057271.png" alt="image-20230323150057271"></p><p>请求报文和响应报文的实例：</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230323150310727.png" alt="image-20230323150310727"></p><p>其中，请求报文中的请求行包括请求的方法、请求 URI 和 HTTP 版本。响应报文中的状态行包括响应结果的状态码，原因短语和 HTTP 版本。首部字段中包含请求和响应的各种条件和属性的各类首部，包括通用首部、请求首部、响应首部和实体首部，也可能包括不在 RFC 中定义的首部。</p><h2 id="3-2-编码提升传输效率"><a href="#3-2-编码提升传输效率" class="headerlink" title="3.2 编码提升传输效率"></a>3.2 编码提升传输效率</h2><h3 id="3-2-1-报文主体和实体主体"><a href="#3-2-1-报文主体和实体主体" class="headerlink" title="3.2.1 报文主体和实体主体"></a>3.2.1 报文主体和实体主体</h3><p>报文（message）指的是 HTTP 通信中的基本单位，由 8 位字节流组成。实体（entity）指的是请求和相应的有效载荷数据，由实体首部和实体主体组成。</p><p>HTTP 报文的主体用于传输请求或者响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p><h3 id="3-2-2-压缩传输的内容编码"><a href="#3-2-2-压缩传输的内容编码" class="headerlink" title="3.2.2 压缩传输的内容编码"></a>3.2.2 压缩传输的内容编码</h3><p>HTTP 协议中的内容编码功能可以将实体进行压缩后传输。常用的内容编码有：gzip、compress 等</p><h3 id="3-2-3-分割发送的分块传输编码"><a href="#3-2-3-分割发送的分块传输编码" class="headerlink" title="3.2.3 分割发送的分块传输编码"></a>3.2.3 分割发送的分块传输编码</h3><p>分块传输编码（Chunked Transfer Coding）会将实体主体分成多个块（chunk）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)” 来标记。 使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。</p><h2 id="3-3-发送多种数据的多部分对象集合-multipart"><a href="#3-3-发送多种数据的多部分对象集合-multipart" class="headerlink" title="3.3 发送多种数据的多部分对象集合 multipart"></a>3.3 发送多种数据的多部分对象集合 multipart</h2><p>HTTP 协议可以发送一份报文主体中含有多种类型的实体（文本、图片、视频等）这是因为采用了多部分对象集合（Multipart）的方法，来容纳不同类型的数据。</p><p>在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-Type。</p><p>例如，<code>multipart/form-data</code>在 web 表单文件上传时使用。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230323154126462.png" alt="image-20230323154126462"></p><p>使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“–”标记（例如： –AaB03x），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–）作为结束。</p><h2 id="3-4-获取部分内容的范围请求-Range"><a href="#3-4-获取部分内容的范围请求-Range" class="headerlink" title="3.4 获取部分内容的范围请求 Range"></a>3.4 获取部分内容的范围请求 Range</h2><p>在以前，如果在下载过程中遇到网络中断的情况，那么必须从头开始。HTTP 实现了恢复机制，可以从之前下载中断处恢复下载。</p><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。 对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230323155239266.png" alt="image-20230323155239266"></p><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。 byte 范围的指定形式如下：</p><ol><li><p>5001 - 10 000 字节：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Range</span>: bytes=<span class="hljs-number">5001</span>-<span class="hljs-number">10000</span></code></pre></div></li><li><p>5001 字节之后的：</p><div class="code-wrapper"><pre><code class="hljs routeros">Range: <span class="hljs-attribute">bytes</span>=5001-</code></pre></div></li><li><p>从开始到 3000 字节和 5000 - 7000 字节：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Range</span>: bytes=-<span class="hljs-number">3000</span>, <span class="hljs-number">5000</span>-<span class="hljs-number">7000</span></code></pre></div></li></ol><p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart&#x2F;byteranges 后返回响应报文。 </p><p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。</p><h2 id="3-5-内容协商返回最合适的内容"><a href="#3-5-内容协商返回最合适的内容" class="headerlink" title="3.5 内容协商返回最合适的内容"></a>3.5 内容协商返回最合适的内容</h2><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉， 然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p><ul><li>Accept</li><li>Accept-Charset</li><li>Accept-Encoding</li><li>Accept-Language</li><li>Content-Language</li></ul><h1 id="4-HTTP-状态码"><a href="#4-HTTP-状态码" class="headerlink" title="4. HTTP 状态码"></a>4. HTTP 状态码</h1><h2 id="4-1-状态码"><a href="#4-1-状态码" class="headerlink" title="4.1 状态码"></a>4.1 状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。状态码如 200 OK，以 3 位数字和原因短语组成。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230323161526712.png" alt="image-20230323161526712"></p><p>常用的状态码有14种</p><h2 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 2XX 成功</h2><ol><li>200 OK，表示从客户端发来的请求在服务器端被正常处理了。</li><li>204 No Content，表示请求已被成功处理，但是返回的响应报文不含实体主体。</li><li>206 Partial Content，表示服务器成功执行了客户端的范围请求。</li></ol><h2 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 3XX 重定向</h2><ol><li><p>301 Moved Permanently，永久性重定向。表示请求的资源已经被分配了新的 URI，以后应该使用资源新的 URI。</p></li><li><p>302 Found，临时性重定向。表示请求的资源已经被分配了新的 URI，本次应该使用资源新的 URI。</p></li><li><p>303 See Other，表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p></li><li><p>304 Not Modified，表示客户端发送附带条件的请求时，服务器端允许请求 访问资源，但未满足条件的情况。</p></li><li><p>307 Temporary Redirect，临时性重定向。与 302 有着相同的含义。</p></li></ol><h2 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 4XX 客户端错误</h2><ol><li>400 Bad Request，表示请求报文中存在语法错误。</li><li>401 Unauthorized，表示发送的请求需要认证消息。</li><li>403 Forbidden，表示请求资源的访问被服务器拒绝了。可能是权限不够。</li><li>404 Not Found，表示服务器上无法找到请求的资源。</li></ol><h2 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 5XX 服务器错误</h2><ol><li>500 Internal Server Error，表示服务器在执行请求是发生了错误。</li><li>503 Service Unavailable，表示服务器暂时处于超负载或者正在停机维护。</li></ol><h1 id="5-Web-服务器"><a href="#5-Web-服务器" class="headerlink" title="5. Web 服务器"></a>5. Web 服务器</h1><h2 id="5-1-代理、网关、隧道"><a href="#5-1-代理、网关、隧道" class="headerlink" title="5.1 代理、网关、隧道"></a>5.1 代理、网关、隧道</h2><p>HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转 发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。</p><h3 id="5-1-1-代理"><a href="#5-1-1-代理" class="headerlink" title="5.1.1 代理"></a>5.1.1 代理</h3><p>代理服务器接收客户端发送的请求后转发给其他服务器，代理不改变请求 URI，会直接发送给源服务器。源服务器返回的响应经过代理服务器后再传给客户端。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327205302767.png" alt="image-20230327205302767"></p><h3 id="5-1-2-网关"><a href="#5-1-2-网关" class="headerlink" title="5.1.2 网关"></a>5.1.2 网关</h3><p>网关和代理相似。不过，网关可以使线路上的服务器提供非 HTTP 服务。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327205834955.png" alt="image-20230327205834955"></p><h3 id="5-1-3-隧道"><a href="#5-1-3-隧道" class="headerlink" title="5.1.3 隧道"></a>5.1.3 隧道</h3><p>隧道可以建立起一条与其他服务器的通信线路。利用 SSL 等加密手段可以确保客户端和服务器之家进行安全通信。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327210037007.png" alt="image-20230327210037007"></p><h2 id="5-2-缓存"><a href="#5-2-缓存" class="headerlink" title="5.2 缓存"></a>5.2 缓存</h2><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p>当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。</p><h3 id="5-2-1-有效期限"><a href="#5-2-1-有效期限" class="headerlink" title="5.2.1 有效期限"></a>5.2.1 有效期限</h3><p>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从 源服务器上获取新资源。</p><h3 id="5-2-2-客户端缓存"><a href="#5-2-2-客户端缓存" class="headerlink" title="5.2.2 客户端缓存"></a>5.2.2 客户端缓存</h3><p>缓存不仅存在在缓存服务器中，还可以存在客户端浏览器中。当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</p><h1 id="6-HTTP-首部"><a href="#6-HTTP-首部" class="headerlink" title="6. HTTP 首部"></a>6. HTTP 首部</h1><h2 id="6-1-HTTP-报文首部"><a href="#6-1-HTTP-报文首部" class="headerlink" title="6.1 HTTP 报文首部"></a>6.1 HTTP 报文首部</h2><p>请求报文：</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327222346012.png" alt="image-20230327222346012"></p><p>响应报文：</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327222359983.png" alt="image-20230327222359983"></p><h2 id="6-2-HTTP-首部字段"><a href="#6-2-HTTP-首部字段" class="headerlink" title="6.2 HTTP 首部字段"></a>6.2 HTTP 首部字段</h2><p>HTTP 首部字段由字段名和字段值构成，中间用冒号分隔：</p><div class="code-wrapper"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html</code></pre></div><p>单个 HTTP 首部字段可以有多个值：</p><div class="code-wrapper"><pre><code class="hljs routeros">Keep-Alive: <span class="hljs-attribute">timeout</span>=15, <span class="hljs-attribute">max</span>=100</code></pre></div><p>根据实际用途，HTTP 首部字段可以分为：通用首部字段、请求首部字段、响应首部字段、实体首部字段。</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327224152837.png" alt="image-20230327224152837"></p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327224200871.png" alt="image-20230327224200871"></p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327224207003.png" alt="image-20230327224207003"></p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327224226210.png" alt="image-20230327224226210"></p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230327224231816.png" alt="image-20230327224231816"></p><h2 id="6-3-通用首部字段"><a href="#6-3-通用首部字段" class="headerlink" title="6.3 通用首部字段"></a>6.3 通用首部字段</h2><p>通用首部字段指的是请求报文和响应报文双方都会使用的首部。</p><ul><li><p>Cache-Control：操作缓存工作机制；指令参数可选，多个指令之间用逗号分隔。</p><div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">private</span>, <span class="hljs-keyword">max</span><span class="hljs-params">-age</span>=<span class="hljs-number">0</span>, no<span class="hljs-params">-cache</span><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: no<span class="hljs-params">-store</span><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">max</span><span class="hljs-params">-age</span>=<span class="hljs-number">604800</span></code></pre></div><ul><li>public：响应：可向任意方提供响应的缓存。</li><li>private：响应：仅向特定用户返回响应。</li><li>no-cache：请求：客户端不接收缓存资源：响应：缓存服务器不对资源进行缓存。</li><li>no-store：不应对请求或者响应进行缓存。</li><li>max-age：单位秒。请求：只接受比该时间少的缓存；响应：资源保存为缓存的最长时间。</li></ul></li><li><p>Connection：控制不再转发给代理的首部字段；管理持久连接</p><ul><li>首部字段名：不再转发的首部字段名。代理服务器转发时会删除该首部。</li><li>Keep-Alive：持久连接。HTTP 1.1 中默认连接就是持久连接</li><li>Close：关闭持久连接</li></ul></li><li><p>Date：表明创建 HTTP 报文的日期和时间</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Date</span>: Tue, <span class="hljs-number">03</span> Jul <span class="hljs-number">2012</span> <span class="hljs-number">04</span>:<span class="hljs-number">40</span>:<span class="hljs-number">59</span> GMT</code></pre></div></li><li><p>Upgrade：检测是否可以使用更高的版本进行通信。产生的作用仅限于客户端和邻接服务器之间。因此使用 Upgrade 时，还需要额外指定 <code>Connection: Upgrade</code></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Upgrade</span>: TLS/<span class="hljs-number">1</span>.<span class="hljs-number">0</span><span class="hljs-attribute">Connection</span>: Upgrade</code></pre></div></li><li><p>Via：追踪客户端和服务器之间的请求和响应报文的传输路径。经常和 TRACE 方法一同使用。</p><img src="../images/【图解HTTP】HTTP笔记/image-20230329203431710.png" alt="image-20230329203431710" style="zoom: 80%;" /></li></ul><h2 id="6-4-请求首部字段"><a href="#6-4-请求首部字段" class="headerlink" title="6.4 请求首部字段"></a>6.4 请求首部字段</h2><p>请求首部字段是客户端发送给服务端的请求中的字段。</p><ul><li><p>Accepct：通知服务器用户代理可以处理的媒体类型和相对优先级。可以使用 type&#x2F;subtype 这种形式，一次性指定多种媒体。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span></code></pre></div><ul><li>文本：text&#x2F;html, text&#x2F;plain, text&#x2F;css, application&#x2F;xhtml+xml, application&#x2F;xml</li><li>图片：image&#x2F;jpeg, image&#x2F;gif, image&#x2F;png</li><li>视频：video&#x2F;mpeg, video&#x2F;quicktime</li><li>应用程序使用的二进制文件：application&#x2F;octet-stream, application&#x2F;zip</li></ul><p>可以使用 q&#x3D; 来额外表示权重值，权重值 q 的范围是 0-1，1最大。默认权重 q&#x3D;1.0。</p></li><li><p>Accept-Charset：通知服务器用户代理支持的字符集和相对优先级。也可以使用 q&#x3D; 来表示优先级。</p></li><li><p>Accept-Encoding：通知服务器用户代理支持的内容编码和优先级。</p><ul><li>gzip，compress，deflate，identity</li></ul></li><li><p>Accept-Language：通知服务器用户代理能够处理的语言集和相对优先级。</p></li><li><p>Authorization：告知服务器用户代理的认证信息。</p></li><li><p>Host：必要。告知服务器<strong>请求的资源</strong>所处的互联网主机名和端口号。</p></li><li><p>Referer：告知服务器请求的原始资源的 URI。</p></li><li><p>User-Agent：告知服务器浏览器和用户代理的名称。</p></li><li><p>Range：范围请求。服务器会在处理请求后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，会返回状态码为 200 OK 的响应和全部资源。</p></li></ul><h2 id="6-5-响应首部字段"><a href="#6-5-响应首部字段" class="headerlink" title="6.5 响应首部字段"></a>6.5 响应首部字段</h2><p>响应首部字段是服务端发送给客户端的响应报文中的字段。</p><ul><li><p>Accept-Ranges：告知客户端服务器是否能够处理范围请求。可处理范围请求时值为 bytes，反之为 none。</p></li><li><p>Age：告知客户端源服务器在多久前创建了响应。单位秒。</p></li><li><p>Location：将响应的接收方引导至另一个位置的资源。配合 3xx: Redirection 的响应，提供重定向的 URI。</p></li><li><p>Retry-After：告知客户端应该在多久之后再次发送请求。配合 503  Service Unavailable 或者 3xx Redirect 响应一起使用。</p></li><li><p>Server：告知客户端当前服务器上安装的 HTTP 服务器应用程序信息。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">17</span> (Unix)</code></pre></div></li><li><p>WWW-Authenticate：用于 HTTP 的访问认证，告知客户端适用于请求 URI 的认证方案。</p></li></ul><h2 id="6-6-实体首部字段"><a href="#6-6-实体首部字段" class="headerlink" title="6.6 实体首部字段"></a>6.6 实体首部字段</h2><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p><ul><li><p>Allow：通知客户端能够支持该请求 URI 指定资源的所有 HTTP 方法。</p><p>当服务器收到不支持的 HTTP 方法时，会以 405 Method Not Allowed 作为响应来返回。同时返回把所有能支持的 HTTP 方法写入 Allow 字段后返回。</p><div class="code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-symbol">Allow:</span> <span class="hljs-keyword">GET</span>, HEAD</code></pre></div></li><li><p>Content-Encoding：告知客户端实体的主体选用的内容编码方式。</p><ul><li>gzip,compress,deflate,identity</li></ul></li><li><p>Content-Language：告知客户端实体的主体使用的自然语言。</p></li><li><p>Content-Length：表明了实体主体部分的大小（单位是字节）。</p></li><li><p>Content-Range：告知客户端作为响应返回的实体的哪个部分符合范围请求。</p></li><li><p>Content-Type：说明实体主体内对象的媒体类型。和首部 字段 Accept 一样，字段值用 type&#x2F;subtype 形式赋值。</p></li><li><p>Expires：将资源失效的日期告知客户端。缓存服务器在 接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</p><p>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。 但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。</p></li><li><p>Last-Modified：指明资源最终的修改时间。</p></li></ul><h2 id="6-7-Cookie-相关首部字段"><a href="#6-7-Cookie-相关首部字段" class="headerlink" title="6.7 Cookie 相关首部字段"></a>6.7 Cookie 相关首部字段</h2><ul><li><p>Set-Cookie：响应首部字段中，开始状态管理所使用的 Cookie 信息</p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230329224109626.png" alt="image-20230329224109626"></p><p><img src="/../images/%E3%80%90%E5%9B%BE%E8%A7%A3HTTP%E3%80%91HTTP%E7%AC%94%E8%AE%B0/image-20230329224117869.png" alt="image-20230329224117869"></p></li><li><p>Cookie：请求首部字段中，服务器收到的 Cookie 信息。</p><p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p></li></ul><h1 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h1><p>HTTP 缺点：</p><ol><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ol><p>HTTP 加上<strong>加密处理</strong>和<strong>认证</strong>以及<strong>完整性保护</strong>后即是 HTTPS。HTTPS 不是一种新的协议，只是 HTTP 通信接口部分使用 SSL（Secure Socket Layer，安全套接层） 和 TLS （Transport Layer Security，传输层安全）协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是 身披 SSL 协议这层外壳的 HTTP。</p><h2 id="7-1-SSL"><a href="#7-1-SSL" class="headerlink" title="7.1 SSL"></a>7.1 SSL</h2><p><strong>共享</strong>密钥加密：加密和解密同用一个密钥，加密时把密钥也发送给对方（<strong>对称</strong>加密）。</p><p><strong>公开</strong>密钥加密：使用一对<strong>非对称</strong>的密钥，一把叫私钥，一把叫做公钥。私钥不能让任何人知道，公钥可以发送给任何人。发送密文的时候使用对方的公钥，接收密文之后使用自己的私钥进行解密。</p><p><strong>混合</strong>加密机制：HTTPS 使用的是共享密钥加密和公开密钥加密两种模式混合的加密机制。因为公开密钥加密比共享密钥加密相比速度更慢，为了保证效率，可能使用公开密钥加密传输<strong>密钥</strong>，保证该密钥的安全，随后使用共享密钥加密交换报文。</p><h2 id="7-2-证书"><a href="#7-2-证书" class="headerlink" title="7.2 证书"></a>7.2 证书</h2><p>CA 证书：保证公钥的传输不被破攻击。</p><p>公开密钥加密方式还是存在一定的问题，那就是没有办法保证传输公开密钥的过程中不被攻击。为了解决上述问题，可以使用证书认证机构（CA）所颁发的证书来解决。</p><p>服务器先向证书认证机构申请公开密钥的证书。机构在判明服务器身份之后，对申请的公开密钥做数字签名，并将公开密钥加入到公钥证书中。随后，服务器将公钥证书发送给客户端。客户端使用数字证书认证机构的公开密钥对证书上的签名进行认证。认证机构的公开密钥一般都会内置在浏览器中。</p><h2 id="7-3-TSL"><a href="#7-3-TSL" class="headerlink" title="7.3 TSL"></a>7.3 TSL</h2><p>TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。</p><p>HTTPS 使用 SSL 时会变慢：</p><ol><li>通信量增加</li><li>加密处理需要消耗更多的硬件资源</li></ol><h1 id="8-认证"><a href="#8-认证" class="headerlink" title="8. 认证"></a>8. 认证</h1><p>HTTP&#x2F;1.1 使用的认证方式有：</p><ul><li><p>BASIC 认证（基本认证） </p></li><li><p>DIGEST 认证（摘要认证）</p></li><li><p>SSL 客户端认证</p></li><li><p>FormBase 认证（基于表单认证）</p></li></ul><h1 id="9-基于-HTTP-的追加协议"><a href="#9-基于-HTTP-的追加协议" class="headerlink" title="9. 基于 HTTP 的追加协议"></a>9. 基于 HTTP 的追加协议</h1><h2 id="9-1-WebSocket"><a href="#9-1-WebSocket" class="headerlink" title="9.1 WebSocket"></a>9.1 WebSocket</h2><p>Web 浏览器和 Web 服务器之间<strong>全双工</strong>通信标准。主要特点：</p><ul><li>推送功能：服务器可以直接发送数据，不必等待客户端进行请求。</li><li>减少通信量：建立起 ws 连接之后，一直保持连接。相比 HTTP 开销少。</li></ul><h2 id="9-2-HTTP-x2F-2-0"><a href="#9-2-HTTP-x2F-2-0" class="headerlink" title="9.2 HTTP&#x2F;2.0"></a>9.2 HTTP&#x2F;2.0</h2><p>7 项技术：</p><ul><li>压缩</li><li>多路复用</li><li>TLS 义务化</li><li>协商</li><li>客户端拉曳和服务端推送</li><li>流量控制</li><li>WebSocket</li></ul><h2 id="9-3-WebDAV"><a href="#9-3-WebDAV" class="headerlink" title="9.3 WebDAV"></a>9.3 WebDAV</h2><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个分布式文件系统。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Node】Node基础笔记</title>
    <link href="/archives/f3126934.html"/>
    <url>/archives/f3126934.html</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p><a href="https://nodejs.org/dist/latest-v18.x/docs/api/">官方文档</a></p><h2 id="1-fs-文件系统模块"><a href="#1-fs-文件系统模块" class="headerlink" title="1. fs 文件系统模块"></a>1. fs 文件系统模块</h2><p>fs 是 node 中内置的文件系统模块，可以对文件进行读写。</p><h3 id="1-1-fs-readFile-读取文件"><a href="#1-1-fs-readFile-读取文件" class="headerlink" title="1.1 fs.readFile() 读取文件"></a>1.1 fs.readFile() 读取文件</h3><p><code>fs.readFile(path[, options], callback)</code></p><ul><li>path &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; |&lt;integer&gt; filename or file descriptor</li><li>options &lt;Object&gt; | &lt;string&gt;<ul><li>encoding &lt;string&gt; | &lt;null&gt; Default: null</li><li>flag &lt;string&gt; See support of file system flags. Default: ‘r’.</li><li>signal &lt;AbortSignal&gt; allows aborting an in-progress readFile</li></ul></li><li>callback &lt;Function&gt;<ul><li>err &lt;Error&gt; | &lt;AggregateError&gt;</li><li>data &lt;string&gt; | &lt;Buffer&gt;</li></ul></li></ul><p>eg：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./demo.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件读取失败&#x27;</span>, err)    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件读取成功&#x27;</span>, value)&#125;)</code></pre></div><h3 id="1-2-fs-writeFile-写入文件"><a href="#1-2-fs-writeFile-写入文件" class="headerlink" title="1.2 fs.writeFile() 写入文件"></a>1.2 fs.writeFile() 写入文件</h3><p><code>fs.writeFile(file, data[, options], callback)</code></p><ul><li><p>file &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; | &lt;integer&gt; filename or file descriptor</p></li><li><p>data &lt;string&gt; |&lt;Buffer&gt; | &lt;TypedArray&gt; | &lt;DataView&gt; | &lt;Object&gt;</p></li><li><p>options &lt;Object&gt; | &lt;string&gt;</p><ul><li>encoding &lt;string&gt; | &lt;null&gt; Default: ‘utf8’</li><li>mode &lt;integer&gt; Default: 0o666</li><li>flag &lt;string&gt; See support of file system flags. Default: ‘w’.</li><li>signal &lt;AbortSignal&gt; allows aborting an in-progress writeFile</li></ul></li><li><p>callback &lt;Function&gt;</p><ul><li>err &lt;Error&gt; | &lt;AggregateError&gt;</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;hello world&#x27;</span>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./demo.txt&#x27;</span>, text, &#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">&#x27;a+&#x27;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入失败&#x27;</span>, err)    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入成功&#x27;</span>)&#125;)</code></pre></div><h2 id="2-path-路径模块"><a href="#2-path-路径模块" class="headerlink" title="2. path 路径模块"></a>2. path 路径模块</h2><p>path 是 node 中内置的路径处理模块，可以对文件和目录的路径进行处理。</p><h3 id="2-1-dirname-和-filename"><a href="#2-1-dirname-和-filename" class="headerlink" title="2.1 __dirname 和 __filename"></a>2.1 <code>__dirname</code> 和<code> __filename</code></h3><p>在 node.js 中 <code>__dirname</code>代表当前文件所处目录的绝对路径，<code>__filename</code>代表当前文件的绝对路径。</p><h3 id="2-2-path-join-路径拼接"><a href="#2-2-path-join-路径拼接" class="headerlink" title="2.2 path.join() 路径拼接"></a>2.2 path.join() 路径拼接</h3><p>可以将多个路径片段拼接成格式化后完整的路径字符串。涉及路径拼接的操作尽可能使用这个方法，防止出错。</p><p><code>path.join([...paths])</code></p><ul><li>…paths &lt;string&gt; A sequence of path segments</li><li>Returns: &lt;string&gt;</li></ul><p>eg：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">let</span> fullPath = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;./files&#x27;</span>, <span class="hljs-string">&#x27;demo.txt&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullPath)<span class="hljs-comment">// files\demo.txt</span>fullPath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;demo.txt&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullPath)<span class="hljs-comment">// 当前文件的绝对路径</span></code></pre></div><h3 id="2-3-path-basename-获取路径最后一部分"><a href="#2-3-path-basename-获取路径最后一部分" class="headerlink" title="2.3 path.basename() 获取路径最后一部分"></a>2.3 path.basename() 获取路径最后一部分</h3><p>获取路径中的最后一部分。如果路径代表一个文件，那就返回带扩展名的文件名，如果不想返回扩展名，需要添加第二个参数。如果路径代表一个目录，那就返回路径的最后一部分。</p><p><code>path.basename(path[, suffix])</code></p><ul><li><p>path &lt;string&gt;</p></li><li><p>suffix &lt;string&gt; An optional suffix to remove</p></li><li><p>Returns: &lt;string&gt;</p></li></ul><p>eg：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">let</span> fullPath = <span class="hljs-string">&#x27;./foo/bar/qux.html&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">basename</span>(fullPath))<span class="hljs-comment">// qux.html</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">basename</span>(fullPath, <span class="hljs-string">&#x27;.html&#x27;</span>))<span class="hljs-comment">// qux</span>fullPath = <span class="hljs-string">&#x27;./foo/bar&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">basename</span>(fullPath))<span class="hljs-comment">// bar</span></code></pre></div><h3 id="2-4-path-extname-获取路径中的扩展名"><a href="#2-4-path-extname-获取路径中的扩展名" class="headerlink" title="2.4 path.extname() 获取路径中的扩展名"></a>2.4 path.extname() 获取路径中的扩展名</h3><p>获取路径中的扩展名。如果路径代表一个文件，那就返回文件的扩展名（带小数点）。如果路径不代表一个文件，那就返回一个空串。</p><p><code>path.extname(path)</code></p><ul><li><p>path &lt;string&gt;</p></li><li><p>Returns: &lt;string&gt;</p></li></ul><p>eg：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">let</span> fullPath = <span class="hljs-string">&#x27;./foo/bar/qux.html&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">extname</span>(fullPath))<span class="hljs-comment">// .html</span>fullPath = <span class="hljs-string">&#x27;./foo/bar/qux&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">extname</span>(fullPath))<span class="hljs-comment">// 空串</span></code></pre></div><h2 id="3-http-模块"><a href="#3-http-模块" class="headerlink" title="3 http 模块"></a>3 http 模块</h2><p>http 是 node 中创建 web 服务器的模块。</p><p>创建一个简单的 http 服务器：</p><ol><li>导入 http 模块</li><li>创建 http 服务器实例</li><li>为 http 服务器实例绑定 request 事件</li><li>启动服务器，监听端口</li></ol><p>eg：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)server.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;3000&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server is runing on port 3000&#x27;</span>)&#125;)</code></pre></div><p>运行后，浏览器中输入 <a href="http://localhost:3000/">http://localhost:3000/</a> 即可看到 hello world。</p><h3 id="3-1-request-请求对象"><a href="#3-1-request-请求对象" class="headerlink" title="3.1 request 请求对象"></a>3.1 request 请求对象</h3><p>给 http 实例绑定 request 事件处理函数时，传入的时间处理函数有两个形参：req 和 res。这其中第一个形参是一个 request 请求对象。这个对象是内部创建的，通过这个对象可以对客户端发送过来的请求进行处理。</p><p>常用属性：</p><h4 id="3-1-1-protocol-x2F-host-x2F-path-x2F-url-x2F-method"><a href="#3-1-1-protocol-x2F-host-x2F-path-x2F-url-x2F-method" class="headerlink" title="3.1.1 protocol &#x2F; host &#x2F; path &#x2F; url &#x2F; method"></a>3.1.1 protocol &#x2F; host &#x2F; path &#x2F; url &#x2F; method</h4><p>协议 &#x2F; 主机名 &#x2F; 路径 &#x2F; URL &#x2F; 请求方法</p><h3 id="3-2-response-响应对象"><a href="#3-2-response-响应对象" class="headerlink" title="3.2 response 响应对象"></a>3.2 response 响应对象</h3><p>给 http 实例绑定 request 事件处理函数时，传入的时间处理函数有两个形参：req 和 res。其中第二个形参是一个 response 响应对象。这个对象是内部创建的，通过这个对象可以响应客户端请求。</p><p>常用方法：</p><h4 id="3-2-1-response-end"><a href="#3-2-1-response-end" class="headerlink" title="3.2.1 response.end()"></a>3.2.1 response.end()</h4><p>向客户端发送响应，向服务器发出响应完成信号。每个响应都必须调用 end() 方法。</p><p><code>response.end([data[, encoding]][, callback])</code></p><ul><li><p>data &lt;string&gt; | &lt;Buffer&gt;</p></li><li><p>encoding &lt;string&gt;</p></li><li><p>callback &lt;Function&gt;</p></li><li><p>Returns: &lt;this&gt;</p></li></ul><h4 id="3-2-2-response-setHeader"><a href="#3-2-2-response-setHeader" class="headerlink" title="3.2.2 response.setHeader()"></a>3.2.2 response.setHeader()</h4><p>设置响应头。</p><p><code>response.setHeader(name, value)</code></p><ul><li><p>name &lt;string&gt;</p></li><li><p>value &lt;any&gt;</p></li><li><p>Returns: &lt;http.ServerResponse&gt;</p></li></ul><p>eg：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-comment">// 设置响应头</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)        <span class="hljs-comment">// 发出响应</span>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;你好，世界&#x27;</span>)&#125;)server.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;3000&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server is runing on port 3000&#x27;</span>)&#125;)</code></pre></div><h2 id="4-模块化"><a href="#4-模块化" class="headerlink" title="4. 模块化"></a>4. 模块化</h2><h3 id="4-1-node-中的模块分类"><a href="#4-1-node-中的模块分类" class="headerlink" title="4.1 node 中的模块分类"></a>4.1 node 中的模块分类</h3><p>根据来源的不同，node 中模块分为3类：</p><ul><li>内置模块：node 官方提供，无需安装就可以直接引用。比如：fs、path、http 等</li><li>自定义模块：用户创建的每个 .js 文件，都可以当作自定义模块</li><li>第三方模块：使用前需要先下载安装</li></ul><p>eg，使用 require() 来引入模块：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 加载内置模块，传入模块名</span><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<span class="hljs-comment">// 加载自定义模块，传入路径，可以省略.js后缀</span><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./foo&#x27;</span>)<span class="hljs-comment">// 加载第三方模块，传入模块名（需要提前下载安装）</span><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;axios&#x27;</span>)</code></pre></div><h3 id="4-2-模块作用域"><a href="#4-2-模块作用域" class="headerlink" title="4.2 模块作用域"></a>4.2 模块作用域</h3><p>为了防止全局变量污染，在模块中定义的变量，只能在模块内部访问，无法在外部访问到。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// foo.js</span><span class="hljs-keyword">const</span> bar = <span class="hljs-string">&#x27;baz&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./foo&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// &#123;&#125; 空对象</span></code></pre></div><h3 id="4-3-CommonJS-模块化规范"><a href="#4-3-CommonJS-模块化规范" class="headerlink" title="4.3 CommonJS 模块化规范"></a>4.3 CommonJS 模块化规范</h3><p>模块化规范指的是使用什么样的语法来引用模块或者对外暴露成员。node 遵循了 CommonJS 规范：</p><ol><li>每个模块内部，module 对象代表当前模块</li><li>module 对象的 exports 属性是对外的接口</li><li>使用 require() 函数来加载模块</li></ol><h4 id="4-3-1-module-对象"><a href="#4-3-1-module-对象" class="headerlink" title="4.3.1 module 对象"></a>4.3.1 module 对象</h4><p>每个自定义模块中都有一个 module 对象，这个对象身上存储了当前模块有关的信息。</p><h5 id="module-exports-暴露成员"><a href="#module-exports-暴露成员" class="headerlink" title="module.exports 暴露成员"></a>module.exports 暴露成员</h5><p>通过 module 的 exports 属性可以向外暴露模块成员。通过 require() 方法导入自定义模块时，拿到的就是自定义模块的 module.exports 对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// foo.js</span><span class="hljs-keyword">const</span> bar = <span class="hljs-string">&#x27;baz&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;&#125;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    bar,    fn&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./foo&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// &#123; bar: &#x27;baz&#x27;, fn: [Function: fn] &#125;</span></code></pre></div><h4 id="4-3-2-exports-对象"><a href="#4-3-2-exports-对象" class="headerlink" title="4.3.2 exports 对象"></a>4.3.2 exports 对象</h4><p>由于使用 module.exports 向外暴露成员写法比较繁琐，所以 node 提供了 exports 对象简化操作。初始情况下，exports 和 module.exports 都指向同一个空对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// foo.js</span><span class="hljs-keyword">const</span> bar = <span class="hljs-string">&#x27;baz&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123; &#125;<span class="hljs-built_in">exports</span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&#x27;baz&#x27;</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">fn</span> = fn</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./foo&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// &#123; bar: &#x27;baz&#x27;, fn: [Function: fn] &#125;</span></code></pre></div><p>如果给 exports 或者 module.exports 赋值为一个新的对象，那么这两个对象会失去联系。require() 函数只会去寻找  module.exports。</p><h4 id="4-3-3-require-加载模块"><a href="#4-3-3-require-加载模块" class="headerlink" title="4.3.3 require() 加载模块"></a>4.3.3 require() 加载模块</h4><p>使用 require() 函数来加载模块：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./foo&#x27;</span>)<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;axios&#x27;</span>)</code></pre></div><h5 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h5><ol><li><p>使用 require() 引入模块时，模块在会进行缓存。之后使用 reuqire() 引入模块，会优先从缓存中加载，从而提高加载效率。</p></li><li><p>使用 require() 引入模块时，node 会先从内置模块中寻找。</p></li><li><p>使用 require() 引入自定义模块，必须传入以<code>./</code>或者<code>../</code>开头的路径标识符。</p></li><li><p>使用 require() 引入自定义模块，如果省略了文件扩展名，会：</p><ol><li>先按确切文件名进行加载</li><li>补全 .js 扩展名进行加载</li><li>补全 .json 扩展名进行加载</li><li>补全 .node 扩展名进行加载</li></ol></li><li><p>如果传给 require() 的模块标识符不是内置模块，也不以<code>./</code>和<code>../</code>开头，node 会从当前模块的父目录开始，尝试到 <code>node_modules</code>目录在查找第三方模块。如果找不到，会继续向父目录查找，直到系统根目录。</p></li><li><p>如果将目录作为模块引入，会：</p><ol><li>在该目录下查找 package.json，并寻找 main 属性，将属性值作为加载入口。</li><li>如果找不到 package.json 或者 main 入口解析失败，则试图将目录下的 index.js 作为入口</li></ol></li></ol><h2 id="5-npm"><a href="#5-npm" class="headerlink" title="5. npm"></a>5. npm</h2><p>node 中第三方模块也叫包（依赖）。npm 是 node 中自带的包管理工具，通过这个工具可以安装、升级、卸载包。</p><h3 id="5-1-npm-init-项目初始化"><a href="#5-1-npm-init-项目初始化" class="headerlink" title="5.1 npm init 项目初始化"></a>5.1 npm init 项目初始化</h3><p>在项目目录下，运行 npm init 可以对 node 项目进行初始化。运行后，项目根目录会生成一个 package.json 文件。文件中会记录包括项目依赖包在内的项目信息。</p><div class="code-wrapper"><pre><code class="hljs shell">npm init</code></pre></div><p>运行这条命令后，需要交互式输入项目名称、版本号等信息。可以使用 -y 参数，对所有问题都回复 yes。</p><div class="code-wrapper"><pre><code class="hljs shell">npm init -y</code></pre></div><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;demo&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 包名。上传到npm后，可以通过包名搜索到该包</span>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 版本号</span>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 描述</span>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 入口文件</span>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 关键字</span>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 作者</span>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 开源协议</span>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-comment">// 依赖</span>    <span class="hljs-attr">&quot;axios&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.3.4&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-comment">// 开发依赖</span>    <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.75.0&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h3 id="5-2-npm-install-安装包"><a href="#5-2-npm-install-安装包" class="headerlink" title="5.2 npm install 安装包"></a>5.2 npm install 安装包</h3><p>在项目目录下，输入命令：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install &lt;包名&gt;</code></pre></div><p>简写：</p><div class="code-wrapper"><pre><code class="hljs shell">npm i &lt;包名&gt;</code></pre></div><h4 id="D-安装开发依赖"><a href="#D-安装开发依赖" class="headerlink" title="-D 安装开发依赖"></a>-D 安装开发依赖</h4><p>通过这种方式安装的包，会记录在 package.json 中的 dependencies 节点下。表示在开发环境和生产环境都会用到。如果某些包只会在项目的开发环境中使用，不会应用到生产环境，可以使用 –save-dev 或者 -D 参数：</p><div class="code-wrapper"><pre><code class="hljs shell">npm i -D &lt;包名&gt;</code></pre></div><p>这样，包会记录在 package.json 中的 devDependencies 节点下。</p><h4 id="g-安装全局依赖"><a href="#g-安装全局依赖" class="headerlink" title="-g 安装全局依赖"></a>-g 安装全局依赖</h4><p>使用 -g 参数可以把包安装到全局（不在项目目录下）。</p><div class="code-wrapper"><pre><code class="hljs shell">npm i -g &lt;包名&gt;</code></pre></div><p>只有工具性质的包才有全局安装的必要性。eg：nodemon 可以监听文件变化，重启服务器，可以代替 node 命令来执行。</p><div class="code-wrapper"><pre><code class="hljs shell">npm i -g nodemon</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">nodemon index.js</code></pre></div><h4 id="指定版本"><a href="#指定版本" class="headerlink" title="@ 指定版本"></a>@ 指定版本</h4><p>默认情况下，npm install 会安装最新版本的包。可以通过<code>@</code>来指定安装包的版本：</p><div class="code-wrapper"><pre><code class="hljs shell">npm i &lt;包名&gt;@&lt;版本号&gt;</code></pre></div><p>在不输入包名的情况下，会安装项目目录下 package.json 中所记录的所有依赖包：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install// 或npm i</code></pre></div><h3 id="5-3-npm-uninstall-卸载包"><a href="#5-3-npm-uninstall-卸载包" class="headerlink" title="5.3 npm uninstall 卸载包"></a>5.3 npm uninstall 卸载包</h3><p>在项目目录下，输入命令：</p><div class="code-wrapper"><pre><code class="hljs shell">npm uninstall &lt;包名&gt;</code></pre></div><p>即可卸载指定包，并将这个包从 package.json 中的依赖项中删除。</p><h4 id="g-卸载全局依赖"><a href="#g-卸载全局依赖" class="headerlink" title="-g 卸载全局依赖"></a>-g 卸载全局依赖</h4><div class="code-wrapper"><pre><code class="hljs shell">npm uninstall -g &lt;包名&gt;</code></pre></div><h2 id="6-Express"><a href="#6-Express" class="headerlink" title="6. Express"></a>6. Express</h2><p>Express 是基于 node 的快速、开放、极简的 web 开发框架。Express 封装了 http 模块，开发效率更高。</p><h3 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1 安装"></a>6.1 安装</h3><p>在项目的根目录下：</p><div class="code-wrapper"><pre><code class="hljs shell">npm initnpm install express</code></pre></div><h3 id="6-2-起步"><a href="#6-2-起步" class="headerlink" title="6.2 起步"></a>6.2 起步</h3><ol><li>引入依赖</li><li>创建 web 服务器</li><li>监听端口</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server is running at http://localhost:3000&#x27;</span>)&#125;)</code></pre></div><h3 id="6-3-监听-GET-x2F-POST-请求"><a href="#6-3-监听-GET-x2F-POST-请求" class="headerlink" title="6.3 监听 GET &#x2F; POST 请求"></a>6.3 监听 GET &#x2F; POST 请求</h3><p>通过 app.get() 方法来监听 GET 请求。函数接收两个参数，第一个参数是路径名，第二个参数是回调函数。回调函数有两个参数，第一个参数是请求对象，第二个参数是响应对象。</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)</code></pre></div><p>通过 app.post() 方法来监听 POST 请求。</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;post&#x27;</span>)&#125;)</code></pre></div><h3 id="6-4-请求对象"><a href="#6-4-请求对象" class="headerlink" title="6.4 请求对象"></a>6.4 请求对象</h3><h4 id="6-4-1-req-query-查询对象"><a href="#6-4-1-req-query-查询对象" class="headerlink" title="6.4.1 req.query 查询对象"></a>6.4.1 req.query 查询对象</h4><p>通过请求对象身上的 query 属性可以获取查询对象。默认为空对象</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 当客户端发送 get 请求：http://localhost:3000/?foo=a&amp;bar=b</span>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> query = req.<span class="hljs-property">query</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(query)<span class="hljs-comment">// &#123; foo: &#x27;a&#x27;, bar: &#x27;b&#x27; &#125;</span>&#125;)</code></pre></div><h4 id="6-4-2-req-params-动态参数对象"><a href="#6-4-2-req-params-动态参数对象" class="headerlink" title="6.4.2 req.params 动态参数对象"></a>6.4.2 req.params 动态参数对象</h4><p>通过请求对象身上的 params 属性可以获取动态参数对象。默认为空对象。例如：当请求URL为 <code>/posts/:id</code> 时，id 就是一个动态参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 当客户端发送 get 请求：http://localhost:3000/posts/3</span>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/posts/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> params = req.<span class="hljs-property">params</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params)<span class="hljs-comment">// &#123; id: &#x27;3&#x27; &#125;</span>&#125;)</code></pre></div><h3 id="6-5-响应对象"><a href="#6-5-响应对象" class="headerlink" title="6.5 响应对象"></a>6.5 响应对象</h3><h4 id="6-5-1-res-send-发送响应"><a href="#6-5-1-res-send-发送响应" class="headerlink" title="6.5.1 res.send() 发送响应"></a>6.5.1 res.send() 发送响应</h4><p>通过响应对象身上的 send() 方法，可以向客户端发送响应。</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)</code></pre></div><h3 id="6-6-express-static-托管静态资源"><a href="#6-6-express-static-托管静态资源" class="headerlink" title="6.6 express.static() 托管静态资源"></a>6.6 express.static() 托管静态资源</h3><p>通过 express.static() 方法可以托管静态资源。express 在指定的静态资源目录中查找文件，并提供资源的当前路径。</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<span class="hljs-comment">// eg: http://localhost:3000/index.html</span><span class="hljs-comment">// eg: http://localhost:3000/css/reset.css</span><span class="hljs-comment">// eg: http://localhost:3000/js/index.js</span></code></pre></div><p>按照这种方式托管的静态资源，没有路径前缀。如果想设置一个路径前缀，可以：</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/public&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<span class="hljs-comment">// eg: http://localhost:3000/public/index.html</span><span class="hljs-comment">// eg: http://localhost:3000/public/css/reset.css</span><span class="hljs-comment">// eg: http://localhost:3000/public/js/index.js</span></code></pre></div><p>如果想托管多个静态资源目录，可以多次调用：</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>))</code></pre></div><p>如果多个静态资源目录中存在多个同名文件，那么按照调用次序，访问时返回先调用的静态资源目录下的文件。</p><h3 id="6-7-路由"><a href="#6-7-路由" class="headerlink" title="6.7 路由"></a>6.7 路由</h3><p>在 express 中，路由指的是客户端请求和服务端处理函数之间的映射关系。</p><p>可以直接将路由挂载到 app 上</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;&#125;)app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;&#125;)</code></pre></div><p>可以将路由单独写成一个模块：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// router.js</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123; &#125;)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)app.<span class="hljs-title function_">use</span>(router)app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server is running at http://localhost:3000&#x27;</span>)&#125;)<span class="hljs-comment">// http://localhost:3000/foo</span></code></pre></div><p>如果想给路由添加一个前缀：</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)<span class="hljs-comment">// http://localhost:3000/api/foo</span></code></pre></div><h3 id="6-8-中间件"><a href="#6-8-中间件" class="headerlink" title="6.8 中间件"></a>6.8 中间件</h3><p>中间件（middleware），是将具体业务和底层逻辑解耦的组件。express 中的中间件函数可以访问请求对象、响应对象和请求-响应周期中 next() 函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 中间件函数</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw</span> = (<span class="hljs-params">req, res, next</span>)=&gt;&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a middleware function&#x27;</span>)    <span class="hljs-title function_">next</span>()&#125;</code></pre></div><p>中间件可以执行以下功能：</p><ul><li>执行业务代码</li><li>对请求对象和响应对象进行更改</li><li>结束请求-响应周期</li><li>调用堆栈中的下一个中间件</li></ul><p>如果当前中间件函数没有结束请求-响应周期，那就必须调用 next() 函数来将控制权交给下一个中间件。否则，请求会被搁置。</p><p>中间件之间共享同一份 req 和 res。上游中间件对 req 和 res 的修改会传递给下游的中间件。</p><h4 id="6-8-1-全局生效"><a href="#6-8-1-全局生效" class="headerlink" title="6.8.1 全局生效"></a>6.8.1 全局生效</h4><p>全局生效的中间件是请求到达服务器之后，都会触发的中间件。通过调用 app.use()，并传入中间件函数，可以使其全局生效。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw</span> = (<span class="hljs-params">req, res, next</span>)=&gt;&#123;    <span class="hljs-title function_">next</span>()&#125;app.<span class="hljs-title function_">use</span>(mw)</code></pre></div><p>注意：中间件要在路由之前定义注册。否则中间件无法工作。</p><h4 id="6-8-2-局部生效"><a href="#6-8-2-局部生效" class="headerlink" title="6.8.2 局部生效"></a>6.8.2 局部生效</h4><p>局部生效的中间件只会在当前路由中生效。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;    <span class="hljs-title function_">next</span>()&#125;app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, mw, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)</code></pre></div><p>也可以定义多个局部的中间件：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw1</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>)    <span class="hljs-title function_">next</span>()&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">mw2</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>)    <span class="hljs-title function_">next</span>()&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">mw3</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>)    <span class="hljs-title function_">next</span>()&#125;<span class="hljs-comment">// 两种方式均可：</span>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, mw1, mw2, mw3, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, [mw1, mw2, mw3], <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)</code></pre></div><h4 id="6-8-3-分类"><a href="#6-8-3-分类" class="headerlink" title="6.8.3 分类"></a>6.8.3 分类</h4><ol><li><p>应用级别的中间件</p><p>通过 app.use() 或者 app.get() 和 app.post() 绑定到 app 实例上面的中间件。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<span class="hljs-keyword">const</span> <span class="hljs-title function_">mw</span> = (<span class="hljs-params">req, res, next</span>)=&gt;&#123;    <span class="hljs-title function_">next</span>()&#125;app.<span class="hljs-title function_">use</span>(mw)</code></pre></div></li><li><p>路由级别的中间件</p><p>绑定到 express.Router() 实例上的中间件。和应用级别中间件没有什么区别，应用级别中间件绑定到 app 上，路由级别中间件绑定到 router 实例上。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// router.js</span><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<span class="hljs-keyword">const</span> <span class="hljs-title function_">mw</span> = (<span class="hljs-params">req, res, next</span>)=&gt;&#123;    <span class="hljs-title function_">next</span>()&#125;router.<span class="hljs-title function_">use</span>(mv)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)app.<span class="hljs-title function_">use</span>(router)</code></pre></div></li><li><p>错误级别的中间件</p><p>专门来捕获项目中抛出的异常，防止项目异常崩溃。错误级别的中间件处理函数有4个形参:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;error!&#x27;</span>)&#125;app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, mw, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title function_">errorHandler</span> = (<span class="hljs-params">err, req, res, next</span>) =&gt; &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;The error has been processed&#x27;</span>)&#125;app.<span class="hljs-title function_">use</span>(errorHandler)</code></pre></div><p>注意：错误级别的中间件必须注册在所有路由之后。</p></li><li><p>express 内置中间件</p><p>express 内置的常用中间件函数：</p><ul><li><p>express.static()：托管静态资源</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./public&#x27;</span>))</code></pre></div></li><li><p>express.json()：解析 JSON 格式的请求体</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>())</code></pre></div><p>注册了 express.json() 中间件之后，客户端发送过来的 json 格式的数据可以在路由处理函数中的 req.body 中获取：</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>)<span class="hljs-comment">// 可以拿到请求体数据</span>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;)</code></pre></div></li><li><p>express.urlencoded()：解析 URL-encoded 格式的请求体</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))</code></pre></div><p>注册了 express.urlencoded() 中间件之后，客户端发送过来的表单数据，可以在路由处理函数中的 req.body 中获取。</p></li></ul></li><li><p>第三方中间件</p><p>第三方的中间件，按需下载并注册即可。比如：使用 cors 这个第三方的中间件来解决跨域问题。</p><div class="code-wrapper"><pre><code class="hljs shell">npm install cors</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>())</code></pre></div><p>注意：在路由之前进行注册。</p></li></ol><h2 id="7-MySQL"><a href="#7-MySQL" class="headerlink" title="7. MySQL"></a>7. MySQL</h2><h3 id="7-1-安装并配置"><a href="#7-1-安装并配置" class="headerlink" title="7.1 安装并配置"></a>7.1 安装并配置</h3><p>安装：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install mysql</code></pre></div><p>配置：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<span class="hljs-keyword">const</span> db = mysql.<span class="hljs-title function_">createPool</span>(&#123;    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,    <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>,    <span class="hljs-attr">passward</span>: <span class="hljs-string">&#x27;root&#x27;</span>,    <span class="hljs-attr">databse</span>: <span class="hljs-string">&#x27;express&#x27;</span>&#125;)</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;select 1&#x27;</span>db.<span class="hljs-title function_">query</span>(sql, <span class="hljs-function">(<span class="hljs-params">error, value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (error) &#123;        <span class="hljs-keyword">throw</span> error    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<span class="hljs-comment">// [ RowDataPacket &#123; &#x27;1&#x27;: 1 &#125; ]</span>&#125;)</code></pre></div><h3 id="7-2-增删查改"><a href="#7-2-增删查改" class="headerlink" title="7.2 增删查改"></a>7.2 增删查改</h3><p>当前 express 库中 users 表结构如下，其中 id 字段自增：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>------<span class="hljs-code">+--------+</span><span class="hljs-section">| id | name | age |</span><span class="hljs-section">+----+------+--------+</span><span class="hljs-section">|  1 | foo  | 18     |</span><span class="hljs-section">+----+------+--------+</span></code></pre></div><h4 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;insert into users(name, age) values(?, ?);&#x27;</span><span class="hljs-keyword">const</span> user = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>&#125;db.<span class="hljs-title function_">query</span>(sql, [user.<span class="hljs-property">name</span>, user.<span class="hljs-property">age</span>], <span class="hljs-function">(<span class="hljs-params">error, value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (error) &#123; <span class="hljs-keyword">throw</span> error &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`affectedRows: <span class="hljs-subst">$&#123;value.affectedRows&#125;</span>`</span>)    <span class="hljs-comment">// affectedRows: 1</span>&#125;)</code></pre></div><p>如果对象的属性和字段名一一对应，那么可以进行简写：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;insert into users set ?;&#x27;</span><span class="hljs-keyword">const</span> user = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>&#125;db.<span class="hljs-title function_">query</span>(sql, user, <span class="hljs-function">(<span class="hljs-params">error, value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (error) &#123; <span class="hljs-keyword">throw</span> error &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`affectedRows: <span class="hljs-subst">$&#123;value.affectedRows&#125;</span>`</span>)&#125;)</code></pre></div><h4 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;delete from users where id=?&#x27;</span><span class="hljs-keyword">const</span> user = &#123;    <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 如果只传一个参数，那不必放在数组中</span>db.<span class="hljs-title function_">query</span>(sql, user.<span class="hljs-property">id</span>, <span class="hljs-function">(<span class="hljs-params">error, value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (error) &#123; <span class="hljs-keyword">throw</span> error &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`affectedRows: <span class="hljs-subst">$&#123;value.affectedRows&#125;</span>`</span>)&#125;)</code></pre></div><h4 id="改："><a href="#改：" class="headerlink" title="改："></a>改：</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;update users set name=?, age=? where id=?;&#x27;</span><span class="hljs-keyword">const</span> user = &#123;    <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>&#125;db.<span class="hljs-title function_">query</span>(sql, [user.<span class="hljs-property">name</span>, user.<span class="hljs-property">age</span>, user.<span class="hljs-property">id</span>], <span class="hljs-function">(<span class="hljs-params">error, value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (error) &#123; <span class="hljs-keyword">throw</span> error &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`affectedRows: <span class="hljs-subst">$&#123;value.affectedRows&#125;</span>`</span>)&#125;)</code></pre></div><p>如果对象的属性和字段名一一对应，那么可以进行简写：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;update users set ? where id=?;&#x27;</span><span class="hljs-keyword">const</span> user = &#123;    <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>&#125;db.<span class="hljs-title function_">query</span>(sql, [user, user.<span class="hljs-property">id</span>], <span class="hljs-function">(<span class="hljs-params">error, value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (error) &#123; <span class="hljs-keyword">throw</span> error &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`affectedRows: <span class="hljs-subst">$&#123;value.affectedRows&#125;</span>`</span>)&#125;)</code></pre></div><h4 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;select * from users&#x27;</span>db.<span class="hljs-title function_">query</span>(sql, user.<span class="hljs-property">id</span>, <span class="hljs-function">(<span class="hljs-params">error, value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (error) &#123; <span class="hljs-keyword">throw</span> error &#125;    <span class="hljs-comment">// value 是一个数组，每个元素是一条数据</span>    value.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item.<span class="hljs-property">id</span>, item.<span class="hljs-property">name</span>, item.<span class="hljs-property">age</span>)    &#125;)&#125;)</code></pre></div><h2 id="8-鉴权"><a href="#8-鉴权" class="headerlink" title="8. 鉴权"></a>8. 鉴权</h2><h3 id="8-1-session"><a href="#8-1-session" class="headerlink" title="8.1 session"></a>8.1 session</h3><p>安装并注册 express-session：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install express-session</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;    <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;secret key&#x27;</span>,    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>&#125;))</code></pre></div><p>注册后， session 信息会挂载到 req.session 中：</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">session</span>)&#125;)</code></pre></div><h3 id="8-2-JWT"><a href="#8-2-JWT" class="headerlink" title="8.2 JWT"></a>8.2 JWT</h3><p>JWT，JSON Web Token。通常由三部分组成，分别是 Header（头部）、Payload（载荷）和 Signature（签名）。</p><p>安装：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install jsonwebtoken express-jwt</code></pre></div><p>其中 jsonwebtoken 用于生成 JWT 字符串，express-jwt 中间件用于将 JWT 字符串解析成 JSON 对象。</p><p>使用 jsonwebtoken  生成 token：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;key&#x27;</span><span class="hljs-keyword">const</span> token = jwt.<span class="hljs-title function_">sign</span>(&#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;, secretKey, &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;3600s&#x27;</span> &#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(token)</code></pre></div><p>生成的 token 在前面加上 Bearer，放在每次请求的 Authorization 请求头中。</p><p><img src="/../images/%E3%80%90Node%E3%80%91Node%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-20230309170635451.png" alt="image-20230309170635451"></p><p>express-jwt 中间件注册后，解析出来的信息会挂载到 req.auth上。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; expressjwt &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">expressjwt</span>(&#123; <span class="hljs-attr">secret</span>: secretKey, <span class="hljs-attr">algorithms</span>: [<span class="hljs-string">&quot;HS256&quot;</span>] &#125;).<span class="hljs-title function_">unless</span>(&#123; <span class="hljs-attr">path</span>: [<span class="hljs-string">&quot;/login&quot;</span>] &#125;))app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/getInfo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">auth</span>)<span class="hljs-comment">//&#123;&quot;username&quot;:&quot;foo&quot;,&quot;password&quot;:&quot;bar&quot;,&quot;iat&quot;:1678352356,&quot;exp&quot;:1678355956&#125;</span>&#125;)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSS】grid布局</title>
    <link href="/archives/58eeb0d7.html"/>
    <url>/archives/58eeb0d7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Grid-布局"><a href="#Grid-布局" class="headerlink" title="Grid 布局"></a>Grid 布局</h1><p>grid 布局，也被称之为网格布局，是将页面中的父元素划分成一个个的格子，然后通过这些格子的合并来进行布局。</p><p>给父元素的 display 属性设置为 grid 或者 inline-grid，可以触发网格布局。grid 代表的是块状网格，默认独占一行，类似于块级元素；inline-grid 代表的是行内块网络，与行内块元素类似。</p><p>划分行列之后，才能将里面的区域进行划分，才能显示出网格。</p><p>几个基本概念：</p><ul><li><p>容器：指的是采用 grid 布局的父元素</p></li><li><p>内容：指的是显示项目的区域</p></li><li><p>项目：每个格子内部放置的元素</p></li><li><p>行 &#x2F; 列：横向 &#x2F; 纵向</p></li><li><p>网格线：横向纵向的线条。一个 m 行 n 列的网格需要 m+1 条横向和 n+1 条纵向网格线组成</p></li><li><p>单元格：横纵线条交汇的区域称之为单元格</p></li><li><p>间距：网格与网格之间的距离被称为间距</p></li></ul><p>案例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230304224031800.png" alt="image-20230304224031800" style="zoom: 67%;" /><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="1-display-触发网格布局"><a href="#1-display-触发网格布局" class="headerlink" title="1. display 触发网格布局"></a>1. display 触发网格布局</h3><p>将元素的 display 属性设置为 grid 或者 inline-grid，可以触发网格布局。当属性设置为 grid 时，元素此时表现类似块元素；当属性设置为 inline-grid 时，元素此时表现类似于行内块元素。</p><h3 id="2-grid-template-rows-x2F-grid-template-columns-划分行列"><a href="#2-grid-template-rows-x2F-grid-template-columns-划分行列" class="headerlink" title="2. grid-template-rows &#x2F; grid-template-columns 划分行列"></a>2. grid-template-rows &#x2F; grid-template-columns 划分行列</h3><p>使用 grid-template-rows 和 grid-template-columns 可以对网格进行行列的划分。这两个元素有不同的取值方式。</p><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>举例：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;&#125;</code></pre></div><p>浏览器中打开控制台，选择元素可以看到网格布局：</p><img src="../images/【CSS】grid布局/image-20230304224303123.png" alt="image-20230304224303123" style="zoom: 67%;" /><h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h4><p>举例：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">20%</span> <span class="hljs-number">30%</span> <span class="hljs-number">50%</span>;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230304224555192.png" alt="image-20230304224555192" style="zoom: 67%;" /><h4 id="repeat-参数"><a href="#repeat-参数" class="headerlink" title="repeat() 参数"></a>repeat() 参数</h4><p>repeat(num1，num2) 函数有两个参数，第一个参数代表的是重复的次数，第二个参数代表的是需要重复的数值。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">50px</span>);    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">20%</span>);&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305094750903.png" alt="image-20230305094750903" style="zoom: 67%;" /><p>可以使用 auto-fill 根据需要重复的数值，自动填充数量。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">50px</span>);    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">20%</span>);&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305095051134.png" alt="image-20230305095051134" style="zoom: 67%;" /><h4 id="auto-自动"><a href="#auto-自动" class="headerlink" title="auto 自动"></a>auto 自动</h4><p>取值为 auto，可以自适应剩下的空间</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">30px</span> auto <span class="hljs-number">20px</span>;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">20%</span>);&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305095251912.png" alt="image-20230305095251912" style="zoom: 67%;" /><h4 id="fr-片段划分"><a href="#fr-片段划分" class="headerlink" title="fr 片段划分"></a>fr 片段划分</h4><p>根据 fr 的数值可以自动计算出比例。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">20px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr <span class="hljs-number">3</span>fr;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">20%</span>);&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305095602233.png" alt="image-20230305095602233" style="zoom: 67%;" /><h4 id="minmax-函数"><a href="#minmax-函数" class="headerlink" title="minmax() 函数"></a>minmax() 函数</h4><p>minmax(min, max) 函数指定了尺寸最大最小值的闭区间。有两个参数，第一个参数指的是尺寸的最小值，第二个参数指的是尺寸的最大值。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span> <span class="hljs-built_in">minmax</span>(<span class="hljs-number">50px</span>, <span class="hljs-number">80px</span>);    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">20%</span>);&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305095918607.png" alt="image-20230305095918607" style="zoom: 67%;" /><h3 id="3-row-gap-x2F-column-gap-调整间距"><a href="#3-row-gap-x2F-column-gap-调整间距" class="headerlink" title="3. row-gap &#x2F; column-gap 调整间距"></a>3. row-gap &#x2F; column-gap 调整间距</h3><p>默认情况下，网格之间的行间距和列间距都是0。通过 row-gap &#x2F; column-gap 可以调整行列间距。</p><p>这两个属性合并在一起有一个简写形式 gap，这个属性值的第一个数值代表 row-gap，第二个数值代表 column-gap。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">50px</span>);    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">50px</span>);    <span class="hljs-attribute">row-gap</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">10px</span>;&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305101337313.png" alt="image-20230305101337313" style="zoom: 67%;" /><h3 id="4-grid-auto-flow-排列方式"><a href="#4-grid-auto-flow-排列方式" class="headerlink" title="4. grid-auto-flow 排列方式"></a>4. grid-auto-flow 排列方式</h3><p>默认情况下，grid 布局中的项目按照从左到右，从上到下进行布局：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">60px</span>);    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">60px</span>);&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305102227518.png" alt="image-20230305102227518" style="zoom: 67%;" /><p>通过设置 grid-auto-flow 属性可以控制布局方式。</p><p>可选值：</p><ul><li><p>row，逐行进行排列（默认值）</p></li><li><p>column，逐列进行排列</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<span class="hljs-attribute">grid-auto-flow</span>: column&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305102550614.png" alt="image-20230305102550614" style="zoom: 67%;" /></li></ul><h3 id="5-justify-items-x2F-align-items-项目对齐方式"><a href="#5-justify-items-x2F-align-items-项目对齐方式" class="headerlink" title="5. justify-items &#x2F; align-items 项目对齐方式"></a>5. justify-items &#x2F; align-items 项目对齐方式</h3><p>通过 justify-items &#x2F; align-items 可以设置项目的行 &#x2F; 列对齐方式。</p><p>这两个属性合并到一起有一个简写属性：place-items，这个属性的第一个数值是 justify-items 的值，第二个属性是 align-items 的值。</p><p> 可选值：</p><ul><li>start：从起始位置开始排列</li><li>end：从结束位置开始排列</li><li>center：居中对齐</li><li>stretch：自适应拉伸（前提是项目在该方向上没有尺寸）</li></ul><p>举例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">60px</span>);    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">60px</span>);&#125;<span class="hljs-selector-class">.box</span>&gt;<span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">30px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305105211831.png" alt="image-20230305105211831" style="zoom:67%;" /><p>添加项目对齐方式：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;    place-items: center center;&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305105458924.png" alt="image-20230305105458924" style="zoom:67%;" /><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;    justify-items: stretch;&#125;<span class="hljs-selector-class">.box</span>&gt;<span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-comment">/* width: 30px; */</span>&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305105758020.png" alt="image-20230305105758020" style="zoom:67%;" /><h3 id="6-justify-content-x2F-align-content-内容对齐方式"><a href="#6-justify-content-x2F-align-content-内容对齐方式" class="headerlink" title="6. justify-content &#x2F; align-content 内容对齐方式"></a>6. justify-content &#x2F; align-content 内容对齐方式</h3><p>默认情况下，网格位于容器的左上角显示。</p><img src="../images/【CSS】grid布局/image-20230305114157407.png" alt="image-20230305114157407" style="zoom:67%;" /><p>通过 justify-content &#x2F; align-content 可以设置网格在容器中的行 &#x2F; 列对齐方式。</p><p>这两个属性合并到一起有一个简写属性：place-content，这个属性的第一个数值是 justify-content 的值，第二个属性是 align-content 的值。</p><p>可选值：</p><ul><li><p>start：网格从容器的起始位置排列</p></li><li><p>end：网格从容器的结束位置开始排列</p></li><li><p>center：网格居中排列</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;place-<span class="hljs-attribute">content</span>:center center&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305114745051.png" alt="image-20230305114745051" style="zoom:67%;" /></li><li><p>space-between：均匀排列，首尾不留空</p></li><li><p>space-around：均匀排列，首尾留空，每个网格周围分配相同的空间</p></li><li><p>space-evenly：均匀排列，首尾留空，每个网格之间间隔相同</p></li><li><p>stretch：自适应拉伸（前提是在该方向下没有尺寸）</p></li></ul><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h4 id="grid-column-x2F-grid-row-合并网格"><a href="#grid-column-x2F-grid-row-合并网格" class="headerlink" title="grid-column &#x2F; grid-row 合并网格"></a>grid-column &#x2F; grid-row 合并网格</h4><p>可以使用 grid-column &#x2F; grid-row 两个属性来合并网格。属性值的格式是 <code>start/end</code>，其中 start 代表的是合并后网格的起始编号，end 代表合并后网格的结束编号。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">60px</span>);    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">60px</span>);    <span class="hljs-attribute">justify-content</span>: center;    <span class="hljs-attribute">align-content</span>: center;&#125;<span class="hljs-selector-class">.box</span>&gt;<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;&#125;<span class="hljs-selector-id">#div2</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span>/<span class="hljs-number">4</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>/<span class="hljs-number">3</span>;&#125;</code></pre></div><img src="../images/【CSS】grid布局/image-20230305121351603.png" alt="image-20230305121351603" style="zoom:67%;" />]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSS】flex布局</title>
    <link href="/archives/24ffa1ff.html"/>
    <url>/archives/24ffa1ff.html</url>
    
    <content type="html"><![CDATA[<h1 id="FlexBox"><a href="#FlexBox" class="headerlink" title="FlexBox"></a>FlexBox</h1><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="1-display-触发弹性盒子布局"><a href="#1-display-触发弹性盒子布局" class="headerlink" title="1. display 触发弹性盒子布局"></a>1. display 触发弹性盒子布局</h3><p>将元素的 display 属性设置为 flex，可以使其<strong>子元素</strong>按照弹性盒进行布局。</p><p>注意：</p><ul><li>display 设置为 flex，影响的是<strong>子元素</strong>，但是不会影响到子元素的子元素。</li><li>触发弹性盒子布局之后，子元素将默认按照<strong>块盒子</strong>显示，也就是 display 属性会变成 block。</li><li>触发弹性盒子布局之后，子元素将默认按照<strong>水平方向</strong>进行排列，如果在侧轴没有尺寸会被拉伸。</li></ul><p>几个基本概念：</p><ul><li>主轴与侧轴：主轴就是子元素排列方向的轴。子元素按水平排列，主轴就是横向（水平方向），侧轴就是纵向（垂直方向）；子元素按垂直排列，主轴就是纵向，侧轴就是横向。默认主轴在水平方向。侧轴也叫交叉轴。</li><li>容器和项目：容器指的就是设置 display 为 flex 的父元素；项目指的就是这个父元素的所有子元素。</li></ul><p>案例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bigbox&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;    <span class="hljs-comment">/* flexbox */</span>    <span class="hljs-attribute">display</span>: flex&#125;<span class="hljs-selector-class">.bigbox</span>&gt;<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230302222700176.png" alt="image-20230302222700176" style="zoom:67%;" /><h3 id="2-flex-direction-主轴方向"><a href="#2-flex-direction-主轴方向" class="headerlink" title="2. flex-direction 主轴方向"></a>2. flex-direction 主轴方向</h3><p>flexbox 默认主轴方向为水平方向。通过 flex-direction 属性可以设置主轴方向，也就是元素按什么方向排列。</p><p>可选值：</p><ul><li><p>row：水平排列（默认值）</p><img src="../images/【CSS】flex布局/image-20230302222712716.png" alt="image-20230302222712716" style="zoom: 67%;" /></li><li><p>row-reverse：水平排列，但置换主轴的起点和终点</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span> &#123;    <span class="hljs-attribute">flex-direction</span>: row-reverse;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230302223001753.png" alt="image-20230302223001753" style="zoom:67%;" /></li><li><p>column：垂直排列</p><img src="../images/【CSS】flex布局/image-20230302223032072.png" alt="image-20230302223032072" style="zoom:67%;" /></li><li><p>column-reverse：垂直排列，但置换主轴的起点和终点</p><img src="../images/【CSS】flex布局/image-20230302223109170.png" alt="image-20230302223109170" style="zoom:67%;" /></li></ul><h3 id="3-justify-content-主轴对齐方式"><a href="#3-justify-content-主轴对齐方式" class="headerlink" title="3. justify-content 主轴对齐方式"></a>3. justify-content 主轴对齐方式</h3><p>flexbox 默认从主轴的起始位置开始排列。通过 justify-content 属性可以设置元素如何沿着主轴排列，并分配空间。</p><p>可选值：</p><ul><li><p>normal：初始值（相当于flex-start）</p></li><li><p>flex-start：起始位置开始排列，项目无间距</p><img src="../images/【CSS】flex布局/image-20230302224112505.png" alt="image-20230302224112505" style="zoom:67%;" /></li><li><p>flex-end：结束位置开始排列，项目无间距</p><img src="../images/【CSS】flex布局/image-20230302224020903.png" alt="image-20230302224020903" style="zoom:67%;" /></li><li><p>center：从居中位置开始排列，项目无间距</p><img src="../images/【CSS】flex布局/image-20230302223823484.png" alt="image-20230302223823484" style="zoom:67%;" /></li><li><p>space-between：均匀排列，首尾不留空</p><img src="../images/【CSS】flex布局/image-20230302224257091.png" alt="image-20230302224257091" style="zoom:67%;" /></li><li><p>space-around：均匀排列，首尾留空，每个元素周围分配相同的空间</p><img src="../images/【CSS】flex布局/image-20230302224359564.png" alt="image-20230302224359564" style="zoom:67%;" /></li><li><p>space-evenly：均匀排列，首尾留空，每个元素之间间隔相同</p><img src="../images/【CSS】flex布局/image-20230302224507518.png" alt="image-20230302224507518" style="zoom:67%;" /></li><li><p>stretch：自适应拉伸（前提是项目在该方向下没有尺寸）</p></li></ul><h3 id="4-align-items-侧轴对齐方式"><a href="#4-align-items-侧轴对齐方式" class="headerlink" title="4. align-items 侧轴对齐方式"></a>4. align-items 侧轴对齐方式</h3><p>flex-box 默认从侧轴的起始位置沿着主轴方向开始排列，通过 align-items 属性可以设置从侧轴何处开始排列。</p><p>可选值：</p><ul><li><p>normal：初始值（相当于 flex-start）</p></li><li><p>flex-start：从侧轴的开始位置进行排列</p><img src="../images/【CSS】flex布局/image-20230304102535744.png" alt="image-20230304102535744" style="zoom:67%;" /></li><li><p>flex-end：从侧轴的结束位置进行排列</p><img src="../images/【CSS】flex布局/image-20230303225341903.png" alt="image-20230303225341903" style="zoom:67%;" /></li><li><p>center：居中开始排列</p><img src="../images/【CSS】flex布局/image-20230304102934605.png" alt="image-20230304102934605" style="zoom:67%;" /></li><li><p>stretch：自适应拉伸。前提是，子元素是没有侧轴方向的尺寸。比如，主轴在水平方向时，子元素想要侧轴自适应拉伸，那就不能设置高度值。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span> &#123;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">align-items</span>: stretch;&#125;<span class="hljs-selector-class">.bigbox</span>&gt;<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;    <span class="hljs-comment">/* height: 50px; */</span>&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230304103210328.png" alt="image-20230304103210328" style="zoom:67%;" /></li></ul><h3 id="5-flex-wrap-换行显示"><a href="#5-flex-wrap-换行显示" class="headerlink" title="5. flex-wrap 换行显示"></a>5. flex-wrap 换行显示</h3><p>在没有触发弹性盒子之前，当子元素过多时，由于元素保持自己的宽度和高度，会显示出<strong>溢出</strong>效果：</p><img src="../images/【CSS】flex布局/image-20230303230053702.png" alt="image-20230303230053702" style="zoom:50%;" /><p>当触发弹性盒子之后，子元素会沿着主轴排列，当子元素过多时，元素会丢掉自己的主轴方向尺寸，显示出<strong>压缩</strong>效果：</p><img src="../images/【CSS】flex布局/image-20230303230107301.png" alt="image-20230303230107301" style="zoom:67%;" /><p>也就是说，默认情况下项目是不会换行显示的。通过 flex-wrap 属性可以设置是否换行显示。</p><p>可选值：</p><ul><li><p>nowrap：不换行显示（默认值）</p></li><li><p>wrap：换行显示。设置后项目保持自己的尺寸，并且在超出容器时自动<strong>换行</strong>显示。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span>&#123;<span class="hljs-attribute">flex-wrap</span>: wrap;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230303230738029.png" alt="image-20230303230738029" style="zoom:67%;" /></li></ul><p>不过这种方式也会存在一些问题：</p><ol><li><p>如果一行中剩余的宽度不够排列下一个元素，会默认留白并换行排列。</p></li><li><p>当子元素设置了固定的高度之后，行与行之间会留出间距。此时，如果不设置子元素的高度，那么子元素会沿着侧轴进行拉伸，高度均匀地分布在每一行之间。</p><img src="../images/【CSS】flex布局/image-20230303230920021.png" alt="image-20230303230920021" style="zoom:67%;" /></li></ol><h3 id="6-align-content-行间距"><a href="#6-align-content-行间距" class="headerlink" title="6. align-content 行间距"></a>6. align-content 行间距</h3><p>当设置换行显示之后，如果子元素设置了固定的高度，行与行之间会留出间距。通过 align-content 属性可以控制这个行间距。</p><p>可选值：</p><ul><li><p>normal：初始值（相当于 flex-start）</p></li><li><p>flex-start：每行元素在侧轴的起始位置排列，并且没有行间距。</p><img src="../images/【CSS】flex布局/image-20230303232045934.png" alt="image-20230303232045934" style="zoom:67%;" /></li><li><p>flex-end：每行元素在侧轴的结束位置开始排列（正向），并且没有行间距。</p><img src="../images/【CSS】flex布局/image-20230303232105492.png" alt="image-20230303232105492" style="zoom:67%;" /></li><li><p>space-between：均匀排列，首尾不留空</p><img src="../images/【CSS】flex布局/image-20230303232333980.png" alt="image-20230303232333980" style="zoom:67%;" /><p>如果有3排：</p><img src="../images/【CSS】flex布局/image-20230303232358461.png" alt="image-20230303232358461" style="zoom:67%;" /></li><li><p>space-around：均匀排列，首尾留空，每个元素周围分配相同的空间</p><img src="../images/【CSS】flex布局/image-20230303232449180.png" alt="image-20230303232449180" style="zoom:67%;" /></li><li><p>space-evenly：均匀排列，首尾留空，每个元素之间间隔相同</p><img src="../images/【CSS】flex布局/image-20230303232532106.png" alt="image-20230303232532106" style="zoom:67%;" /></li></ul><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="1-align-self-项目侧轴对齐方式"><a href="#1-align-self-项目侧轴对齐方式" class="headerlink" title="1. align-self 项目侧轴对齐方式"></a>1. align-self 项目侧轴对齐方式</h3><p>默认情况下，项目按照容器设置的 align-items 属性进行侧轴对齐。通过 align-self 属性，可以给项目设置自己的侧轴对齐方式。</p><p>可选值：</p><ul><li><p>auto：设置为容器（父元素）的 align-items 值</p></li><li><p>flex-start：从侧轴开始位置进行排列</p></li><li><p>flex-end：从侧轴结束位置开始排列</p><img src="../images/【CSS】flex布局/image-20230304083345465.png" alt="image-20230304083345465" style="zoom:67%;" /></li><li><p>center：从侧轴居中位置开始排列</p><img src="../images/【CSS】flex布局/image-20230304083502182.png" alt="image-20230304083502182" style="zoom:67%;" /></li><li><p>stretch：自适应拉伸（在该项目的侧轴方向没有尺寸的情况下）</p><img src="../images/【CSS】flex布局/image-20230304084208589.png" alt="image-20230304084208589" style="zoom:67%;" /></li></ul><h3 id="2-order-项目调整显示顺序"><a href="#2-order-项目调整显示顺序" class="headerlink" title="2. order 项目调整显示顺序"></a>2. order 项目调整显示顺序</h3><p>触发弹性盒子之后，项目默认按主轴横向显示，并且从左到右依次排列。使用 order 属性可以对项目的显示顺序进行调整。</p><p>可选值：</p><ul><li>auto：默认值（可以理解为0）</li><li>数值（可以正数负数0）：值越小越靠前，值越大越靠后</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bigbox&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;    <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.bigbox</span>&gt;<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;&#125;<span class="hljs-selector-id">#div2</span> &#123;    <span class="hljs-comment">/* 可以是正数、负数、0 或者 auto,auto可以看作是0*/</span>    <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230304110154330.png" alt="image-20230304110154330" style="zoom:67%;" /><h3 id="3-flex-1-项目自适应剩余空间"><a href="#3-flex-1-项目自适应剩余空间" class="headerlink" title="3. flex: 1 项目自适应剩余空间"></a>3. flex: 1 项目自适应剩余空间</h3><p>当主轴在横向的时候，设置 flex: 1，项目会占据剩余所有宽度。</p><img src="../images/【CSS】flex布局/image-20230304085843576.png" alt="image-20230304085843576" style="zoom:67%;" /><p>当主轴在纵向的时候，设置 flex: 1，项目会占据剩余所有高度。</p><img src="../images/【CSS】flex布局/image-20230304085914811.png" alt="image-20230304085914811" style="zoom:67%;" /><p>当多个项目都设置了flex: 1，项目会平分剩余空间：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#div1</span>,<span class="hljs-selector-id">#div2</span> &#123;    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230304111916739.png" alt="image-20230304111916739" style="zoom:67%;" /><blockquote><p>flex 是一个复合属性，是由flex-grow、flex-shrink、flex-basis 三个属性复合得来的。</p><p>设置 flex: 1，相当于 flex:1 1 0，也就是flex-grow: 1 、flex-shrink: 1、flex-basis: 0</p></blockquote><h3 id="4-flex-grow-x2F-flex-shrink-x2F-flex-basis"><a href="#4-flex-grow-x2F-flex-shrink-x2F-flex-basis" class="headerlink" title="4.  flex-grow &#x2F; flex-shrink &#x2F; flex-basis"></a>4.  flex-grow &#x2F; flex-shrink &#x2F; flex-basis</h3><p>flex-basis 属性可以设置在分配多余空间之前，项目占据的主轴空间。浏览器会根据这个属性来计算主轴是否存在多余空间。初始值为 auto，省略时默认值为0。</p><p>flex-grow 属性可以设置项目的放大比例。初始值为0， 也就是即使存在剩余空间也不会放大；flex-grow 属性如果是一个数值 n，表示放大为 flex-grow 等于 1 的元素 n 倍。省略时默认值为1。</p><p>flex-shrink 属性可以设置项目的收缩比例。最常用的有两个可选值：初始值为0，表示不压缩；省略时默认值为1，表示项目进行压缩。</p><p>举例：</p><p>默认情况下，flexbox 中项目会失去原有的宽度，产生一个宽度压缩的效果：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bigbox&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;    <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.bigbox</span>&gt;<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230304092833513.png" alt="image-20230304092833513" style="zoom:67%;" /><p>如果将 flex-shrink 设置为0，则项目宽度不会发生压缩：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span>&gt;<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230304093107049.png" alt="image-20230304093107049" style="zoom:67%;" /><p>如果想横向滚动，可以再给容器添加一个 overflow: auto。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span> &#123;    <span class="hljs-attribute">overflow</span>: auto;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230304093407677.png" alt="image-20230304093407677" style="zoom:67%;" /><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="水平垂直居中对齐"><a href="#水平垂直居中对齐" class="headerlink" title="水平垂直居中对齐"></a>水平垂直居中对齐</h3><p>想让一个元素水平垂直居中对齐，可以将其父元素设置为弹性盒子（display: flex）,并且设置项目 margin: auto。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bigbox&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;    <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.bigbox</span>&gt;<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;    <span class="hljs-attribute">margin</span>: auto;&#125;</code></pre></div><img src="../images/【CSS】flex布局/image-20230304094054471.png" alt="image-20230304094054471" style="zoom:67%;" /><p>或者在容器上使用 justify-content 和 align-items 设置主轴和侧轴居中对齐：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.bigbox</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid gray;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">justify-content</span>: center;    <span class="hljs-attribute">align-items</span>: center;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【TypeScript】基础笔记</title>
    <link href="/archives/8a5a935d.html"/>
    <url>/archives/8a5a935d.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><h2 id="1-1-什么是-TypeScript"><a href="#1-1-什么是-TypeScript" class="headerlink" title="1.1 什么是 TypeScript"></a>1.1 什么是 TypeScript</h2><ul><li><p>JavaScript 的超集，一门建立在 JavaScript 上的语言。</p></li><li><p>为 JavaScript 添加了新特性和优势。</p></li><li><p>无法在 JavaScript 环境中运行，但最终会编译成 JavaScript。</p></li></ul><h2 id="1-2-为什么使用-TypeScript"><a href="#1-2-为什么使用-TypeScript" class="headerlink" title="1.2 为什么使用 TypeScript"></a>1.2 为什么使用 TypeScript</h2><ul><li>JavaScript 中没有类型系统。因此，可能写出符合 JavaScript 语法，但是逻辑有错误的代码。</li><li>使用 TypeScript 提供的类型系统，可以避免因为弱类型带来的错误。</li></ul><h2 id="1-3-搭建开发环境"><a href="#1-3-搭建开发环境" class="headerlink" title="1.3 搭建开发环境"></a>1.3 搭建开发环境</h2><ol><li><p>安裝 node.js</p></li><li><p>全局安装 typescript </p><div class="code-wrapper"><pre><code class="hljs shell">npm i -g typescript</code></pre></div></li><li><p>检查是否安装成功</p><div class="code-wrapper"><pre><code class="hljs shell">tsc -v</code></pre></div></li></ol><h2 id="1-4-Hello-World"><a href="#1-4-Hello-World" class="headerlink" title="1.4 Hello World"></a>1.4 Hello World</h2><ol><li><p>编写 TypeScript 代码</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 在文件 hello-world.ts 中：</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)</code></pre></div></li><li><p>编译 TypeScript 代码</p><div class="code-wrapper"><pre><code class="hljs shell">tsc hello-world.ts</code></pre></div><p>编译器会将 .ts 文件编译成 .js 文件。在目录下会生成文件：hello-world.js</p></li><li><p>执行 JavaScript 代码</p><div class="code-wrapper"><pre><code class="hljs shell">node hello-world.js</code></pre></div></li></ol><h1 id="2-类型"><a href="#2-类型" class="headerlink" title="2 类型"></a>2 类型</h1><h2 id="2-1-类型声明"><a href="#2-1-类型声明" class="headerlink" title="2.1 类型声明"></a>2.1 类型声明</h2><h3 id="2-1-1-变量声明"><a href="#2-1-1-变量声明" class="headerlink" title="2.1.1 变量声明"></a>2.1.1 变量声明</h3><p>定义变量时，在变量名后声明变量的类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// number</span><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><span class="hljs-comment">// string</span><span class="hljs-keyword">let</span> <span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;hello world&#x27;</span><span class="hljs-comment">// boolean</span><span class="hljs-keyword">let</span> <span class="hljs-attr">flag</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span></code></pre></div><p>定义变量并初始化时，即使不声明变量的类型，编译器也能被根据初始值判断出变量类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// number</span><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><span class="hljs-comment">// string</span><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&#x27;hello world&#x27;</span><span class="hljs-comment">// boolean</span><span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></code></pre></div><h3 id="2-1-2-函数参数声明"><a href="#2-1-2-函数参数声明" class="headerlink" title="2.1.2 函数参数声明"></a>2.1.2 函数参数声明</h3><p>定义函数时，在形参的后面声明形参的类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-keyword">return</span> a + b&#125;</code></pre></div><h3 id="2-1-3-函数返回值声明"><a href="#2-1-3-函数返回值声明" class="headerlink" title="2.1.3 函数返回值声明"></a>2.1.3 函数返回值声明</h3><p>定义函数时，在形参列表的后面声明函数返回值的类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSumMsg</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> &#123;    <span class="hljs-keyword">return</span> (a + b).<span class="hljs-title function_">toString</span>()&#125;</code></pre></div><h3 id="2-1-4-箭头函数声明"><a href="#2-1-4-箭头函数声明" class="headerlink" title="2.1.4 箭头函数声明"></a>2.1.4 箭头函数声明</h3><p>同时声明箭头函数的参数类型和返回值类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">sum</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><span class="hljs-comment">// 形参名不必和定义时保持一致，但是类型需要保持一致</span>sum = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;    <span class="hljs-keyword">return</span> x + y&#125;</code></pre></div><h2 id="2-2-所有类型"><a href="#2-2-所有类型" class="headerlink" title="2.2 所有类型"></a>2.2 所有类型</h2><h3 id="2-2-1-基本类型"><a href="#2-2-1-基本类型" class="headerlink" title="2.2.1 基本类型"></a>2.2.1 基本类型</h3><table><thead><tr><th>数据类型</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>任意类型</td><td>any</td><td>声明为 any 的变量可以赋予任意类型的值。</td></tr><tr><td>未知类型</td><td>unknown</td><td>未知类型的变量。</td></tr><tr><td>void</td><td>void</td><td>用于标识方法返回值的类型，表示该方法没有返回值。</td></tr><tr><td>never</td><td>never</td><td>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</td></tr><tr><td>数组</td><td>无</td><td>声明变量为数组。</td></tr><tr><td>元组</td><td>无</td><td>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。</td></tr><tr><td>枚举</td><td>enum</td><td>枚举类型用于定义数值集合。</td></tr><tr><td>数字类型</td><td>number</td><td>同 JavaScript</td></tr><tr><td>字符串类型</td><td>string</td><td>同 JavaScript</td></tr><tr><td>布尔类型</td><td>boolean</td><td>同 JavaScript</td></tr><tr><td>null</td><td>null</td><td>同 JavaScript</td></tr><tr><td>undefined</td><td>undefined</td><td>同 JavaScript</td></tr></tbody></table><h4 id="2-2-1-1-any-x2F-unknown"><a href="#2-2-1-1-any-x2F-unknown" class="headerlink" title="2.2.1.1 any &#x2F; unknown"></a>2.2.1.1 any &#x2F; unknown</h4><p>对变量声明为 any 类型，相当于对该变量关闭类型检测：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">any</span>foo = <span class="hljs-number">10</span>foo = <span class="hljs-string">&#x27;bar&#x27;</span>foo = <span class="hljs-literal">true</span></code></pre></div><p>不声明变量的类型，隐式为 any 类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> foofoo = <span class="hljs-number">10</span>foo = <span class="hljs-string">&#x27;bar&#x27;</span>foo = <span class="hljs-literal">true</span></code></pre></div><p>any 类型的变量可以赋值给任何类型。这可能导致其他类型的变量与声明的类型不符：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">10</span><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>:<span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;bar&#x27;</span><span class="hljs-comment">//将 any 类型数据赋值给count，导致count 与声明的类型不符</span>count = foo<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count) <span class="hljs-comment">// &#x27;bar&#x27;</span></code></pre></div><p>当不知道应该给变量声明为什么类型时，建议将其声明为 unknown：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>:<span class="hljs-built_in">unknown</span>foo = <span class="hljs-number">10</span>foo = <span class="hljs-string">&#x27;bar&#x27;</span>foo = <span class="hljs-literal">true</span></code></pre></div><p>unknown 类型的变量不可以赋值给其他类型变量，但可以赋值给 同样为 unknown 类型的变量：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>:<span class="hljs-built_in">unknown</span> = <span class="hljs-number">10</span><span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>:<span class="hljs-built_in">unknown</span>bar = foo</code></pre></div><h4 id="2-2-1-2-void"><a href="#2-2-1-2-void" class="headerlink" title="2.2.1.2 void"></a>2.2.1.2 void</h4><p>对函数返回值声明为 void，表示函数没有明确的返回值：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printFn</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;print...&#x27;</span>)&#125;</code></pre></div><p>定义函数时，如果不声明函数返回值的类型，那么函数返回值隐式声明为 void：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printFn</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;print...&#x27;</span>)&#125;</code></pre></div><p>但是，如果函数有返回值，即使不声明函数返回值的类型，那么编译器也会自动推断函数返回值的类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 自动推断函数返回值的类型：10 | &#x27;foo&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">5</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>    &#125;&#125;</code></pre></div><p>如果对变量声明为 void，只能将其赋值为 null 或 undefined。</p><h4 id="2-2-1-3-never"><a href="#2-2-1-3-never" class="headerlink" title="2.2.1.3 never"></a>2.2.1.3 never</h4><p>对函数返回值声明为 never，表示函数不会返回结果（比如：死循环、抛出错误）：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()&#125;</code></pre></div><h4 id="2-2-1-4-number-x2F-string-x2F-boolean"><a href="#2-2-1-4-number-x2F-string-x2F-boolean" class="headerlink" title="2.2.1.4 number &#x2F; string &#x2F; boolean"></a>2.2.1.4 number &#x2F; string &#x2F; boolean</h4><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// number</span><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><span class="hljs-comment">// string</span><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&#x27;hello world&#x27;</span><span class="hljs-comment">// boolean</span><span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></code></pre></div><p>可以直接使用字面量进行类型声明。声明后不可以赋值为其他字面量（类似常量）：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 使用单个字面量进行类型声明</span><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-number">10</span> = <span class="hljs-number">10</span><span class="hljs-comment">// 使用多个字面量进行类型声明</span><span class="hljs-keyword">let</span> <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;foo&#x27;</span> | <span class="hljs-string">&#x27;bar&#x27;</span> = <span class="hljs-string">&#x27;foo&#x27;</span>msg = <span class="hljs-string">&#x27;bar&#x27;</span></code></pre></div><h3 id="2-2-2-对象类型"><a href="#2-2-2-对象类型" class="headerlink" title="2.2.2 对象类型"></a>2.2.2 对象类型</h3><h4 id="2-2-2-1-指定属性"><a href="#2-2-2-1-指定属性" class="headerlink" title="2.2.2.1 指定属性"></a>2.2.2.1 指定属性</h4><p>声明一个变量为对象类型的同时，还要指定这个对象应该存在的属性以及该属性的类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> &#125;</code></pre></div><p>变量的属性及其类型应该与定义时的规定保持一致。属性多了少了、类型错误都不行：</p><div class="code-wrapper"><pre><code class="hljs typescript">obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 报错</span>obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>&#125;<span class="hljs-comment">// 报错</span>obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">20</span> &#125; <span class="hljs-comment">// 报错</span></code></pre></div><h4 id="2-2-2-2-可选属性"><a href="#2-2-2-2-可选属性" class="headerlink" title="2.2.2.2 可选属性"></a>2.2.2.2 可选属性</h4><p>声明变量时，如果不确定某个属性是否一定存在，可以使用<code>?</code>来表示该属性可选：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>, c?: <span class="hljs-built_in">boolean</span> &#125;obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 正确</span>obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;<span class="hljs-comment">// 正确</span></code></pre></div><p>也可使用<code>[propName: string]</code>来表示任意属性名：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 必须有一个number类型的a属性，其余属性类型不限制</span><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span> &#125;</code></pre></div><h4 id="2-2-2-3-数组"><a href="#2-2-2-3-数组" class="headerlink" title="2.2.2.3 数组"></a>2.2.2.3 数组</h4><p>有两种方式将变量声明为数组：使用<code>Array</code>和<code>[]</code>。</p><p>使用<code>Array</code>：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;&#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> &#125;&gt; = [    &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;]</code></pre></div><p>在类型后加上<code>[]</code>：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> &#125;[] = [    &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;]</code></pre></div><h4 id="2-2-2-4-元组"><a href="#2-2-2-4-元组" class="headerlink" title="2.2.2.4 元组"></a>2.2.2.4 元组</h4><p>元组可看作数量和对应位置元素类型固定的数组：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>] = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-literal">true</span>]</code></pre></div><h4 id="2-2-2-5-枚举"><a href="#2-2-2-5-枚举" class="headerlink" title="2.2.2.5 枚举"></a>2.2.2.5 枚举</h4><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span> &#123;<span class="hljs-title class_">Male</span>, <span class="hljs-title class_">Female</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">person</span>: &#123; <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span> &#125; = &#123; <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Male</span> &#125;</code></pre></div><h3 id="2-2-3-联合类型"><a href="#2-2-3-联合类型" class="headerlink" title="2.2.3 联合类型"></a>2.2.3 联合类型</h3><p>使用<code>|</code>来连接多种类型，表示多种类型满足其一即可：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> = <span class="hljs-number">10</span>foo = <span class="hljs-string">&#x27;bar&#x27;</span></code></pre></div><p>使用<code>&amp;</code>来连接多种类型，表示多种类型要同时满足：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span> &#125; &amp; &#123; <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> &#125;foo =  = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;</code></pre></div><h2 id="2-3-类型断言"><a href="#2-3-类型断言" class="headerlink" title="2.3 类型断言"></a>2.3 类型断言</h2><p>可以对变量的类型进行断言，来告诉编译器不知道类型的变量其实际类型。</p><p>有两种方式对变量的类型进行断言：<code>as</code> 和 <code>&lt;&gt;</code>。</p><p>使用 <code>as</code>：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-string">&#x27;bar&#x27;</span>foo = bar <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span></code></pre></div><p>使用<code>&lt;&gt;</code>：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-string">&#x27;bar&#x27;</span>foo = &lt;<span class="hljs-built_in">string</span>&gt;bar</code></pre></div><h2 id="2-4-类型别名"><a href="#2-4-类型别名" class="headerlink" title="2.4 类型别名"></a>2.4 类型别名</h2><p>使用 type 关键字可以给类型起一个别名：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> myType = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>,    <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>,    <span class="hljs-attr">c</span>: <span class="hljs-built_in">boolean</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: myType = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> &#125;</code></pre></div><h1 id="3-tsc-编译选项"><a href="#3-tsc-编译选项" class="headerlink" title="3 tsc 编译选项"></a>3 tsc 编译选项</h1><h2 id="3-1-w-监视文件变化"><a href="#3-1-w-监视文件变化" class="headerlink" title="3.1 -w 监视文件变化"></a>3.1 -w 监视文件变化</h2><p>使用 <code>-w</code> 选项来监视文件的变化，当文件发生变化时，自动将 .ts 文件编译成 .js 文件：</p><div class="code-wrapper"><pre><code class="hljs shell">tsc &lt;文件名&gt;.ts -w</code></pre></div><h2 id="3-2-生成-tsconfig-json"><a href="#3-2-生成-tsconfig-json" class="headerlink" title="3.2 生成 tsconfig.json"></a>3.2 生成 tsconfig.json</h2><p>tsconfig.json 中记录着 ts 编译器的配置。使用 <code>--init</code> 参数可以生成默认配置。</p><div class="code-wrapper"><pre><code class="hljs shell">tsc --init</code></pre></div><p>当前目录下存在 tsconfig.json 文件时，使用 tsc 命令即可编译当前目录下所有文件。加上 <code>-w</code> 参数即可监视所有文件。</p><div class="code-wrapper"><pre><code class="hljs shell">tsc -w</code></pre></div><h2 id="3-3-tsconfig-json-配置项"><a href="#3-3-tsconfig-json-配置项" class="headerlink" title="3.3 tsconfig.json 配置项"></a>3.3 tsconfig.json 配置项</h2><p>配置文档 <a href="https://www.typescriptlang.org/zh/tsconfig">https://www.typescriptlang.org/zh/tsconfig</a></p><h3 id="3-3-1-include-x2F-exclude-x2F-files"><a href="#3-3-1-include-x2F-exclude-x2F-files" class="headerlink" title="3.3.1 include &#x2F; exclude &#x2F; files"></a>3.3.1 include &#x2F; exclude &#x2F; files</h3><p>include 用来指定哪些 ts 文件需要被编译，。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-string">&quot;./src/*&quot;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><blockquote><p>注：<code>**</code>匹配任意目录，<code>*</code>匹配任意文件，”.&#x2F;src&#x2F;**&#x2F;*”匹配当前目录下的 src 目录下的任意目录下的任意文件</p></blockquote><p>exclude 用来指定哪些 ts 文件不需要被编译。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-string">&quot;./src/demo/*&quot;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>files 用来指定哪些文件需要被编译，需要将文件路径。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>    &#x27;foo.ts&#x27;<span class="hljs-punctuation">,</span> &#x27;bar.ts&#x27;  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h3 id="3-3-2-compilerOptions"><a href="#3-3-2-compilerOptions" class="headerlink" title="3.3.2 compilerOptions"></a>3.3.2 compilerOptions</h3><p>compilerOptions 编译器选项中常用子选项如下：</p><ol><li>target：指定 ts 被编译为 ES 的版本。</li><li>module：指定编译后使用的模块化规范。</li><li>lib：指定需要使用的库。</li><li>outDir：指定编译生成的代码输出的目录。</li><li>outFile：将所有编译后的代码合并为一个文件。</li><li>allowJs：是否编译 js 文件。</li><li>checkJs：是否检查 js 文件是否符合 ts 规范。</li><li>removeComments：是否一处注释。</li><li>noEmit：是否生成编译后的代码。</li><li>noEmitOnError：编译出错时是否生成代码。</li><li>strict：严格模式。</li><li>alwaysStrict：是否开启严格模式。</li><li>noImplicitAny：是否允许隐式 any 类型。</li><li>noImplicitThis：是否允许不明确的 this。</li><li>…</li></ol><h1 id="4-webpack-打包-ts-文件"><a href="#4-webpack-打包-ts-文件" class="headerlink" title="4 webpack 打包 ts 文件"></a>4 webpack 打包 ts 文件</h1><h2 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a>4.1 准备工作</h2><ol><li><p>初始化 node 项目，生成 package.json 文件</p><div class="code-wrapper"><pre><code class="hljs shell">npm install -y</code></pre></div></li><li><p>安装 webpack、webpack-cli、typescript、ts-loader</p><div class="code-wrapper"><pre><code class="hljs shell">npm install -D webpack webpack-cli typescript ts-loader</code></pre></div><blockquote><p>注：-D 参数表示安装的是开发依赖。</p></blockquote></li><li><p>配置 webpack</p><p>在根目录下新建 webpack.config.js 文件，然后配置如下信息：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 path 包</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">// 配置信息都应该写在 module.exports 中</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-comment">// 入口文件</span>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.ts&#x27;</span>,    <span class="hljs-comment">// 打包后的文件</span>    <span class="hljs-attr">output</span>: &#123;        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>    &#125;,    <span class="hljs-comment">// 设置 webpack 为开发模式</span>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,        <span class="hljs-comment">// webpack 打包时要使用的模块</span>    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-comment">// 指定加载规则</span>        <span class="hljs-attr">rules</span>: [            &#123;                <span class="hljs-comment">// test 指定规则生效的文件</span>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,                <span class="hljs-comment">// 指定要使用的 loader</span>                <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,                <span class="hljs-comment">// 要排除的文件</span>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>            &#125;        ]    &#125;&#125;</code></pre></div></li><li><p>配置 ts</p><p>根目录下执行：<code>tsc --init</code>，生成 tsconfig.json 文件。</p></li><li><p>在 package.json 中添加配置：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#125;</span></code></pre></div></li><li><p>构建</p><div class="code-wrapper"><pre><code class="hljs shell">npm run build</code></pre></div></li></ol><h2 id="4-2-进阶配置"><a href="#4-2-进阶配置" class="headerlink" title="4.2 进阶配置"></a>4.2 进阶配置</h2><h3 id="4-3-1-html-webpack-plugin"><a href="#4-3-1-html-webpack-plugin" class="headerlink" title="4.3.1 html-webpack-plugin"></a>4.3.1 html-webpack-plugin</h3><p>html-webpack-plugin 插件可以自动生成 index.html 并引入所 js需文件。</p><ol><li><p>安装插件</p><div class="code-wrapper"><pre><code class="hljs shell">npm install -D html-webpack-plugin</code></pre></div></li><li><p>更新 webpack 配置</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 path 包</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">// 引入 html 插件</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HTMLWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<span class="hljs-comment">// 配置信息都应该写在 module.exports 中</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-comment">// 入口文件</span>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.ts&#x27;</span>,    <span class="hljs-comment">// 打包后的文件</span>    <span class="hljs-attr">output</span>: &#123;        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>    &#125;,    <span class="hljs-comment">// 设置 webpack 为开发模式</span>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,        <span class="hljs-comment">// webpack 打包时要使用的模块</span>    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-comment">// 指定加载规则</span>        <span class="hljs-attr">rules</span>: [            &#123;                <span class="hljs-comment">// test 指定规则生效的文件</span>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,                <span class="hljs-comment">// 指定要使用的 loader</span>                <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,                <span class="hljs-comment">// 要排除的文件</span>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>            &#125;        ]    &#125;,    <span class="hljs-comment">// 配置插件：</span>    <span class="hljs-attr">plugins</span>:[        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLWebpackPlugin</span>()    ]&#125;</code></pre></div></li><li><p>构建</p><div class="code-wrapper"><pre><code class="hljs shell">npm run build</code></pre></div><p>可以看到 dist 输出目录下多了一个 index.html 文件。</p></li><li><p>（可选）实例化 html 插件时传入配置，实现自定义页面标题。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HTMLWebpackPlugin</span> = <span class="hljs-title function_">require</span>(<span class="hljs-params"><span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span></span>)&#123;    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;        <span class="hljs-attr">plugins</span>: [            <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLWebpackPlugin</span>(&#123;<span class="hljs-attr">title</span>:<span class="hljs-string">&quot;&quot;</span>&#125;)        ]    &#125;&#125;</code></pre></div></li></ol><h3 id="4-3-2-webpack-dev-server"><a href="#4-3-2-webpack-dev-server" class="headerlink" title="4.3.2 webpack-dev-server"></a>4.3.2 webpack-dev-server</h3><p>webpack-dev-server 插件能监视文件变化，并自动打包构建。</p><ol><li><p>安装插件</p><div class="code-wrapper"><pre><code class="hljs shell">npm install -D webpack-dev-server</code></pre></div></li><li><p>在 package.json 中添加如下配置</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve --open index.html&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#125;</span></code></pre></div></li><li><p>运行</p><div class="code-wrapper"><pre><code class="hljs shell">npm run start</code></pre></div><p>webpack-dev-server 插件会开启服务器，在浏览器中打开 html-webpack-plugin 插件生成的 index.html，监视其变化并自动打包构建。</p></li></ol><h3 id="4-3-3-clean-webpack-plugin"><a href="#4-3-3-clean-webpack-plugin" class="headerlink" title="4.3.3 clean-webpack-plugin"></a>4.3.3 clean-webpack-plugin</h3><p>clean-webpack-plugin 插件可以在构建时先把 dist 文件夹下的旧文件清楚，然后再接着构建。</p><ol><li><p>安装插件</p><div class="code-wrapper"><pre><code class="hljs shell">npm install -D clean-webpack-plugin</code></pre></div></li><li><p>更新 webpack 配置</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 path 包</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">// 引入 html 插件</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HTMLWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<span class="hljs-comment">// 引入 clean 插件</span><span class="hljs-keyword">const</span> &#123;<span class="hljs-title class_">CleanWebpackPlugin</span>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<span class="hljs-comment">// 配置信息都应该写在 module.exports 中</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-comment">// 入口文件</span>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.ts&#x27;</span>,    <span class="hljs-comment">// 打包后的文件</span>    <span class="hljs-attr">output</span>: &#123;        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>    &#125;,    <span class="hljs-comment">// 设置 webpack 为开发模式</span>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,    <span class="hljs-comment">// webpack 打包时要使用的模块</span>    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-comment">// 指定加载规则</span>        <span class="hljs-attr">rules</span>: [            &#123;                <span class="hljs-comment">// test 指定规则生效的文件</span>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,                <span class="hljs-comment">// 指定要使用的 loader</span>                <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,                <span class="hljs-comment">// 要排除的文件</span>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>            &#125;        ]    &#125;,    <span class="hljs-comment">// 配置插件：</span>    <span class="hljs-attr">plugins</span>: [        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLWebpackPlugin</span>(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;ts-demo&#x27;</span> &#125;)    ]&#125;</code></pre></div></li></ol><h3 id="4-3-4-配置引用模块"><a href="#4-3-4-配置引用模块" class="headerlink" title="4.3.4 配置引用模块"></a>4.3.4 配置引用模块</h3><p>默认配置下，webpack 不知道哪些文件是否可以作为模块被引入。如果想要引入 ts、js 作为模块代码，需要配置 webpack.config.js 如下选项：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 path 包</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">// 引入 html 插件</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HTMLWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<span class="hljs-comment">// 引入 clean 插件</span><span class="hljs-keyword">const</span> &#123;<span class="hljs-title class_">CleanWebpackPlugin</span>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<span class="hljs-comment">// 配置信息都应该写在 module.exports 中</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-comment">// 入口文件</span>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.ts&#x27;</span>,    <span class="hljs-comment">// 打包后的文件</span>    <span class="hljs-attr">output</span>: &#123;        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>    &#125;,    <span class="hljs-comment">// 设置 webpack 为开发模式</span>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,    <span class="hljs-comment">// webpack 打包时要使用的模块</span>    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-comment">// 指定加载规则</span>        <span class="hljs-attr">rules</span>: [            &#123;                <span class="hljs-comment">// test 指定规则生效的文件</span>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,                <span class="hljs-comment">// 指定要使用的 loader</span>                <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,                <span class="hljs-comment">// 要排除的文件</span>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>            &#125;        ]    &#125;,    <span class="hljs-comment">// 配置插件：</span>    <span class="hljs-attr">plugins</span>: [        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLWebpackPlugin</span>(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;ts-demo&#x27;</span> &#125;)    ],    <span class="hljs-comment">// 配置引用模块</span>    <span class="hljs-attr">resolve</span>: &#123;        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>]    &#125;&#125;</code></pre></div><h3 id="4-3-5-babel"><a href="#4-3-5-babel" class="headerlink" title="4.3.5 babel"></a>4.3.5 babel</h3><p>为了让编译后的代码具备更好的兼容性，还需配置 babel 工具。</p><ol><li><p>安装依赖</p><div class="code-wrapper"><pre><code class="hljs shell">npm i -D @babel/core @babel/preset-env babel-loader core-js</code></pre></div></li><li><p>更新 webpack 配置</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 path 包</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">// 引入 html 插件</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HTMLWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<span class="hljs-comment">// 引入 clean 插件</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<span class="hljs-comment">// 配置信息都应该写在 module.exports 中</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-comment">// 入口文件</span>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.ts&#x27;</span>,    <span class="hljs-comment">// 打包后的文件</span>    <span class="hljs-attr">output</span>: &#123;        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,        <span class="hljs-attr">environment</span>: &#123;            <span class="hljs-attr">arrowFunction</span>: <span class="hljs-literal">false</span>        &#125;    &#125;,    <span class="hljs-comment">// 设置 webpack 为开发模式</span>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,    <span class="hljs-comment">// webpack 打包时要使用的模块</span>    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-comment">// 指定加载规则</span>        <span class="hljs-attr">rules</span>: [            &#123;                <span class="hljs-comment">// test 指定规则生效的文件</span>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,                <span class="hljs-comment">// 指定要使用的 loader</span>                <span class="hljs-attr">use</span>: [                    <span class="hljs-comment">// 配置 babel</span>                    &#123;                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,                        <span class="hljs-attr">options</span>: &#123;                            <span class="hljs-comment">// 设置预定义环境</span>                            <span class="hljs-attr">presets</span>: [                                [                                    <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,                                    &#123;                                        <span class="hljs-attr">targets</span>: &#123;                                            <span class="hljs-string">&quot;chrome&quot;</span>: <span class="hljs-string">&quot;100&quot;</span>,                                        &#125;,                                        <span class="hljs-attr">corejs</span>: <span class="hljs-string">&quot;3&quot;</span>,                                        <span class="hljs-comment">// 按需加载</span>                                        <span class="hljs-attr">useBuiltIns</span>: <span class="hljs-string">&quot;usage&quot;</span>,                                    &#125;                                ]                            ]                        &#125;                    &#125;,                    <span class="hljs-string">&#x27;ts-loader&#x27;</span>                ],                <span class="hljs-comment">// 要排除的文件</span>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>            &#125;        ]    &#125;,    <span class="hljs-comment">// 配置插件：</span>    <span class="hljs-attr">plugins</span>: [        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLWebpackPlugin</span>(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;ts-demo&#x27;</span> &#125;)    ],    <span class="hljs-comment">// 配置引用模块</span>    <span class="hljs-attr">resolve</span>: &#123;        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>]    &#125;&#125;</code></pre></div></li></ol><h2 id="5-面向对象"><a href="#5-面向对象" class="headerlink" title="5 面向对象"></a>5 面向对象</h2><h2 id="5-1-类"><a href="#5-1-类" class="headerlink" title="5.1 类"></a>5.1 类</h2><h3 id="5-1-1-属性声明"><a href="#5-1-1-属性声明" class="headerlink" title="5.1.1 属性声明"></a>5.1.1 属性声明</h3><p>跟 js 相比，不同点在于需要在类中先声明属性及其类型。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;        <span class="hljs-comment">// 声明属性</span>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>    <span class="hljs-keyword">static</span> <span class="hljs-attr">sum</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">8</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age    &#125;    <span class="hljs-title function_">sayName</span>(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getNumber</span>(): <span class="hljs-built_in">number</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">sum</span>    &#125;&#125;<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">10</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>)     <span class="hljs-comment">// 10</span>person.<span class="hljs-title function_">sayName</span>()            <span class="hljs-comment">// my name is foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">getNumber</span>()) <span class="hljs-comment">// 8</span></code></pre></div><h3 id="5-1-2-属性修饰符"><a href="#5-1-2-属性修饰符" class="headerlink" title="5.1.2 属性修饰符"></a>5.1.2 属性修饰符</h3><p>ts 中可以给类中属性添加属性修饰符：public,private,protected</p><ol><li>public：公有属性。属性可以进行访问或修改。</li><li>private：私有属性。属性只能在类的内部进行访问或修改。</li><li>protected：保护属性。属性只能在类的内部或者子类的内部进行访问或修改。</li></ol><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age    &#125;&#125;<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">19</span>)</code></pre></div><p>也可以直接将属性声明在构造函数的形参列表中，不必在构造函数中进行属性的初始化赋值，形成以下简写形式：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span></span>) &#123;&#125; &#125;<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">19</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person)</code></pre></div><h2 id="5-2-继承"><a href="#5-2-继承" class="headerlink" title="5.2 继承"></a>5.2 继承</h2><p>与 js 无二异。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;    <span class="hljs-attr">addr</span>: <span class="hljs-built_in">string</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, addr: <span class="hljs-built_in">string</span></span>) &#123;        <span class="hljs-variable language_">super</span>(name, age)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">addr</span> = addr    &#125;&#125;<span class="hljs-comment">// Teacher &#123;name: &#x27;foo&#x27;, age: 30, addr: &#x27;bar&#x27;&#125;</span><span class="hljs-keyword">const</span> teacher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)</code></pre></div><h2 id="5-3-抽象类"><a href="#5-3-抽象类" class="headerlink" title="5.3 抽象类"></a>5.3 抽象类</h2><p>什么是抽象类：</p><ul><li>被 abstract 修饰，不能被实例化，只能用作继承。</li><li>可以包含抽象方法，子类必须对抽象方法进行重写。</li></ul><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age    &#125;    <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">sayHello</span>(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;        <span class="hljs-variable language_">super</span>(name, age)    &#125;    <span class="hljs-title function_">sayHello</span>(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello, i am a teacher&#x27;</span>)    &#125;&#125;<span class="hljs-keyword">const</span> teacher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">10</span>)teacher.<span class="hljs-title function_">sayHello</span>()</code></pre></div><h2 id="5-4-接口"><a href="#5-4-接口" class="headerlink" title="5.4 接口"></a>5.4 接口</h2><h3 id="5-4-1-定义"><a href="#5-4-1-定义" class="headerlink" title="5.4.1 定义"></a>5.4.1 定义</h3><p>接口用来定义一个类的结构，包括应该存在的属性和方法。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>    <span class="hljs-title function_">sayHello</span>(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <span class="hljs-title function_">sayHello</span>(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)    &#125;&#125;</code></pre></div><h3 id="5-4-2-实现"><a href="#5-4-2-实现" class="headerlink" title="5.4.2 实现"></a>5.4.2 实现</h3><p>定义在一个类实现一个接口，满足接口的要求。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>    <span class="hljs-title function_">sayHello</span>(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age    &#125;    <span class="hljs-title function_">sayHello</span>(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello &#x27;</span>)    &#125;&#125;</code></pre></div><h3 id="5-4-3-用于类型声明"><a href="#5-4-3-用于类型声明" class="headerlink" title="5.4.3 用于类型声明"></a>5.4.3 用于类型声明</h3><p>接口也可以用来类型声明。</p><p>interface 和 type 进行类型声明的区别：</p><p>interface 允许重复声明；type 不允许重复声明。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = &#123;    <span class="hljs-attr">bar</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">qux</span>: <span class="hljs-built_in">number</span>&#125;<span class="hljs-comment">// 重复声明，报错</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = &#123;    <span class="hljs-attr">baz</span>: <span class="hljs-built_in">string</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;    <span class="hljs-attr">bar</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">qux</span>: <span class="hljs-built_in">number</span>&#125;<span class="hljs-comment">// 可以重复声明</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;    <span class="hljs-attr">baz</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 声明多个同名的 interface 时，这些同名的 interface 都要满足。</span><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">Foo</span> = &#123;    <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,    <span class="hljs-attr">qux</span>: <span class="hljs-number">10</span>,    <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;baz&#x27;</span>&#125;</code></pre></div><h2 id="5-5-泛型"><a href="#5-5-泛型" class="headerlink" title="5.5 泛型"></a>5.5 泛型</h2><p>定义时不指定确切的类型，运行时根据实际情况来确定类型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> fn&lt;T&gt;(<span class="hljs-attr">x</span>: T):T &#123;    <span class="hljs-keyword">return</span> x&#125;fn&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">10</span>)fn&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// 也可以让编译器进行类型推断：</span><span class="hljs-title function_">fn</span>(<span class="hljs-number">10</span>)<span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)</code></pre></div><p>多个泛型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> fn&lt;T, K&gt;(<span class="hljs-attr">x</span>: T, <span class="hljs-attr">y</span>: K): &#123; <span class="hljs-attr">x</span>: T, <span class="hljs-attr">y</span>: K &#125; &#123;    <span class="hljs-keyword">return</span> &#123; x, y &#125;&#125;<span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">10</span>)</code></pre></div><p>给泛型做出一些限制，比如限制实现某些接口的泛型：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age    &#125;&#125;<span class="hljs-keyword">function</span> fn&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&gt;(<span class="hljs-attr">person</span>: T): <span class="hljs-built_in">number</span> &#123;    <span class="hljs-keyword">return</span> person.<span class="hljs-property">age</span>&#125;<span class="hljs-keyword">const</span> teacher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(teacher))</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript】浅拷贝和深拷贝</title>
    <link href="/archives/f1b2b1fb.html"/>
    <url>/archives/f1b2b1fb.html</url>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝：对于基本数据类型，拷贝的是值；对于引用数据类型，拷贝的是对象的地址。</p><h3 id="1-for-in"><a href="#1-for-in" class="headerlink" title="1 for-in"></a>1 for-in</h3><p>使用 for-in 遍历原对象中的属性，并将属性名和属性值拷贝到新对象中。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">obj</span>) &#123;    <span class="hljs-keyword">let</span> newObj = &#123;&#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> obj) &#123;        newObj[prop] = obj[prop]    &#125;    <span class="hljs-keyword">return</span> newObj&#125;<span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhang san&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <span class="hljs-attr">school</span>: &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;THU&#x27;</span>,    &#125;&#125;<span class="hljs-keyword">let</span> newObj = <span class="hljs-title function_">copy</span>(obj)obj.<span class="hljs-property">school</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;PKU&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj)</code></pre></div><img src="../images/【JavaScript】浅拷贝和深拷贝/image-20230122193038681.png" alt="image-20230122193038681" style="zoom:50%;" /><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="1-for-in-递归"><a href="#1-for-in-递归" class="headerlink" title="1 for-in + 递归"></a>1 for-in + 递归</h3><p>判断原对象的每个属性值是否是对象，如果是则递归调用拷贝函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">obj</span>) &#123;    <span class="hljs-keyword">let</span> newObj = &#123;&#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> obj) &#123;        <span class="hljs-keyword">if</span> (obj[prop] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;            newObj[prop] = <span class="hljs-title function_">copy</span>(obj[prop])        &#125; <span class="hljs-keyword">else</span> &#123;            newObj[prop] = obj[prop]        &#125;    &#125;    <span class="hljs-keyword">return</span> newObj&#125;<span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhang san&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <span class="hljs-attr">school</span>: &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;THU&#x27;</span>,    &#125;&#125;<span class="hljs-keyword">let</span> newObj = <span class="hljs-title function_">copy</span>(obj)obj.<span class="hljs-property">school</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;PKU&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj)</code></pre></div><img src="../images/【JavaScript】浅拷贝和深拷贝/image-20230122205449366.png" alt="image-20230122205449366" style="zoom:50%;" /><h3 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2 JSON"></a>2 JSON</h3><p>使用 JSON.stringify() 将原对象转为字符串，再使用 JSON.parse() 将该字符串转为一个新的对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">obj</span>) &#123;    <span class="hljs-keyword">let</span> objString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)    <span class="hljs-keyword">let</span> newObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(objString)    <span class="hljs-keyword">return</span> newObj&#125;<span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhang san&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <span class="hljs-attr">school</span>: &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;THU&#x27;</span>,    &#125;&#125;<span class="hljs-keyword">let</span> newObj = <span class="hljs-title function_">copy</span>(obj)obj.<span class="hljs-property">school</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;PKU&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj)</code></pre></div><img src="../images/【JavaScript】浅拷贝和深拷贝/image-20230122212258742.png" alt="image-20230122212258742" style="zoom:50%;" />]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript】运行机制</title>
    <link href="/archives/ca3aff80.html"/>
    <url>/archives/ca3aff80.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-同步和异步"><a href="#1-同步和异步" class="headerlink" title="1 同步和异步"></a>1 同步和异步</h2><p>同步：按顺序执行代码，上一代码行完成后再执行下一行。</p><p>异步：运行时间长的操作在执行时，不影响其他同步代码。操作完成时通知运行结果。</p><p>JavaScript 中的异步操作：</p><ul><li><p>定时器</p></li><li><p>发送请求</p></li><li><p>读写文件</p></li><li><p>Promise 实例的 then() 方法</p></li><li><p>…</p></li></ul><p><strong>执行顺序</strong>：</p><ol><li>同步代码</li><li>异步代码</li></ol><p>举例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 5 2 3 4</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)</code></pre></div><h2 id="2-单线程"><a href="#2-单线程" class="headerlink" title="2 单线程"></a>2 单线程</h2><p>JavaScript 是单线程的，只能等一个任务执行完毕后执行下一个任务。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1000个1 5 234</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)&#125;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)</code></pre></div><p>定时器只负责在指定的时间将任务插入任务队列中，不关心任务的具体执行时间。无论定时器设置的时间是多少，都会让同步的代码先执行完。所以有时会有定时器没有按指定的时间运行的感觉，因为需要等同步代码和任务队列中前面的代码执行完毕。</p><h2 id="3-process-nextTick-和-setImmediate"><a href="#3-process-nextTick-和-setImmediate" class="headerlink" title="3 process.nextTick() 和 setImmediate()"></a>3 process.nextTick() 和 setImmediate()</h2><p>注：process.nextTick() 只能在 Node 中运行。</p><p>process.nextTick() 在同步代码完成之后，异步代码完成之前执行。setImmediate() 在异步代码完成之后执行。</p><p><strong>执行顺序</strong>：</p><ol><li>同步代码</li><li>process.nextTick()</li><li>异步代码</li><li>setImmediate()</li></ol><p>举例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 3 2 4</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) &#125;, <span class="hljs-number">0</span>)process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)&#125;)<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)&#125;)</code></pre></div><h2 id="4-事件循环"><a href="#4-事件循环" class="headerlink" title="4 事件循环"></a>4 事件循环</h2><p>同步代码存在运行栈中，异步代码存在任务队列中。事件循环不停地检测任务队列中的是否有任务，如果有就按顺序执行。</p><p><strong>执行顺序</strong>：</p><ul><li>同步代码</li><li>process.nextTick()</li><li>异步代码</li><li>当前时间循环结束后执行 setImmediate()</li></ul><p>举例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 5 2 4 6 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>) &#125;, <span class="hljs-number">1000</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>) &#125;, <span class="hljs-number">0</span>)process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)&#125;)<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)&#125;)</code></pre></div><h2 id="5-宏任务和微任务"><a href="#5-宏任务和微任务" class="headerlink" title="5 宏任务和微任务"></a>5 宏任务和微任务</h2><p>宏任务：计时器、发送请求、读取文件</p><p>微任务：Promise 实例的 then() 方法</p><p>先执行微任务再执行宏任务。</p><p><strong>执行顺序</strong>：</p><ol><li>同步代码</li><li>process.nextTick()</li><li>微任务</li><li>宏任务</li><li>当前时间循环结束后执行 setImmediate()</li></ol><p>举例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 7 5 8 2 4 6 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>) &#125;, <span class="hljs-number">1000</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>) &#125;, <span class="hljs-number">0</span>)process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)&#125;)<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)&#125;)<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)    <span class="hljs-title function_">resolve</span>()&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)&#125;)</code></pre></div><h2 id="6-Promise-和-async-x2F-await"><a href="#6-Promise-和-async-x2F-await" class="headerlink" title="6 Promise 和 async&#x2F;await"></a>6 Promise 和 async&#x2F;await</h2><p>构造 Promise 实例时传入的执行器函数是同步代码。Promise 实例的 then() 方法是微任务。</p><p>async 能把函数的返回值用 Promise.resolve() 包装成一个 Promise 实例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>&#125;<span class="hljs-title function_">fn</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) &#125;)  <span class="hljs-comment">// foo</span></code></pre></div><p>await 关键字会等待表达式返回 Promise 对象，并把 Promise 对象进行解包。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>  &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn</span>()    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;<span class="hljs-title function_">test</span>()<span class="hljs-comment">// foo</span></code></pre></div><p>await 后面的代码可以看作是 Pormise 实例 then() 方法中的代码。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 3 5 7 2 6 4</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn2</span>()    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)&#125;<span class="hljs-title function_">fn1</span>()<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>) &#125;, <span class="hljs-number">0</span>)<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)    <span class="hljs-title function_">resolve</span>()&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】28.事件</title>
    <link href="/archives/4ad9257b.html"/>
    <url>/archives/4ad9257b.html</url>
    
    <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="1-事件流"><a href="#1-事件流" class="headerlink" title="1 事件流"></a>1 事件流</h2><p><strong>事件</strong>意味着用户或浏览器执行的某种动作。比如，单击（click）、加载（load）、鼠标悬停 （mouseover）。<strong>事件流</strong>描述页面接收事件的顺序。有两种事件流：事件冒泡和事件捕获。</p><h3 id="1-1-事件冒泡"><a href="#1-1-事件冒泡" class="headerlink" title="1.1 事件冒泡"></a>1.1 事件冒泡</h3><p>事件冒泡指的是事件被定义为从最具体的元素触发，然后传播到没那么具体的元素。也就是从内向外触发。</p><h3 id="1-2-事件捕获"><a href="#1-2-事件捕获" class="headerlink" title="1.2 事件捕获"></a>1.2 事件捕获</h3><p>事件捕获指的是事件被定义为从最不具体的元素触发，然后传播到具体的元素。也就是从外向内触发。</p><h3 id="1-3-DOM2-事件流"><a href="#1-3-DOM2-事件流" class="headerlink" title="1.3 DOM2 事件流"></a>1.3 DOM2 事件流</h3><p>DOM2 事件流规定了事件流分三个阶段：事件捕获，到达元素，事件冒泡。一般认为事件处理是<strong>事件冒泡</strong>的一部分。</p><h2 id="2-事件监听器"><a href="#2-事件监听器" class="headerlink" title="2 事件监听器"></a>2 事件监听器</h2><p>为响应事件而调用的函数被称为事件处理程序（或事件监听器）。事件处理程序的名字 以”on”开头，因此 click 事件的处理程序叫作 onclick，而 load 事件的处理程序叫作 onload。</p><h3 id="2-1-HTML-事件处理程序"><a href="#2-1-HTML-事件处理程序" class="headerlink" title="2.1 HTML 事件处理程序"></a>2.1 HTML 事件处理程序</h3><p>给 HTML 元素加事件处理程序：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;hello world&#x27;)&quot;</span>/&gt;</span></code></pre></div><p>以这种方式指定的事件处理程序有一些特殊的地方：</p><p>会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量 event：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(event)&quot;</span>/&gt;</span></code></pre></div><img src="../images/【JavaScript】28_事件/image-20230119111915003.png" alt="image-20230119111915003" style="zoom:50%;" /><p>在这个函数中，this 值相当于事件的目标元素：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(this)&quot;</span>/&gt;</span></code></pre></div><img src="../images/【JavaScript】28_事件/image-20230119111954119.png" alt="image-20230119111954119" style="zoom:50%;" /><p>函数的作用域链被扩展了。在这个函数中， document 和元素自身的成员都可以被当成局部变量来访问：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数等价于使用了 with：</span><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">document</span></span>) &#123;        <span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;            <span class="hljs-comment">// 属性值</span>        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click Me&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(value)&quot;</span>&gt;</span> // Click Me</code></pre></div><p>如果这个元素是一个表单输入框，则作用域链中还会包含表单元素：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数等价于：</span><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">document</span></span>) &#123;        <span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>.form</span>) &#123;            <span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;                <span class="hljs-comment">// 属性值</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Echo Username&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(username.value)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><h3 id="2-2-DOM0-事件处理程序"><a href="#2-2-DOM0-事件处理程序" class="headerlink" title="2.2 DOM0 事件处理程序"></a>2.2 DOM0 事件处理程序</h3><p>在 JavaScript 中指定事件处理程序，先取得元素的引用，然后把函数赋值给给元素的事件处理程序属性：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)&#125;</code></pre></div><p>事件处理程序是普通函数（不是箭头函数时）this 等于元素值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<span class="hljs-comment">// input 元素</span>&#125;</code></pre></div><p>事件处理程序是箭头函数时，this 等于 window 对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)btn.<span class="hljs-property">onclick</span> = <span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;</code></pre></div><p>移除事件处理程序，直接将属性值赋值为 null。</p><h3 id="2-3-DOM2-事件处理程序"><a href="#2-3-DOM2-事件处理程序" class="headerlink" title="2.3 DOM2 事件处理程序"></a>2.3 DOM2 事件处理程序</h3><p>DOM2 定义了两个方法来添加事件处理程序：addEventListener() 和 removeEventListener()。</p><h4 id="2-3-1-addEventListener-添加事件处理程序"><a href="#2-3-1-addEventListener-添加事件处理程序" class="headerlink" title="2.3.1 addEventListener() 添加事件处理程序"></a>2.3.1 addEventListener() 添加事件处理程序</h4><p>addEventListener() 接收3个参数：事件名、事件处理程序和一个布尔值。布尔值为 true 时，表示在事件捕获阶段待用事件处理程序；布尔值为 false时，表示在事件冒泡阶段调用事件处理程序。默认 false。</p><p>事件处理程序是普通函数（不是箭头函数时）this 等于元素值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)   <span class="hljs-comment">// input 元素</span>&#125;)</code></pre></div><p>事件处理程序是箭头函数时，this 等于 window 对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)   <span class="hljs-comment">// Window 对象</span>&#125;)</code></pre></div><p>使用 DOM2 方式可以给元素的一个事件添加<strong>多个</strong>事件处理程序：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)&#125;)btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)&#125;)<span class="hljs-comment">// foo</span><span class="hljs-comment">// bar</span></code></pre></div><h4 id="2-3-2-removeEventListener-移除事件处理程序"><a href="#2-3-2-removeEventListener-移除事件处理程序" class="headerlink" title="2.3.2 removeEventListener() 移除事件处理程序"></a>2.3.2 removeEventListener() 移除事件处理程序</h4><p>通过 addEventListener() 添加的事件处理程序必须用 removeEventListener() 移除。</p><p>想要 removeEventListener() 有效果，就必须传给它和 addEventListener() 时<strong>完全一样</strong>的参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)&#125;)<span class="hljs-comment">// 不起效果，因为传入的事件处理程序不是同一个</span>btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">()=&gt;</span>[    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)])</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<span class="hljs-comment">// 定义事件处理程序</span>handler = <span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)&#125;btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler)<span class="hljs-comment">// 起效果</span>btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler)</code></pre></div><h2 id="3-事件对象"><a href="#3-事件对象" class="headerlink" title="3 事件对象"></a>3 事件对象</h2><p>无论使用哪种方式添加的事件监听器，所有相关信息都会被收集并存储在一个名为 event 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>)=&gt;</span>&#123;<span class="hljs-comment">// 传不传参数均可</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">// 传不传参数均可</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)&#125;)</code></pre></div><p>属性：</p><ul><li>currentTarget，元素，当前事件处理程序所在的元素</li><li>target，元素，事件目标</li></ul><p>在事件处理程序内部，this 对象始终等于 currentTarget 的值，而 target 只包含事件的实际目标。</p><p>更多属性和方法见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event">MDN</a> 。</p><p>注：event 对象只在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。</p><h2 id="4-事件类型"><a href="#4-事件类型" class="headerlink" title="4 事件类型"></a>4 事件类型</h2><p>所有事件类型见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">MDN</a>。</p><h2 id="5-事件委托"><a href="#5-事件委托" class="headerlink" title="5 事件委托"></a>5 事件委托</h2><p>多个子元素的事件可以委托给父元素，以达到节省事件处理程序所占内存的目的。使用 event.target 可以区分出事件具体发生在哪个子元素。</p><p>比如，想给多个 li 元素添加事件：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#list&#x27;</span>)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> li <span class="hljs-keyword">of</span> ul.<span class="hljs-property">childNodes</span>)&#123;    li.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<span class="hljs-comment">// li 元素</span>    &#125;)&#125;</code></pre></div><p>使用事件委托后：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#list&#x27;</span>)ul.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<span class="hljs-comment">// ul 元素</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>)<span class="hljs-comment">// li 元素</span>&#125;)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】27.DOM</title>
    <link href="/archives/90b269fc.html"/>
    <url>/archives/90b269fc.html</url>
    
    <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="1-DOM-API"><a href="#1-DOM-API" class="headerlink" title="1 DOM API"></a>1 DOM API</h2><p>任何 HTML 都可以用 DOM 表示为一个由节点构成的层级结构。节点分为 12 种不同类型，最常用的是 Document 类型和 Element 类型。</p><h3 id="1-1-Node-类型"><a href="#1-1-Node-类型" class="headerlink" title="1.1 Node 类型"></a>1.1 Node 类型</h3><p>所有的节点类型都实现了 Node 接口。也就是说，所有的节点类型都有 Node 中的属性和方法。</p><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><ul><li>nodeType 节点类型<ul><li>由 12 个数值常量来表示。例如：Node.ELEMENT_NODE 为1。</li></ul></li><li>nodeName 节点名<ul><li>具体值取决于节点类型。</li></ul></li><li>nodeValue 节点值<ul><li>具体值取决于节点类型。</li></ul></li><li>ownerDocument 节点顶层 document 对象</li></ul><p><strong>表示节点关系</strong>：</p><ul><li>childNodes 子节点列表<ul><li>返回值是 NodeList 实例。NodeList 是一个类数组对象。节点关系变化时，NodeList 实例会自动更新。</li><li>可以使用 NodeList 实例的 item(id) 方法或者 [id] 语法来获取子节点。</li></ul></li><li>parentNode 父节点</li><li>previousSibling 前一个兄弟节点</li><li>nextSibling 后一个兄弟节点</li><li>firstChild 第一个子节点</li><li>lastChild 最后一个子节点</li></ul><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul><li><p>hasChildNodes() 查询是否有子节点</p><ul><li>不需要参数</li><li>返回值：true 表示有；false 表示没有</li></ul></li><li><p>appendChild() 添加子节点到子节点列表末尾</p><ul><li>接受一个参数：要添加的子节点</li><li>返回值：添加的子节点</li><li>会在 childNodes 末尾添加节点，节点关系指针会随之变化。</li><li>把已有的节点传给该方法时，已有节点将从之前的位置移动到新位置。</li></ul></li><li><p>insetBefore() 添加子节点到参照节点前</p><ul><li>接受两个参数：要插入的子节点和参照节点</li><li>返回值：插入的子节点</li><li>传入的参照节点是 null 时，效果等同于 appendChild()</li></ul></li><li><p>replaceChild() 替换指定节点</p><ul><li>接受两个参数：要插入的节点和要替换的节点</li><li>返回值：被替换的子节点</li></ul></li><li><p>removeChild() 删除节点</p><ul><li>接受一个参数：要删除的节点</li><li>返回值：被删除的节点</li></ul></li><li><p>cloneNode() 克隆节点</p><ul><li>接受一个布尔值参数：true 代表深复制，复制节点和子 DOM；false 代表浅复制，只复制节点。</li><li>返回值：新节点。该节点属于当前 document，但是没有指定父节点，也就是孤儿节点。</li><li>只复制 HTML 属性，不复制 JavaScript 属性（比如绑定的事件）。</li></ul></li><li><p>normalize() 整理节点</p><ul><li>由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点层级之间互为同胞关系。在节点上调用 normalize() 方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。</li></ul></li></ul><h3 id="1-2-Document-类型"><a href="#1-2-Document-类型" class="headerlink" title="1.2 Document 类型"></a>1.2 Document 类型</h3><p>Document 类型表示文档节点。在浏览器中，文档对象 document 表示整个 HTML 页面。document 是 window 对象的属性，因此是一个全局对象。因为实现了 Node 接口，所有 Node 身上的属性和方法 document 都有。</p><h4 id="继承自-Node："><a href="#继承自-Node：" class="headerlink" title="继承自 Node："></a>继承自 Node：</h4><p>属性：</p><ul><li>nodeType 值为 9</li><li>nodeName 值为 “#document”</li><li>nodeValue 值为 null</li><li>parentNode 值为 null</li><li>ownerDocument 值为 null</li></ul><p>方法：</p><ul><li>一般不会对 document 使用 appendChild()、removeChild() 和 replaceChild() 方法。因为 document 只有一个子节点：html 元素。</li></ul><h4 id="属性：-1"><a href="#属性：-1" class="headerlink" title="属性："></a>属性：</h4><p>便捷指针：</p><ul><li>documentElement 指向 html 元素</li><li>activeElement 指向当前具有焦点的元素（HTML5 新增）</li><li>body 指向 body 元素</li><li>head 指向 head 元素（HTML5 新增）</li><li>doctype 指向 doctype 元素</li></ul><p>文档信息：</p><ul><li>title 页面标题</li><li>URL 完整 URL</li><li>domain 域名</li><li>referrer 页面来源</li><li>characterSet 字符集（HTML5 新增）</li></ul><p>特殊集合：</p><ul><li>anchors<ul><li>包含文档中所有带 name 属性的元素。</li></ul></li><li>forms<ul><li>包含文档中所有 form 元素（与 document.getElementsByTagName (“form”) 返回的结果相同）。</li></ul></li><li>images<ul><li>包含文档中所有 img 元素（与 document.getElementsByTagName (“img”) 返回的结果相同)。</li></ul></li><li>links<ul><li>包含文档中所有带 href 属性的元素。</li></ul></li></ul><h4 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h4><p>获取元素：</p><ul><li>getElementById()<ul><li>接受一个参数：要获取元素的 id 属性值。参数必须完全匹配，区分大小写。</li><li>返回值：找到返回元素；未找到返回 null。</li><li>如果有多个相同 id 的元素，只返回第一个。</li></ul></li><li>getElementsByTagName()<ul><li>接受一个参数：要获取元素的标签名。参数规范区分大小写。</li><li>返回值：一个 HTMLCollection 对象，表示具有该标签名的所有节点。</li><li>该 HTMLCollection 实例身上的方法：<ul><li>item(id) 或者 [id] 语法来获取节点。</li><li>namedItem(name) 或者 [name] 语法来通过 name 属性获取节点。如有多个只返回第一个。</li></ul></li></ul></li><li>getElementsByName()<ul><li>接受一个参数：要获取元素的 name 属性值。</li><li>返回值：一个 HTMLCollection 对象，表示具有 name 属性的所有节点。</li></ul></li></ul><p>文档写入：</p><ul><li><p>write() </p><ul><li>将字符串文本写入网页</li></ul></li><li><p>writeln()</p><ul><li>将字符串文本写入网页并换行</li></ul></li><li><p>open() </p><ul><li>打开文档写入流</li></ul></li><li><p>close()</p><ul><li>关闭文档写入流</li></ul></li></ul><h3 id="1-3-Element-类型"><a href="#1-3-Element-类型" class="headerlink" title="1.3 Element 类型"></a>1.3 Element 类型</h3><p>Element 代表 HTML 中的元素。所有 HTML 元素都通过 HTMLElement 类型表示。</p><h4 id="继承自-Node：-1"><a href="#继承自-Node：-1" class="headerlink" title="继承自 Node："></a>继承自 Node：</h4><ul><li>nodeType 等于 1</li><li>nodeName 值为元素的标签名</li><li>nodeValue 值为 null</li><li>parentNode 值为 Document 或 Element 对象</li></ul><h4 id="继承自-Element："><a href="#继承自-Element：" class="headerlink" title="继承自 Element："></a>继承自 Element：</h4><p>所有 HTML 元素身上都有的标准属性：</p><ul><li>id，元素在文档中的唯一标识符；</li><li>title，包含元素的额外信息，通常以提示条形式展示；</li><li>lang，元素内容的语言代码（很少用）；</li><li>dir，语言的书写方向（”ltr”表示从左到右，”rtl”表示从右到左，同样很少用）； </li><li>className，相当于 class 属性，用于指定元素的 CSS 类。</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bd&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Body text&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">&quot;ltr&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">id</span>)<span class="hljs-comment">// myDiv</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">title</span>)<span class="hljs-comment">// Body text</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">lang</span>)<span class="hljs-comment">// en</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">dir</span>)<span class="hljs-comment">// ltr</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">className</span>)<span class="hljs-comment">// bd</span></code></pre></div><h4 id="属性：-2"><a href="#属性：-2" class="headerlink" title="属性："></a>属性：</h4><ul><li><p>tagName 元素标签名</p><ul><li>等同于 nodeName 属性。元素标签名始终以<strong>全大写</strong>表示。</li></ul></li><li><p>attributes </p><p>每个元素的 attributes 属性包含一个 NamedNodeMap 实例，代表该元素属性的集合。</p><blockquote><p>NamedNodeMap 的用法：</p><p>属性：</p><ul><li>nodeName 属性名</li><li>nodeValue 属性值</li></ul><p>方法：</p><ul><li><p>item(pos)，返回索引位置 pos 处的节点，也可以使用中括号来访问。</p></li><li><p>getNamedItem(name)，返回 nodeName 属性等于 name 的节点</p></li><li><p>setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引</p></li><li><p>removeNamedItem(name)，删除 nodeName 属性等于 name 的节点</p></li></ul><p>举例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">attributes</span>)</code></pre></div></blockquote></li><li><p>style 元素样式</p></li></ul><h4 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h4><p>创建元素：</p><ul><li>document.createElement()<ul><li>接受一个参数：要创建元素的标签名</li><li>返回值：新创建的元素</li></ul></li></ul><p>操作属性：</p><ul><li><p>getAttribute()</p><ul><li>接受一个参数：要获取的属性名。属性名不区分大小写。</li><li>返回值：若有该属性则返回属性值，否则返回 null</li></ul></li><li><p>setAttribute()</p><ul><li>接受两个参数：要设置的属性名和属性值</li><li>设置的属性名将规范为小写形式。如果已存在则替换，否则新建。</li><li>自定义属性名应该以 data- 为前缀</li></ul></li><li><p>removeAttribute()</p><ul><li>接受一个参数：要删除的属性名</li><li>将属性完全从元素中删除</li></ul></li></ul><h2 id="2-Selectors-API"><a href="#2-Selectors-API" class="headerlink" title="2 Selectors API"></a>2 Selectors API</h2><p>Selectors API 可以根据 CSS 选择符的模式匹配 DOM 元素，而不是使用 getElementById()和 getElementsByTagName()。</p><h3 id="2-1-querySelector"><a href="#2-1-querySelector" class="headerlink" title="2.1 querySelector()"></a>2.1 querySelector()</h3><p>querySelector() 方法接收 CSS 选择符参数，返回匹配该模式的<strong>第一个</strong>后代元素，如果没有匹配项则返回 null。</p><p>在 Document 上使用 querySelector() 方法时，会从文档元素开始搜索；在 Element 上使用 querySelector() 方法时，则只会从当前元素的后代中查询。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;msg&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#myDiv&#x27;</span>)<span class="hljs-keyword">const</span> h2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h2&#x27;</span>)<span class="hljs-keyword">const</span> span = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.msg&#x27;</span>)<span class="hljs-comment">// 只能查询到第一个满足条件的元素</span><span class="hljs-keyword">const</span> h4 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h4.msg&#x27;</span>)<span class="hljs-comment">// 查询同时满足类名和标签的元素</span></code></pre></div><h3 id="2-2-querySelectorAll"><a href="#2-2-querySelectorAll" class="headerlink" title="2.2 querySelectorAll()"></a>2.2 querySelectorAll()</h3><p>querySelectorAll() 方法跟 querySelector()一样，也接收一个用于查询的参数，但它会返回<strong>所有</strong>匹配的节点，而不止一个。这个方法返回的是一个 NodeList 的<strong>静态实例</strong>。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> spans = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;span.msg&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(spans)</code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230117200215456.png" alt="image-20230117200215456" style="zoom:33%;" /><h3 id="2-3-matches"><a href="#2-3-matches" class="headerlink" title="2.3 matches()"></a>2.3 matches()</h3><p>matches()方法接收一个 CSS 选择符参数，如果元素匹配则该选择符返回 true，否则返回 false。</p><p>使用 matches() 可以方便地检测某个元素会不会被 querySelector() 或 querySelectorAll()方法返回。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-title function_">matches</span>(<span class="hljs-string">&#x27;div&#x27;</span>))<span class="hljs-comment">// true</span></code></pre></div><h2 id="3-HTML5-对-DOM-的扩展"><a href="#3-HTML5-对-DOM-的扩展" class="headerlink" title="3 HTML5 对 DOM 的扩展"></a>3 HTML5 对 DOM 的扩展</h2><h3 id="3-1-CSS-类扩展"><a href="#3-1-CSS-类扩展" class="headerlink" title="3.1 CSS 类扩展"></a>3.1 CSS 类扩展</h3><h4 id="3-1-1-getElementsByClassName"><a href="#3-1-1-getElementsByClassName" class="headerlink" title="3.1.1 getElementsByClassName()"></a>3.1.1 getElementsByClassName()</h4><p>getElementsByClassName() 方法暴露在 document 和所有元素上。</p><p>接受一个参数：一个或多个的类名。返回 HTMLCollection 实例。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;myClass&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;myClass&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;myClass&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;myClass&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;myClass&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(divs)</code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118191906084.png" alt="image-20230118191906084" style="zoom: 50%;" /><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-keyword">const</span> spans = div.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;mySpan&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(spans)</code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118191951035.png" alt="image-20230118191951035" style="zoom:50%;" /><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;myClass yourClass&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;myClass&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;myClass ourClass yourClass&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;myClass ourClass&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;myClass yourClass&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(divs)</code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118192241381.png" alt="image-20230118192241381" style="zoom:50%;" /><h4 id="3-1-2-classList-属性"><a href="#3-1-2-classList-属性" class="headerlink" title="3.1.2 classList 属性"></a>3.1.2 classList 属性</h4><p>使用元素的 classList 属性可以方便操作类名。classList 属性是一个 DOMTokenList 实例。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c1 c2 c3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-keyword">const</span> c = div.<span class="hljs-property">classList</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)</code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118193800113.png" alt="image-20230118193800113" style="zoom:50%;" /><p>DOMTokenList 的属性和方法如下：</p><ul><li><p>length，表示包含多少类名。</p></li><li><p>item(id)，或者 [id]，取第 id 个类名。</p></li><li><p>add(value)，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。</p></li><li><p>contains(value)，返回布尔值，表示给定的 value 是否存在。 </p></li><li><p>remove(value)，从类名列表中删除指定的字符串值 value。 </p></li><li><p>toggle(value)，如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。</p></li></ul><h3 id="3-2-自定义数据属性"><a href="#3-2-自定义数据属性" class="headerlink" title="3.2 自定义数据属性"></a>3.2 自定义数据属性</h3><p>HTML5 允许给元素指定非标准的属性，但要使用前缀 data-以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，data-后面跟什么都可以。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span> <span class="hljs-attr">data-appId</span>=<span class="hljs-string">&quot;12345&quot;</span> <span class="hljs-attr">data-myname</span>=<span class="hljs-string">&quot;Nicholas&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>定义了自定义数据属性后，可以通过元素的 dataset 属性来访问。dataset 属性是一个 DOMStringMap 的实例，包含一组键&#x2F;值对映射。元素的每个 data-name 属性在 dataset 中都可以通 过 data-后面的字符串作为键来访问（例如，属性 data-myname、data-myName 可以通过 myname 访 问，但要注意 data-my-name、data-My-Name 要通过 myName 来访问）。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span> <span class="hljs-attr">data-foo</span>=<span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-attr">data-bar</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-keyword">const</span> ds = div.<span class="hljs-property">dataset</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ds)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ds.<span class="hljs-property">foo</span>)<span class="hljs-comment">// foo</span>ds.<span class="hljs-property">bar</span> = <span class="hljs-string">&#x27;baz&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ds.<span class="hljs-property">bar</span>)<span class="hljs-comment">// baz</span></code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118195141364.png" alt="image-20230118195141364" style="zoom:50%;" /><h3 id="3-3-插入标记"><a href="#3-3-插入标记" class="headerlink" title="3.3 插入标记"></a>3.3 插入标记</h3><h4 id="3-3-1-innerHTML-属性"><a href="#3-3-1-innerHTML-属性" class="headerlink" title="3.3.1 innerHTML 属性"></a>3.3.1 innerHTML 属性</h4><p><strong>读取</strong> innerHTML 属性时，会返回元素所有后代的 HTML 字符串。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">innerHTML</span>)  <span class="hljs-comment">// hello world</span></code></pre></div><p><strong>写入</strong> innerHTML 时，则会根据提供的字符串值以新的 DOM 子树替代元素中原来后代的所有节点。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)div.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;span&gt;foo, bar&lt;/span&gt;&#x27;</span><span class="hljs-comment">// 页面上会显示新 DOM</span></code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118201427667.png" alt="image-20230118201427667" style="zoom: 50%;" /><h4 id="3-3-2-outerHTML-属性"><a href="#3-3-2-outerHTML-属性" class="headerlink" title="3.3.2 outerHTML 属性"></a>3.3.2 outerHTML 属性</h4><p>outerHTML与 innerHTML 是类似的，只不过作用范围包含调用它的节点。</p><p><strong>读取</strong> outerHTML 属性时，会返回调用它的元素（及所有后代元素）的 HTML 字符串。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">outerHTML</span>)</code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118202855326.png" alt="image-20230118202855326" style="zoom: 50%;" /><p><strong>写入</strong> outerHTML 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)div.<span class="hljs-property">outerHTML</span> = <span class="hljs-string">&#x27;&lt;span&gt;hello, world&lt;/span&gt;&#x27;</span></code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118203339486.png" alt="image-20230118203339486" style="zoom:50%;" /><h4 id="3-3-3-innerText-属性"><a href="#3-3-3-innerText-属性" class="headerlink" title="3.3.3 innerText 属性"></a>3.3.3 innerText 属性</h4><p><strong>读取</strong> innerText 会按照深度优先的顺序将子树中所有<strong>文本节点</strong>的值拼接起来。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">innerText</span>)<span class="hljs-comment">// 1 2 3 4</span></code></pre></div><p><strong>写入</strong> innerText 会移除元素的所有后代并插入一个包含该值的<strong>文本节点</strong>。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span> foo, bar <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)div.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;hello world&#x27;</span></code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118205700348.png" alt="image-20230118205700348" style="zoom:50%;" /><h4 id="3-3-4-outerText-属性"><a href="#3-3-4-outerText-属性" class="headerlink" title="3.3.4 outerText 属性"></a>3.3.4 outerText 属性</h4><p>outerText 与 innerText 是类似的，只不过作用范围包含调用它的节点。</p><p><strong>读取</strong>文本值时， outerText 与 innerText 实际上会返回同样的内容。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mySpan&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">outerText</span>)<span class="hljs-comment">// 1 2 3 4</span></code></pre></div><p><strong>写入</strong>文本值时，outerText 不止会移除所有后代节点，而是会替换整个元素。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span> foo, bar<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)div.<span class="hljs-property">outerText</span> = <span class="hljs-string">&#x27;hello world&#x27;</span></code></pre></div><img src="../images/【JavaScript】27_DOM/image-20230118210754504.png" alt="image-20230118210754504" style="zoom:50%;" />]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】26.客户端存储</title>
    <link href="/archives/64622cda.html"/>
    <url>/archives/64622cda.html</url>
    
    <content type="html"><![CDATA[<h1 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h1><h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1 cookie"></a>1 cookie</h2><p>&#x2F;&#x2F; TODO 封装 cookie 操作</p><h2 id="2-Web-Storage"><a href="#2-Web-Storage" class="headerlink" title="2 Web Storage"></a>2 Web Storage</h2><p>Web Storage 的第 2 版定义了两个<strong>对象</strong>：localStorage 和 sessionStorage。localStorage 是永久存储机制，sessionStorage 是跨会话的存储机制。这两种浏览器存储 API 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。</p><p>注：只能存储字符串，每个 domain 最多存储 5 MB 数据。</p><h3 id="2-1-localStorage"><a href="#2-1-localStorage" class="headerlink" title="2.1 localStorage"></a>2.1 localStorage</h3><p>localStorage 存储持久数据，即使浏览器关闭也不会消失，除非手动清除。</p><h4 id="2-2-1-setItem-存储数据"><a href="#2-2-1-setItem-存储数据" class="headerlink" title="2.2.1 setItem() 存储数据"></a>2.2.1 setItem() 存储数据</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-comment">// 设置</span></code></pre></div><img src="../images/【JavaScript】26_客户端存储/image-20230115111721024.png" alt="image-20230115111721024" style="zoom:33%;" /><h4 id="2-2-2-getItem-读取数据"><a href="#2-2-2-getItem-读取数据" class="headerlink" title="2.2.2 getItem() 读取数据"></a>2.2.2 getItem() 读取数据</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))<span class="hljs-comment">// 读取</span></code></pre></div><h4 id="2-2-3-removeItem-删除数据"><a href="#2-2-3-removeItem-删除数据" class="headerlink" title="2.2.3 removeItem() 删除数据"></a>2.2.3 removeItem() 删除数据</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// 删除</span></code></pre></div><h4 id="2-2-4-clear-清空数据"><a href="#2-2-4-clear-清空数据" class="headerlink" title="2.2.4 clear() 清空数据"></a>2.2.4 clear() 清空数据</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;qux&#x27;</span>)<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>()<span class="hljs-comment">// 清空</span></code></pre></div><h4 id="2-2-5-key-读取键名"><a href="#2-2-5-key-读取键名" class="headerlink" title="2.2.5 key() 读取键名"></a>2.2.5 key() 读取键名</h4><p>读取第n个键值对的键名：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;qux&#x27;</span>)<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>)<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;456&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">key</span>(<span class="hljs-number">2</span>))<span class="hljs-comment">// 顺序不可靠</span></code></pre></div><h3 id="2-2-sessionStorage"><a href="#2-2-sessionStorage" class="headerlink" title="2.2 sessionStorage"></a>2.2 sessionStorage</h3><p>sessionStorage 存储会话数据，浏览器关闭时数据消失。API 和 localStorage 完全相同</p><h4 id="2-2-1-setItem-存储数据-1"><a href="#2-2-1-setItem-存储数据-1" class="headerlink" title="2.2.1 setItem() 存储数据"></a>2.2.1 setItem() 存储数据</h4><div class="code-wrapper"><pre><code class="hljs javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-string">&#x27;bar&#x27;</span>)</code></pre></div><img src="../images/【JavaScript】26_客户端存储/image-20230115115234941.png" alt="image-20230115115234941" style="zoom:33%;" /><h4 id="2-2-2-getItem-读取数据-1"><a href="#2-2-2-getItem-读取数据-1" class="headerlink" title="2.2.2 getItem() 读取数据"></a>2.2.2 getItem() 读取数据</h4><div class="code-wrapper"><pre><code class="hljs javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))<span class="hljs-comment">// bar</span></code></pre></div><h4 id="2-2-3-removeItem-删除数据-1"><a href="#2-2-3-removeItem-删除数据-1" class="headerlink" title="2.2.3 removeItem() 删除数据"></a>2.2.3 removeItem() 删除数据</h4><div class="code-wrapper"><pre><code class="hljs javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-string">&#x27;bar&#x27;</span>)sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)</code></pre></div><h4 id="2-2-4-clear-清空数据-1"><a href="#2-2-4-clear-清空数据-1" class="headerlink" title="2.2.4 clear() 清空数据"></a>2.2.4 clear() 清空数据</h4><div class="code-wrapper"><pre><code class="hljs javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-string">&#x27;bar&#x27;</span>)sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;baz&#x27;</span>,<span class="hljs-string">&#x27;qux&#x27;</span>)sessionStorage.<span class="hljs-title function_">clear</span>()</code></pre></div><h4 id="2-2-5-key-读取键名-1"><a href="#2-2-5-key-读取键名-1" class="headerlink" title="2.2.5 key() 读取键名"></a>2.2.5 key() 读取键名</h4><div class="code-wrapper"><pre><code class="hljs javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;qux&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sessionStorage.<span class="hljs-title function_">key</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">// 顺序不可靠</span></code></pre></div><h3 id="2-3-storage-事件"><a href="#2-3-storage-事件" class="headerlink" title="2.3 storage 事件"></a>2.3 storage 事件</h3><p>当 localStorage 或者 sessionStorage 对象发生变化时，会触发 storage 事件。这个事件的 event 对象有如下 4 个属性：</p><ul><li>domain：存储变化对应的域。</li><li>key：被设置或删除的键。</li><li>newValue：键被设置的新值，若键被删除则为 null。</li><li>oldValue：键变化之前的值。</li></ul><p>举例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;storage&quot;</span>,<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Storage changed for $&#123;event.domain&#125;&#x27;</span>));</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【NLP】常用工具库</title>
    <link href="/archives/f9e0efab.html"/>
    <url>/archives/f9e0efab.html</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>总结 NER 代码中常用的工具库如下：</p><ol><li>argparse 参数解析 <a href="https://docs.python.org/3/library/argparse.html">https://docs.python.org/3/library/argparse.html</a></li><li>logging 日志记录 <a href="https://docs.python.org/3/library/logging.html">https://docs.python.org/3/library/logging.html</a></li><li>tqdm 显示进度条 <a href="https://tqdm.github.io/">https://tqdm.github.io/</a></li><li>seqeval 序列标注评估 <a href="https://github.com/chakki-works/seqeval">https://github.com/chakki-works/seqeval</a></li></ol><h2 id="1-argparse-参数解析"><a href="#1-argparse-参数解析" class="headerlink" title="1. argparse 参数解析"></a>1. argparse 参数解析</h2><blockquote><p>argparse 模块使编写用户友好的命令行界面变得容易。程序定义了它需要的参数，argparse 将确定如何从sys.argv 中解析这些参数。argparse 模块还自动生成帮助和用法消息。当用户给程序提供无效参数时，模块也会发出错误。</p></blockquote><h3 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h3><p>常用 argparse 模块来定义 batch_size 和 lr 等超参数。这样就可以在不改变代码的前提下，通过 shell 命令来指定不同的超参数。</p><h3 id="1-2-用法"><a href="#1-2-用法" class="headerlink" title="1.2 用法"></a>1.2 用法</h3><p>使用 argparse 的步骤：</p><ol><li>导包 —— <code>import argparse</code></li><li>创建解析器对象 —— <code>parser = argparse.ArgumentParser()</code></li><li>给解析器对象添加命令行参数 —— <code>parser.add_argument(&#39;--lr&#39;, type=float, default=1e-5)</code></li><li>解析命令行中的参数 —— <code>args = parser.parse_args()</code></li><li>调用参数 —— <code>lr = args.lr</code></li></ol><p>举例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">&#x27;--batch_size&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">32</span>)parser.add_argument(<span class="hljs-string">&#x27;--lr&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">float</span>, default=<span class="hljs-number">1e-5</span>)parser.add_argument(<span class="hljs-string">&#x27;--use_crf&#x27;</span>, action=<span class="hljs-string">&#x27;store_true&#x27;</span>)args = parser.parse_args()<span class="hljs-built_in">print</span>(args.batch_size)<span class="hljs-built_in">print</span>(args.lr)<span class="hljs-built_in">print</span>(args.use_crf)</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span>python demo1.py \    --batch_size 64 \    --lr 2e-5</code></pre></div><h2 id="2-logging-日志记录"><a href="#2-logging-日志记录" class="headerlink" title="2. logging 日志记录"></a>2. logging 日志记录</h2><blockquote><p>该模块定义了为应用程序和库实现灵活事件日志记录系统的函数和类。</p></blockquote><h3 id="2-1-使用场景"><a href="#2-1-使用场景" class="headerlink" title="2.1 使用场景"></a>2.1 使用场景</h3><p>需要将训练模型过程中的一些关键信息记录下来，同时输出到控制台和文件中。</p><h3 id="2-2-用法"><a href="#2-2-用法" class="headerlink" title="2.2 用法"></a>2.2 用法</h3><p>使用 logging 的步骤：</p><ol><li>导包 —— <code>import logging</code></li><li>创建日志对象，设置默认输出级别</li><li>为日志对象添加控制台处理器和文件处理器</li><li>打印日志</li></ol><p>举例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging logger = logging.getLogger(__name__)logger.setLevel(logging.INFO)logger.propagate = <span class="hljs-literal">False</span><span class="hljs-comment"># 日志输出格式</span>formatter = logging.Formatter(    fmt=<span class="hljs-string">&quot;%(asctime)s - %(levelname)s - %(name)s -   %(message)s&quot;</span>,     datefmt=<span class="hljs-string">&#x27;%Y/%m/%d %H:%M:%S&#x27;</span>)<span class="hljs-comment"># 添加控制台日志处理器</span>console_handler = logging.StreamHandler()console_handler.setLevel(logging.INFO)console_handler.setFormatter(formatter)logger.addHandler(console_handler)<span class="hljs-comment"># 添加文件日志处理器</span>file_handler = logging.FileHandler(<span class="hljs-string">&#x27;./demo.log&#x27;</span>, mode=<span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)file_handler.setLevel(logging.INFO)file_handler.setFormatter(formatter)logger.addHandler(file_handler)<span class="hljs-comment"># 打印不同级别的日志</span>logger.info(<span class="hljs-string">&#x27;epoch 0, loss: 0.1&#x27;</span>)</code></pre></div><h2 id="3-tqdm-显示进度条"><a href="#3-tqdm-显示进度条" class="headerlink" title="3. tqdm 显示进度条"></a>3. tqdm 显示进度条</h2><blockquote><p>立即让循环显示智能进度表-只需用 tqdm(iterable) 包装任何可迭代的，就完成了！</p></blockquote><h3 id="3-1-使用场景"><a href="#3-1-使用场景" class="headerlink" title="3.1 使用场景"></a>3.1 使用场景</h3><p>训练模型时，显示训练进度。</p><h3 id="3-2-用法"><a href="#3-2-用法" class="headerlink" title="3.2 用法"></a>3.2 用法</h3><ol><li>安装 tqdm 库，并导包</li><li>使用 <code>tqdm()</code> 包装迭代器</li></ol><p>举例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm, trange<span class="hljs-keyword">import</span> timeepoch = <span class="hljs-number">50</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(epoch)):    time.sleep(<span class="hljs-number">0.25</span>)<span class="hljs-comment"># trange(x) 是 tqdm(range(x)) 的简写</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> trange(epoch):    time.sleep(<span class="hljs-number">0.25</span>)</code></pre></div><h2 id="4-seqeval-序列标注评估"><a href="#4-seqeval-序列标注评估" class="headerlink" title="4. seqeval 序列标注评估"></a>4. seqeval 序列标注评估</h2><h3 id="4-1-使用场景"><a href="#4-1-使用场景" class="headerlink" title="4.1 使用场景"></a>4.1 使用场景</h3><p>评估模型的预测效果。</p><h3 id="4-2-用法"><a href="#4-2-用法" class="headerlink" title="4.2 用法"></a>4.2 用法</h3><ol><li>安装 seqeval 库，并导包</li><li>传入真实标签和预测标签</li></ol><p>举例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> seqeval.metrics <span class="hljs-keyword">import</span> accuracy_score, precision_score, recall_score, f1_score<span class="hljs-keyword">from</span> seqeval.metrics <span class="hljs-keyword">import</span> classification_reporty_true = [[<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;B-MISC&#x27;</span>, <span class="hljs-string">&#x27;I-MISC&#x27;</span>, <span class="hljs-string">&#x27;I-MISC&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>], [<span class="hljs-string">&#x27;B-PER&#x27;</span>, <span class="hljs-string">&#x27;I-PER&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>]]y_pred = [[<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;B-MISC&#x27;</span>, <span class="hljs-string">&#x27;I-MISC&#x27;</span>, <span class="hljs-string">&#x27;I-MISC&#x27;</span>, <span class="hljs-string">&#x27;I-MISC&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>], [<span class="hljs-string">&#x27;B-PER&#x27;</span>, <span class="hljs-string">&#x27;I-PER&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>]]<span class="hljs-built_in">print</span>(accuracy_score(y_true, y_pred))<span class="hljs-built_in">print</span>(precision_score(y_true, y_pred))<span class="hljs-built_in">print</span>(recall_score(y_true, y_pred))<span class="hljs-built_in">print</span>(f1_score(y_true, y_pred))<span class="hljs-built_in">print</span>(classification_report(y_true, y_pred))</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>NER</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript】Axios</title>
    <link href="/archives/6e2d7dc.html"/>
    <url>/archives/6e2d7dc.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Axios-简介"><a href="#1-Axios-简介" class="headerlink" title="1 Axios 简介"></a>1 Axios 简介</h1><h2 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h2><p>Axios 是一个基于 Promise 的网络请求库。一套代码可以同时运行在浏览器和 Node.js 中。浏览器中使用的是 XHR 对象，Node.js 中使用的是 http 模块。</p><p>支持拦截请求和响应、转换请求和响应数据、取消请求，并且可以自动转换 JSON 数据。</p><h2 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h2><p>NPM 安装：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install axios</code></pre></div><p>使用 CDN：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.2.2/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h1 id="2-Axios-发送请求"><a href="#2-Axios-发送请求" class="headerlink" title="2 Axios 发送请求"></a>2 Axios 发送请求</h1><h2 id="2-1-GET-请求"><a href="#2-1-GET-请求" class="headerlink" title="2.1 GET 请求"></a>2.1 GET 请求</h2><p>传给 axios() 一个配置对象，在配置对象中设置请求方法和 URL。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送一个 GET 请求</span><span class="hljs-title function_">axios</span>(&#123;    <span class="hljs-comment">// 传入请求配置对象（该对象所有属性见第3节）</span>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 成功时执行</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 失败时执行</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 无论成功还是失败都会执行</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally code&#x27;</span>)&#125;)</code></pre></div><h2 id="2-2-POST-请求"><a href="#2-2-POST-请求" class="headerlink" title="2.2 POST 请求"></a>2.2 POST 请求</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">axios</span>(&#123;    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>,    <span class="hljs-comment">// 请求体</span>    <span class="hljs-attr">data</span>: &#123;        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;title&#x27;</span>,        <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;author&#x27;</span>    &#125;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally code&#x27;</span>)&#125;)</code></pre></div><h2 id="2-3-其他请求方法"><a href="#2-3-其他请求方法" class="headerlink" title="2.3 其他请求方法"></a>2.3 其他请求方法</h2><p>Axios 支持 HTTP 中所有的请求方法。只需要在配置对象中正确设置 method 属性即可。</p><h2 id="2-4-请求方法别名"><a href="#2-4-请求方法别名" class="headerlink" title="2.4 请求方法别名"></a>2.4 请求方法别名</h2><p>为了方便起见，Axios 为所有支持的请求方法提供了别名。</p><p>发送 GET 请求可以：</p><div class="code-wrapper"><pre><code class="hljs javascript">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/1&#x27;</span>)</code></pre></div><p>发送 POST 请求可以：</p><div class="code-wrapper"><pre><code class="hljs javascript">axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;author&#x27;</span> &#125;)</code></pre></div><p>所有请求方法别名如下：</p><div class="code-wrapper"><pre><code class="hljs stylus">axios<span class="hljs-selector-class">.request</span>(config)axios<span class="hljs-selector-class">.get</span>(url<span class="hljs-selector-attr">[, config]</span>)axios<span class="hljs-selector-class">.delete</span>(url<span class="hljs-selector-attr">[, config]</span>)axios<span class="hljs-selector-class">.head</span>(url<span class="hljs-selector-attr">[, config]</span>)axios<span class="hljs-selector-class">.options</span>(url<span class="hljs-selector-attr">[, config]</span>)axios<span class="hljs-selector-class">.post</span>(url<span class="hljs-selector-attr">[, data[, config]</span>])axios<span class="hljs-selector-class">.put</span>(url<span class="hljs-selector-attr">[, data[, config]</span>])axios<span class="hljs-selector-class">.patch</span>(url<span class="hljs-selector-attr">[, data[, config]</span>])</code></pre></div><h1 id="3-Axios-请求配置"><a href="#3-Axios-请求配置" class="headerlink" title="3 Axios 请求配置"></a>3 Axios 请求配置</h1><p>创建请求时传入的配置对象，除 URL 外都是可选的：</p><div class="code-wrapper"><pre><code class="hljs javascript">&#123;  <span class="hljs-comment">// `url` 是用于请求的服务器 URL</span>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,  <span class="hljs-comment">// `method` 是创建请求时使用的方法</span>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-comment">// 默认值</span>  <span class="hljs-comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>  <span class="hljs-comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://some-domain.com/api/&#x27;</span>,  <span class="hljs-comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span>  <span class="hljs-comment">// 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span>  <span class="hljs-comment">// 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream</span>  <span class="hljs-comment">// 你可以修改请求头。</span>  <span class="hljs-attr">transformRequest</span>: [<span class="hljs-keyword">function</span> (<span class="hljs-params">data, headers</span>) &#123;    <span class="hljs-comment">// 对发送的 data 进行任意转换处理</span>    <span class="hljs-keyword">return</span> data;  &#125;],  <span class="hljs-comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>  <span class="hljs-attr">transformResponse</span>: [<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 对接收的 data 进行任意转换处理</span>    <span class="hljs-keyword">return</span> data;  &#125;],  <span class="hljs-comment">// 自定义请求头</span>  <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">&#x27;X-Requested-With&#x27;</span>: <span class="hljs-string">&#x27;XMLHttpRequest&#x27;</span>&#125;,  <span class="hljs-comment">// `params` 是与请求一起发送的 URL 参数</span>  <span class="hljs-comment">// 必须是一个简单对象或 URLSearchParams 对象</span>  <span class="hljs-attr">params</span>: &#123;    <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span>  &#125;,  <span class="hljs-comment">// `paramsSerializer`是可选方法，主要用于序列化`params`</span>  <span class="hljs-comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>  <span class="hljs-attr">paramsSerializer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Qs</span>.<span class="hljs-title function_">stringify</span>(params, &#123;<span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">&#x27;brackets&#x27;</span>&#125;)  &#125;,  <span class="hljs-comment">// `data` 是作为请求体被发送的数据</span>  <span class="hljs-comment">// 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法</span>  <span class="hljs-comment">// 在没有设置 `transformRequest` 时，则必须是以下类型之一:</span>  <span class="hljs-comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>  <span class="hljs-comment">// - 浏览器专属: FormData, File, Blob</span>  <span class="hljs-comment">// - Node 专属: Stream, Buffer</span>  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Fred&#x27;</span>  &#125;,    <span class="hljs-comment">// 发送请求体数据的可选语法</span>  <span class="hljs-comment">// 请求方式 post</span>  <span class="hljs-comment">// 只有 value 会被发送，key 则不会</span>  <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;</span>,  <span class="hljs-comment">// `timeout` 指定请求超时的毫秒数。</span>  <span class="hljs-comment">// 如果请求时间超过 `timeout` 的值，则请求会被中断</span>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>, <span class="hljs-comment">// 默认值是 `0` (永不超时)</span>  <span class="hljs-comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span>  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `adapter` 允许自定义处理请求，这使测试更加容易。</span>  <span class="hljs-comment">// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。</span>  <span class="hljs-attr">adapter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;    <span class="hljs-comment">/* ... */</span>  &#125;,  <span class="hljs-comment">// `auth` HTTP Basic Auth</span>  <span class="hljs-attr">auth</span>: &#123;    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;janedoe&#x27;</span>,    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;s00pers3cret&#x27;</span>  &#125;,  <span class="hljs-comment">// `responseType` 表示浏览器将要响应的数据类型</span>  <span class="hljs-comment">// 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span>  <span class="hljs-comment">// 浏览器专属：&#x27;blob&#x27;</span>  <span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-comment">// 默认值</span>  <span class="hljs-comment">// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)</span>  <span class="hljs-comment">// 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求</span>  <span class="hljs-comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span>  <span class="hljs-attr">responseEncoding</span>: <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-comment">// 默认值</span>  <span class="hljs-comment">// `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称</span>  <span class="hljs-attr">xsrfCookieName</span>: <span class="hljs-string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="hljs-comment">// 默认值</span>  <span class="hljs-comment">// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称</span>  <span class="hljs-attr">xsrfHeaderName</span>: <span class="hljs-string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="hljs-comment">// 默认值</span>  <span class="hljs-comment">// `onUploadProgress` 允许为上传处理进度事件</span>  <span class="hljs-comment">// 浏览器专属</span>  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) &#123;    <span class="hljs-comment">// 处理原生进度事件</span>  &#125;,  <span class="hljs-comment">// `onDownloadProgress` 允许为下载处理进度事件</span>  <span class="hljs-comment">// 浏览器专属</span>  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) &#123;    <span class="hljs-comment">// 处理原生进度事件</span>  &#125;,  <span class="hljs-comment">// `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数</span>  <span class="hljs-attr">maxContentLength</span>: <span class="hljs-number">2000</span>,  <span class="hljs-comment">// `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数</span>  <span class="hljs-attr">maxBodyLength</span>: <span class="hljs-number">2000</span>,  <span class="hljs-comment">// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。</span>  <span class="hljs-comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span>  <span class="hljs-comment">// 则promise 将会 resolved，否则是 rejected。</span>  <span class="hljs-attr">validateStatus</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) &#123;    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-comment">// 默认值</span>  &#125;,  <span class="hljs-comment">// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。</span>  <span class="hljs-comment">// 如果设置为0，则不会进行重定向</span>  <span class="hljs-attr">maxRedirects</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// 默认值</span>  <span class="hljs-comment">// `socketPath` 定义了在node.js中使用的UNIX套接字。</span>  <span class="hljs-comment">// e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。</span>  <span class="hljs-comment">// 只能指定 `socketPath` 或 `proxy` 。</span>  <span class="hljs-comment">// 若都指定，这使用 `socketPath` 。</span>  <span class="hljs-attr">socketPath</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span>  <span class="hljs-comment">// and https requests, respectively, in node.js. This allows options to be added like</span>  <span class="hljs-comment">// `keepAlive` that are not enabled by default.</span>  <span class="hljs-attr">httpAgent</span>: <span class="hljs-keyword">new</span> http.<span class="hljs-title class_">Agent</span>(&#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125;),  <span class="hljs-attr">httpsAgent</span>: <span class="hljs-keyword">new</span> https.<span class="hljs-title class_">Agent</span>(&#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125;),  <span class="hljs-comment">// `proxy` 定义了代理服务器的主机名，端口和协议。</span>  <span class="hljs-comment">// 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。</span>  <span class="hljs-comment">// 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。</span>  <span class="hljs-comment">// `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。</span>  <span class="hljs-comment">// 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。</span>  <span class="hljs-comment">// 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`</span>  <span class="hljs-attr">proxy</span>: &#123;    <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https&#x27;</span>,    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,    <span class="hljs-attr">auth</span>: &#123;      <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;mikeymike&#x27;</span>,      <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;rapunz3l&#x27;</span>    &#125;  &#125;,  <span class="hljs-comment">// see https://axios-http.com/zh/docs/cancellation</span>  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancelToken</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">cancel</span>) &#123;  &#125;),  <span class="hljs-comment">// `decompress` indicates whether or not the response body should be decompressed </span>  <span class="hljs-comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header </span>  <span class="hljs-comment">// from the responses objects of all decompressed responses</span>  <span class="hljs-comment">// - Node only (XHR cannot turn off decompression)</span>  <span class="hljs-attr">decompress</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 默认值</span>&#125;</code></pre></div><h1 id="4-Axios-响应内容"><a href="#4-Axios-响应内容" class="headerlink" title="4 Axios 响应内容"></a>4 Axios 响应内容</h1><p>一个请求的响应内容包括：</p><div class="code-wrapper"><pre><code class="hljs javascript">&#123;  <span class="hljs-comment">// `data` 由服务器提供的响应</span>  <span class="hljs-attr">data</span>: &#123;&#125;,  <span class="hljs-comment">// `status` 来自服务器响应的 HTTP 状态码</span>  <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,  <span class="hljs-comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span>  <span class="hljs-attr">statusText</span>: <span class="hljs-string">&#x27;OK&#x27;</span>,  <span class="hljs-comment">// `headers` 是服务器响应头</span>  <span class="hljs-comment">// 所有的 header 名称都是小写，而且可以使用方括号语法访问</span>  <span class="hljs-comment">// 例如: `response.headers[&#x27;content-type&#x27;]`</span>  <span class="hljs-attr">headers</span>: &#123;&#125;,  <span class="hljs-comment">// `config` 是 `axios` 请求的配置信息</span>  <span class="hljs-attr">config</span>: &#123;&#125;,  <span class="hljs-comment">// `request` 是生成此响应的请求</span>  <span class="hljs-comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span>  <span class="hljs-comment">// 在浏览器中则是 XMLHttpRequest 实例</span>  <span class="hljs-attr">request</span>: &#123;&#125;&#125;</code></pre></div><p>例如：</p><div class="code-wrapper"><pre><code class="hljs javascript">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)&#125;)</code></pre></div><img src="../images/【JavaScript】Axios/image-20230112212204660.png" alt="image-20230112212204660" style="zoom: 50%;" /><h1 id="5-Axios-创建实例"><a href="#5-Axios-创建实例" class="headerlink" title="5 Axios 创建实例"></a>5 Axios 创建实例</h1><p>可以使用 axios.create() 方法并传入一个<strong>实例配置</strong>（同样是配置对象，但优先级不同于前述的<strong>请求配置</strong>）来创建一个实例。使用实例身上的方法来发送请求。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建实例</span><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;    <span class="hljs-comment">// 实例配置</span>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>,    <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>: <span class="hljs-string">&#x27;foobar&#x27;</span> &#125;&#125;);<span class="hljs-comment">// 使用实例的方法发送请求</span>instance.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/1&#x27;</span>)</code></pre></div><p>这个实例配置也可以进行添加和修改：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;    <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>,    <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>: <span class="hljs-string">&#x27;foobar&#x27;</span> &#125;&#125;);<span class="hljs-comment">// 添加实例配置</span>instance.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;Y-Custom-Header&#x27;</span>] = <span class="hljs-string">&#x27;bazqux&#x27;</span><span class="hljs-comment">// 使用实例的方法发送请求</span>instance.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">config</span>.<span class="hljs-property">headers</span>)    <span class="hljs-comment">// X-Custom-Header : &#x27;foobar&#x27;</span>    <span class="hljs-comment">// Y-Custom-Header : &#x27;bazqux&#x27;</span>&#125;)</code></pre></div><p>实例身上所有的方法如下，给实例方法传入的请求配置会和实例配置合并（实例配置优先级更高）：</p><div class="code-wrapper"><pre><code class="hljs leaf">axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-variable">config</span>)</span></span>axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-variable">url</span>[, <span class="hljs-variable">config</span>])</span></span>axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-variable">url</span>[, <span class="hljs-variable">config</span>])</span></span>axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-variable">url</span>[, <span class="hljs-variable">config</span>])</span></span>axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">options</span><span class="hljs-params">(<span class="hljs-variable">url</span>[, <span class="hljs-variable">config</span>])</span></span>axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-variable">url</span>[, <span class="hljs-variable">data</span>[, <span class="hljs-variable">config</span>]])</span></span>axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-variable">url</span>[, <span class="hljs-variable">data</span>[, <span class="hljs-variable">config</span>]])</span></span>axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">patch</span><span class="hljs-params">(<span class="hljs-variable">url</span>[, <span class="hljs-variable">data</span>[, <span class="hljs-variable">config</span>]])</span></span>axios<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getUri</span><span class="hljs-params">([<span class="hljs-variable">config</span>])</span></span></code></pre></div><h1 id="6-Axios-默认配置"><a href="#6-Axios-默认配置" class="headerlink" title="6 Axios 默认配置"></a>6 Axios 默认配置</h1><p>Axios 共有 3 个不同优先级的配置。分别是<strong>全局配置</strong>、<strong>自定义实例配置</strong>和传入每个方法的<strong>请求配置</strong>（config 参数）。其中，前两个配置可以设置<strong>默认值</strong>。</p><h2 id="6-1-全局默认配置"><a href="#6-1-全局默认配置" class="headerlink" title="6.1 全局默认配置"></a>6.1 全局默认配置</h2><p>Axios 的全局默认配置位于 <a href="https://github.com/axios/axios/blob/master/lib/defaults.js#L28">lib&#x2F;defaults.js</a>，可修改 axios.defaults 属性对全局默认配置进行修改。全局的 Axios 配置将作用于每个请求：</p><div class="code-wrapper"><pre><code class="hljs javascript">axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>;axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>.<span class="hljs-property">common</span>[<span class="hljs-string">&#x27;Authorization&#x27;</span>] = <span class="hljs-variable constant_">AUTH_TOKEN</span>;axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>.<span class="hljs-property">post</span>[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] = <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>;</code></pre></div><h2 id="6-2-自定义实例默认配置"><a href="#6-2-自定义实例默认配置" class="headerlink" title="6.2 自定义实例默认配置"></a>6.2 自定义实例默认配置</h2><p>Axios 的自定义实例默认配置在创建实例时进行设置，可修改实例的 instance 属性对其默认属性进行修改。自定义实例默认配置将作用于该实例的每个请求：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建实例时配置默认值</span><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>&#125;);<span class="hljs-comment">// 创建实例后修改默认值</span>instance.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>.<span class="hljs-property">common</span>[<span class="hljs-string">&#x27;Authorization&#x27;</span>] = <span class="hljs-string">&#x27;AUTH_TOKEN&#x27;</span></code></pre></div><h2 id="6-3-配置优先级"><a href="#6-3-配置优先级" class="headerlink" title="6.3 配置优先级"></a>6.3 配置优先级</h2><p>优先级最高：请求配置（config 参数）；其次：自定义实例配置；最低：全局配置。</p><h1 id="7-Axios-拦截器"><a href="#7-Axios-拦截器" class="headerlink" title="7 Axios 拦截器"></a>7 Axios 拦截器</h1><p>可以给全局 axios 或者自定义实例添加请求或响应拦截器，以便在 then() 和 catch() 之前处理请求或响应。</p><h2 id="7-1-添加拦截器"><a href="#7-1-添加拦截器" class="headerlink" title="7.1 添加拦截器"></a>7.1 添加拦截器</h2><p>请求拦截器可以对请求配置（config）进行处理，响应拦截器可以对响应内容（response）进行处理。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加请求拦截器</span>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;    <span class="hljs-comment">// 在发送请求之前做些什么</span>    <span class="hljs-keyword">return</span> config;  &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;    <span class="hljs-comment">// 对请求错误做些什么</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);  &#125;);<span class="hljs-comment">// 添加响应拦截器</span>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;    <span class="hljs-comment">// 2xx 范围内的状态码都会触发该函数。</span>    <span class="hljs-comment">// 对响应数据做点什么</span>    <span class="hljs-keyword">return</span> response;  &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;    <span class="hljs-comment">// 超出 2xx 范围的状态码都会触发该函数。</span>    <span class="hljs-comment">// 对响应错误做点什么</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);  &#125;);</code></pre></div><h2 id="7-2-移除拦截器"><a href="#7-2-移除拦截器" class="headerlink" title="7.2 移除拦截器"></a>7.2 移除拦截器</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myInterceptor = axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">/*...*/</span>&#125;);axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">eject</span>(myInterceptor);</code></pre></div><h2 id="7-3-多个拦截器的执行顺序"><a href="#7-3-多个拦截器的执行顺序" class="headerlink" title="7.3 多个拦截器的执行顺序"></a>7.3 多个拦截器的执行顺序</h2><p>多个请求拦截器时，拦截顺序和定义请求拦截器时的顺序相反。</p><p>多个响应拦截器时，拦截顺序和定义响应拦截器时的顺序相同。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义2个请求拦截器和2个响应拦截器</span>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求拦截器1&#x27;</span>)    <span class="hljs-keyword">return</span> config;&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);&#125;);axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求拦截器2&#x27;</span>)    <span class="hljs-keyword">return</span> config;&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;    <span class="hljs-comment">// 对请求错误做些什么</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);&#125;);axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;响应拦截器1&#x27;</span>)    <span class="hljs-keyword">return</span> response;&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);&#125;);axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;响应拦截器2&#x27;</span>)    <span class="hljs-keyword">return</span> response;&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);&#125;);axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/1&#x27;</span>)<span class="hljs-comment">// 请求拦截器2</span><span class="hljs-comment">// 请求拦截器1</span><span class="hljs-comment">// 响应拦截器1</span><span class="hljs-comment">// 响应拦截器2</span></code></pre></div><h1 id="8-Axios-取消请求"><a href="#8-Axios-取消请求" class="headerlink" title="8 Axios 取消请求"></a>8 Axios 取消请求</h1><h2 id="8-1-AbortController-方式（0-22-0-开始支持）"><a href="#8-1-AbortController-方式（0-22-0-开始支持）" class="headerlink" title="8.1 AbortController 方式（0.22.0 开始支持）"></a>8.1 AbortController 方式（0.22.0 开始支持）</h2><p>从 <code>v0.22.0</code> 开始，Axios 支持以 fetch API 方式—— <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code></a> 取消请求：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/1&#x27;</span>, &#123;    <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>)&#125;);<span class="hljs-comment">// 取消请求</span>controller.<span class="hljs-title function_">abort</span>()</code></pre></div><h2 id="8-2-CancelToken-方式（0-22-0-开始弃用）"><a href="#8-2-CancelToken-方式（0-22-0-开始弃用）" class="headerlink" title="8.2 CancelToken 方式（0.22.0 开始弃用）"></a>8.2 CancelToken 方式（0.22.0 开始弃用）</h2><p>可以使用 <code>CancelToken.source</code> 工厂方法创建一个 cancel token：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CancelToken</span> = axios.<span class="hljs-property">CancelToken</span>;<span class="hljs-keyword">const</span> source = <span class="hljs-title class_">CancelToken</span>.<span class="hljs-title function_">source</span>();axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;  <span class="hljs-attr">cancelToken</span>: source.<span class="hljs-property">token</span>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">thrown</span>) &#123;  <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_">isCancel</span>(thrown)) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request canceled&#x27;</span>, thrown.<span class="hljs-property">message</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 处理错误</span>  &#125;&#125;);axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;new name&#x27;</span>&#125;, &#123;  <span class="hljs-attr">cancelToken</span>: source.<span class="hljs-property">token</span>&#125;)<span class="hljs-comment">// 取消请求（message 参数是可选的）</span>source.<span class="hljs-title function_">cancel</span>(<span class="hljs-string">&#x27;Operation canceled by the user.&#x27;</span>);</code></pre></div><p>也可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建一个 cancel token：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CancelToken</span> = axios.<span class="hljs-property">CancelToken</span>;<span class="hljs-keyword">let</span> cancel;axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancelToken</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">executor</span>(<span class="hljs-params">c</span>) &#123;    <span class="hljs-comment">// executor 函数接收一个 cancel 函数作为参数</span>    cancel = c;  &#125;)&#125;);<span class="hljs-comment">// 取消请求</span><span class="hljs-title function_">cancel</span>();</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】25.期约和异步函数</title>
    <link href="/archives/15bd4d53.html"/>
    <url>/archives/15bd4d53.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-期约的状态"><a href="#1-期约的状态" class="headerlink" title="1 期约的状态"></a>1 期约的状态</h2><h3 id="1-1-期约的三种状态"><a href="#1-1-期约的三种状态" class="headerlink" title="1.1 期约的三种状态"></a>1.1 期约的三种状态</h3><p>通过实例化 Promise 来定义一个<strong>期约对象</strong>，实例化期约时必须传入一个<strong>执行器函数</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p)<span class="hljs-comment">// Promise &#123; &lt;pending&gt; &#125;</span></code></pre></div><blockquote><p>解释：<code>setTimeout(console.log, 0, p)</code> 可以打印出期约的状态 。</p></blockquote><p>期约可能处于以下3种状态：</p><ul><li>待定，pending</li><li>兑现，fulfilled 也叫 resolved</li><li>拒绝，rejected</li></ul><p>最初，期约处于 pending 状态。处于 pending 状态的期约可以落定为 resolved 状态或者 rejected 状态。期约状态落定后不可更改。期约的状态是私有的，无法通过 JavaScript 代码检测到，也不能通过期约外部的 JavaScript 代码来修改期约的状态。</p><h3 id="1-2-期约的解决值或拒绝理由"><a href="#1-2-期约的解决值或拒绝理由" class="headerlink" title="1.2 期约的解决值或拒绝理由"></a>1.2 期约的解决值或拒绝理由</h3><p>期约的状态代表期约是否完成，pending 代表尚未开始或者未完成，resolved 代表<strong>已成功完成</strong>，rejected 代表<strong>未成功完成</strong>。比如，期约向服务器发送请求。如果响应的状态码是200，那么期约就把状态改为 resolved；如果响应的状态码是404，那么期约就把状态改为 rejected。</p><p>期约成功完成时可能需要返回一个<strong>解决值</strong>（value），未成功完成时可能需要返回一个<strong>拒绝理由</strong>（reason）。这两个值是可选的，并且默认值是 undefined。比如在前面的例子中，期约收到的200状态码的响应时，需要返回响应体；收到404状态码的响应时，需要返回错误信息。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p)<span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125; 解决值</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)&#125;)<span class="hljs-comment">// 报错：Uncaught (in promise) bar</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p)<span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: &#x27;bar&#x27;&#125; 拒绝理由</span></code></pre></div><h3 id="1-3-控制期约的状态"><a href="#1-3-控制期约的状态" class="headerlink" title="1.3 控制期约的状态"></a>1.3 控制期约的状态</h3><p>通过调用执行器函数的两个参数可以控制期约的状态，这两个函数一般会被命名为 resolve() 和 reject()。调用resolve() 可以把期约状态从 pending 改为 resolved，调用 reject() 可以把期约状态从 pending 改为 rejected。调用 reject() 也会抛出错误，<strong>这个错误不能被 try-catch 捕获，只能由拒绝处理程序捕获</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;    <span class="hljs-title function_">resolve</span>()&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p)<span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;    <span class="hljs-title function_">reject</span>()&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p)<span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: undefined&#125;</span><span class="hljs-comment">// 报错：Uncaught (in promise) undefined</span></code></pre></div><p>当 resolve() 或者 reject() 被调用之后，期约的状态就不能再变了。再调用 resolved() 或者 reject() 会静默失败。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;    <span class="hljs-title function_">reject</span>()    <span class="hljs-title function_">resolve</span>()<span class="hljs-comment">// 没有效果</span>&#125;)</code></pre></div><p>期约的状态不是只能从 pending 开始，可以直接创建 resolved 状态或者 rejected 状态的期约。</p><h3 id="1-4-Promise-resolve-创建已解决的期约"><a href="#1-4-Promise-resolve-创建已解决的期约" class="headerlink" title="1.4 Promise.resolve() 创建已解决的期约"></a>1.4 Promise.resolve() 创建已解决的期约</h3><p>通过 Promise.resolve() 可以实例化一个已解决的期约，解决值就是传入的第一个参数：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p)<span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span></code></pre></div><p>Promise.resolve() 是一个<strong>幂等方法</strong>，如果传入的参数是一个期约，那么它的行为类似一个空包装：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p1)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2)<span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 === p2)<span class="hljs-comment">// true</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p1)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2)<span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: &#x27;bar&#x27;&#125; 报错：Uncaught (in promise) bar</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1 === p2)<span class="hljs-comment">// true</span></code></pre></div><h3 id="1-5-Promise-reject-创建被拒绝的期约"><a href="#1-5-Promise-reject-创建被拒绝的期约" class="headerlink" title="1.5 Promise.reject() 创建被拒绝的期约"></a>1.5 Promise.reject() 创建被拒绝的期约</h3><p>通过 Promise.reject() 可以创建一个被拒绝的期约（会抛出一个<strong>异步异常</strong>），拒绝原因就是传入的第一个参数。这个参数也会传给后续的处理程序：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e))<span class="hljs-comment">// foo</span></code></pre></div><p>Promise.reject() <strong>不是幂等的</strong>，如果传给它一个期约对象，这个期约对象会成为它的拒绝原因。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(p1)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2)<span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: Promise&#125;</span><span class="hljs-comment">//报错：Uncaught (in promise) Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span></code></pre></div><h2 id="2-期约的实例方法"><a href="#2-期约的实例方法" class="headerlink" title="2 期约的实例方法"></a>2 期约的实例方法</h2><p>期约实例的方法是连接外部<strong>同步</strong>代码与内部<strong>异步</strong>代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p><h3 id="2-1-then"><a href="#2-1-then" class="headerlink" title="2.1 then()"></a>2.1 then()</h3><p>then() 是为期约添加处理程序的主要方法。then() 方法主要接受两个函数参数：onResolved() 处理程序和 onRejected() 处理程序。这两个参数都是可选的，如果提供的话， 则会在期约分别进入 resolved 或 rejected 状态时执行。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onResolved</span>(<span class="hljs-params">value</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">onRejected</span>(<span class="hljs-params">reason</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)&#125;)p.<span class="hljs-title function_">then</span>(onResolved, onRejected)<span class="hljs-comment">// foo</span></code></pre></div><p>then() 返回一个<strong>新</strong>的期约实例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>()<span class="hljs-comment">// 新期约</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1)          <span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2)          <span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1 === p2)   <span class="hljs-comment">// false</span></code></pre></div><p><strong>这个新期约（p2）实例基于 onResovled() 和 onRejected() 处理程序的返回值构建</strong>。如果上一个期约（p1）是 resolve 状态，则通过 onResovled() 返回值来构建 then()返回的期约（p2）；如果上一个期约是 rejected 状态，则通过 onRejected() 返回值来构建 then() 返回的期约（p2）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-string">&#x27;!&#x27;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> e + <span class="hljs-string">&#x27;@&#x27;</span> &#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;p1&#x27;</span>, p1)<span class="hljs-comment">// p1 Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;p2&#x27;</span>, p2)<span class="hljs-comment">// p2 Promise &#123;&lt;fulfilled&gt;: &#x27;bar!&#x27;&#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-string">&#x27;!&#x27;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> e + <span class="hljs-string">&#x27;@&#x27;</span> &#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;p1&#x27;</span>, p1)<span class="hljs-comment">// p1 Promise &#123;&lt;rejected&gt;: &#x27;bar&#x27;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;p2&#x27;</span>, p2)<span class="hljs-comment">// p2 Promise &#123;&lt;fulfilled&gt;: &#x27;bar@&#x27;&#125;</span></code></pre></div><h4 id="2-1-1-当期约落定为-resolved-状态时"><a href="#2-1-1-当期约落定为-resolved-状态时" class="headerlink" title="2.1.1 当期约落定为 resolved 状态时"></a>2.1.1 当期约落定为 resolved 状态时</h4><p>如果期约（p1）落定为 resolved 状态，那么它的 then() 方法总是返回一个<strong>新</strong>的期约值，该值有3种情况：</p><ol><li>如果提供了 onResovled() 处理程序，then() 方法返回的期约值是 Promise.resolve() 包装上 onResovled() 处理程序的返回值。</li><li>如果没有提供 onResovled() 处理程序，then() 方法返回的期约值是 Promise.resolve() 包装上一个期约（p1）解决之后的值。</li><li>如果提供了 onResovled() 处理程序，但是没有显式的返回语句，then() 方法返回的期约值是 Promise.resolve()包装默认的返回值 undefined。</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// 不传处理程序时，状态向后传递。p2值就是 Promise.resolve() 包装上p1</span><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>()<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2)  <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1 === p2)<span class="hljs-comment">// false</span><span class="hljs-comment">// 没有显式返回值，则返回undefined包装值</span><span class="hljs-keyword">const</span> p3 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">undefined</span>)<span class="hljs-keyword">const</span> p4 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123; &#125;) <span class="hljs-keyword">const</span> p5 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>())<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p3) <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p4) <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p5) <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><span class="hljs-comment">// 如果有显式返回值，Promise.resolve() 会包装这个值</span><span class="hljs-keyword">const</span> p6 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-keyword">const</span> p7 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;bar&#x27;</span>))<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p6)  <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p7)  <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span><span class="hljs-comment">// Promise.resolve() 会保留返回的期约</span><span class="hljs-keyword">const</span> p8 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123; &#125;))<span class="hljs-keyword">const</span> p9 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>()) <span class="hljs-comment">// 报错</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p8)  <span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p9)  <span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: undefined&#125; </span><span class="hljs-comment">// 抛出异常会返回拒绝的期约</span><span class="hljs-keyword">const</span> p10 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span> &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)&#125;) <span class="hljs-comment">// 报错</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p10) <span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: Error: bar&#125; </span></code></pre></div><h4 id="2-1-2-当期约落定为-rejected-状态时"><a href="#2-1-2-当期约落定为-rejected-状态时" class="headerlink" title="2.1.2 当期约落定为 rejected 状态时"></a>2.1.2 当期约落定为 rejected 状态时</h4><p>如果期约（p1）落定为 rejected 状态，那么它的 then() 方法总是返回一个<strong>新</strong>的期约值。和期约落定为 resolved 状态一样，该值有3种情况：</p><ol><li>如果提供了 onRejected() 处理程序，then() 方法返回的期约值是 Promise.resolve() 包装上 onRejected() 处理程序的返回值。</li><li>如果没有提供 onRejected() 处理程序，then() 方法返回的期约值是 Promise.resolve() 包装上一个期约（p1）解决之后的值。</li><li>如果提供了 onRejected() 处理程序，但是没有显式的返回语句，then() 方法返回的期约值是 Promise.resolve()包装默认的返回值 undefined。</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// 不传处理程序时，状态向后传递。p2值就是 Promise.resolve() 包装上p1</span><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>()<span class="hljs-comment">// 报错</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2)  <span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: &#x27;foo&#x27;&#125; </span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1 === p2)   <span class="hljs-comment">// false</span> <span class="hljs-comment">// 没有显式返回值，则返回undefined包装值</span><span class="hljs-keyword">const</span> p3 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">undefined</span>)<span class="hljs-keyword">const</span> p4 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">() =&gt;</span> &#123; &#125;)<span class="hljs-keyword">const</span> p5 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>())<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p3) <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p4) <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p5) <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><span class="hljs-comment">// 如果有显式返回值，Promise.resolve() 会包装这个值</span><span class="hljs-keyword">const</span> p6 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-keyword">const</span> p7 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;bar&#x27;</span>))<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p6)  <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p7)  <span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span><span class="hljs-comment">// Promise.resolve() 会保留返回的期约</span><span class="hljs-keyword">const</span> p8 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123; &#125;))<span class="hljs-keyword">const</span> p9 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>())<span class="hljs-comment">// 报错</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p8)  <span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p9)  <span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: undefined&#125; </span><span class="hljs-comment">// 抛出异常会返回拒绝的期约</span><span class="hljs-keyword">const</span> p10 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;bar&#x27;</span>) &#125;)<span class="hljs-comment">// 报错</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p10) <span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: &#x27;foo&#x27;&#125; </span></code></pre></div><h3 id="2-2-catch"><a href="#2-2-catch" class="headerlink" title="2.2  catch()"></a>2.2  catch()</h3><p>catch() 方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected() 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 <code>then(null, onRejected)</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> reason &#125;)p3 = p1.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> reason &#125;)<span class="hljs-comment">// 语法糖</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2)<span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p3)<span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2 === p3) <span class="hljs-comment">// false</span></code></pre></div><h3 id="2-3-finally"><a href="#2-3-finally" class="headerlink" title="2.3 finally()"></a>2.3 finally()</h3><p>finally()方法用于给期约添加 onFinally() 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码。但 onFinally() 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();<span class="hljs-keyword">let</span> onFinally = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Finally!&#x27;</span>)&#125;p1.<span class="hljs-title function_">finally</span>(onFinally); <span class="hljs-comment">// Finally</span>p2.<span class="hljs-title function_">finally</span>(onFinally); <span class="hljs-comment">// Finally</span></code></pre></div><p>finally()方法返回一个<strong>新</strong>的期约实例，这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态无关的方法，所以在大多数情况下它将表现为<strong>父期约的传递</strong>。对于已解决状态和被拒绝状态都是如此。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-comment">// 这里都会原样后传</span><span class="hljs-keyword">let</span> p2 = p1.<span class="hljs-title function_">finally</span>();<span class="hljs-keyword">let</span> p3 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">undefined</span>);<span class="hljs-keyword">let</span> p4 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;);<span class="hljs-keyword">let</span> p5 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>());<span class="hljs-keyword">let</span> p6 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;bar&#x27;</span>);<span class="hljs-keyword">let</span> p7 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;bar&#x27;</span>));<span class="hljs-keyword">let</span> p8 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;qux&#x27;</span>));<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2); <span class="hljs-comment">// Promise &lt;resolved&gt;: foo</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p3); <span class="hljs-comment">// Promise &lt;resolved&gt;: foo</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p4); <span class="hljs-comment">// Promise &lt;resolved&gt;: foo</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p5); <span class="hljs-comment">// Promise &lt;resolved&gt;: foo</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p6); <span class="hljs-comment">// Promise &lt;resolved&gt;: foo</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p7); <span class="hljs-comment">// Promise &lt;resolved&gt;: foo</span></code></pre></div><p>如果返回的是一个待定的期约，或者 onFinally() 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Promise.resolve()保留返回的期约</span><span class="hljs-keyword">let</span> p9 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;));<span class="hljs-keyword">let</span> p10 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>());<span class="hljs-comment">// Uncaught (in promise): undefined</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p9); <span class="hljs-comment">// Promise &lt;pending&gt;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p10); <span class="hljs-comment">// Promise &lt;rejected&gt;: undefined</span><span class="hljs-keyword">let</span> p11 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;baz&#x27;</span>; &#125;); <span class="hljs-comment">// Uncaught (in promise) baz</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p11); <span class="hljs-comment">// Promise &lt;rejected&gt;: baz</span></code></pre></div><p>返回待定期约的情形并不常见，这是因为只要期约一解决，新期约仍然会原样后传初始的期约：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-comment">// 忽略解决的值</span><span class="hljs-keyword">let</span> p2 = p1.<span class="hljs-title function_">finally</span>( <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(     <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;bar&#x27;</span>), <span class="hljs-number">100</span>) ));<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2); <span class="hljs-comment">// Promise &lt;pending&gt;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2), <span class="hljs-number">200</span>);<span class="hljs-comment">// 200 毫秒后：</span><span class="hljs-comment">// Promise &lt;resolved&gt;: foo </span></code></pre></div><h2 id="3-期约实例方法的特性"><a href="#3-期约实例方法的特性" class="headerlink" title="3 期约实例方法的特性"></a>3 期约实例方法的特性</h2><h3 id="3-1-非重入特性"><a href="#3-1-非重入特性" class="headerlink" title="3.1 非重入特性"></a>3.1 非重入特性</h3><p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被<strong>排期</strong>，而非立即执行。跟在添加这个处理程序的代码之后的<strong>同步代码</strong>一定会在处理程序之<strong>前</strong>先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy） 特性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>) &#125;)p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value))<span class="hljs-comment">// 2. 再执行这条语句</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-comment">// 1. 先执行这条语句</span><span class="hljs-comment">// 先输出 bar，再输出 foo</span></code></pre></div><p>在这个例子中，在一个解决期约上调用 then() 会把 onResolved 处理程序推进消息队列。但这个处理程序在当前线程上的同步代码执行完成前不会执行。因此，跟在 then()后面的同步代码一定先于处理程序执行。 </p><p>先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> synchronousResolve;<span class="hljs-comment">// 创建一个期约并将解决函数保存在一个局部变量中</span><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;    synchronousResolve = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1: invoking resolve()&#x27;</span>);<span class="hljs-comment">// 1</span>        <span class="hljs-title function_">resolve</span>();        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2: resolve() returns&#x27;</span>);<span class="hljs-comment">// 2</span>    &#125;;&#125;);p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4: then() handler executes&#x27;</span>));<span class="hljs-comment">// 4</span><span class="hljs-title function_">synchronousResolve</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3: synchronousResolve() returns&#x27;</span>);<span class="hljs-comment">// 3</span></code></pre></div><p><strong>注</strong>：非重入特性适用于onResolved&#x2F;onRejected 处理程序、then()处理程序、catch() 处理程序和 finally() 处理程序。</p><h3 id="3-2-临近处理程序的执行顺序"><a href="#3-2-临近处理程序的执行顺序" class="headerlink" title="3.2 临近处理程序的执行顺序"></a>3.2 临近处理程序的执行顺序</h3><p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照<strong>添加它们的顺序</strong>依次执行。无论是  then()、catch()还是 finally()添加的处理程序都是如此。</p><h3 id="3-3-传递解决值或拒绝理由"><a href="#3-3-传递解决值或拒绝理由" class="headerlink" title="3.3 传递解决值或拒绝理由"></a>3.3 传递解决值或拒绝理由</h3><p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。</p><p>在执行函数中，解决的值和拒绝的理由是分别作为 resolve() 和 reject() 的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为 onResolved() 或 onRejected() 处理程序的唯一参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)); <span class="hljs-comment">// foo</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;bar&#x27;</span>));p2.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)); <span class="hljs-comment">// bar </span></code></pre></div><p>Promise.resolve()和 Promise.reject()在被调用时就会接收解决值和拒绝理由。同样地，它们返回的期约也会像执行器一样把这些值传给 onResolved() 或 onRejected() 处理程序。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)); <span class="hljs-comment">// foo</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);p2.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)); <span class="hljs-comment">// bar </span></code></pre></div><h3 id="3-4-拒绝期约和拒绝错误处理"><a href="#3-4-拒绝期约和拒绝错误处理" class="headerlink" title="3.4 拒绝期约和拒绝错误处理"></a>3.4 拒绝期约和拒绝错误处理</h3><p>拒绝期约类似于 throw() 表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。<strong>在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。</strong>因此以下这些期约都会以一个错误对象为由被拒绝：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)));<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); &#125;);<span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); &#125;);<span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1); <span class="hljs-comment">// Promise &lt;rejected&gt;: Error: foo</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2); <span class="hljs-comment">// Promise &lt;rejected&gt;: Error: foo</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p3); <span class="hljs-comment">// Promise &lt;rejected&gt;: Error: foo</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p4); <span class="hljs-comment">// Promise &lt;rejected&gt;: Error: foo</span><span class="hljs-comment">// 也会抛出4个未捕获的错误</span></code></pre></div><p>期约可以以任何理由拒绝，包括 undefined，但最好统一使用 Error 错误对象。这样做主要是因为创建 Error 错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。</p><img src="../images/【JavaScript】25_期约和异步函数/image-20230104131910260.png" alt="image-20230104131910260" style="zoom:33%;" /><p>所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序：Promise.resolve().then() 的错误最后才出现，这是因为它需要在运行时消息队列中添加处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。 </p><p>这个例子同样揭示了异步错误有意思的副作用。正常情况下，在通过 throw() 关键字抛出错误时， JavaScript 运行时的错误处理机制会停止执行抛出错误之后的任何指令：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>); <span class="hljs-comment">// 这一行不会执行</span><span class="hljs-comment">// Uncaught Error: foo</span></code></pre></div><p>但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<span class="hljs-comment">// 这一行会执行</span><span class="hljs-comment">// bar</span><span class="hljs-comment">// Uncaught (in promise) Error: foo</span></code></pre></div><p>如本章前面的 Promise.reject() 示例所示，异步错误只能通过异步的 onRejected 处理程序捕获：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 正确</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;&#125;);<span class="hljs-comment">// 不正确，还是无法捕获错误</span><span class="hljs-keyword">try</span> &#123;    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));&#125; <span class="hljs-keyword">catch</span>(e) &#123;&#125;</code></pre></div><p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 try&#x2F;catch 在执行函数中捕获错误：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);    &#125; <span class="hljs-keyword">catch</span>(e) &#123;&#125;    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p); <span class="hljs-comment">// Promise &lt;resolved&gt;: bar</span></code></pre></div><p>then()和 catch()的 onRejected 处理程序在语义上相当于 try&#x2F;catch。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之后返回一个<strong>解决</strong>的期约。下面的例子中对比了同步错误处理与异步错误处理：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;begin synchronous execution&#x27;</span>);<span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);&#125; <span class="hljs-keyword">catch</span>(e) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;caught error&#x27;</span>, e);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;continue synchronous execution&#x27;</span>);<span class="hljs-comment">// begin synchronous execution</span><span class="hljs-comment">// caught error Error: foo</span><span class="hljs-comment">// continue synchronous execution</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;begin asynchronous execution&#x27;</span>);    <span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;bar&#x27;</span>));&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;caught error&#x27;</span>, e);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;continue asynchronous execution&#x27;</span>);&#125;);<span class="hljs-comment">// begin asynchronous execution</span><span class="hljs-comment">// caught error Error: bar</span><span class="hljs-comment">// continue asynchronous execution</span></code></pre></div><h2 id="4-期约连锁与期约合成"><a href="#4-期约连锁与期约合成" class="headerlink" title="4 期约连锁与期约合成"></a>4 期约连锁与期约合成</h2><p>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。</p><h3 id="4-1-期约连锁"><a href="#4-1-期约连锁" class="headerlink" title="4.1 期约连锁"></a>4.1 期约连锁</h3><p>把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法，比如then()、catch()和 finally()，都会返回一个<strong>新</strong>的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;first&#x27;</span>);    <span class="hljs-title function_">resolve</span>();&#125;);p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;second&#x27;</span>))    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;third&#x27;</span>))    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fourth&#x27;</span>));<span class="hljs-comment">// first</span><span class="hljs-comment">// second</span><span class="hljs-comment">// third</span><span class="hljs-comment">// fourth </span></code></pre></div><p>这个实现最终执行了一连串同步任务。正因为如此，这种方式执行的任务没有那么有用，毕竟分别使用 4 个同步函数也可以做到：</p><div class="code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;first&#x27;</span>))();(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;second&#x27;</span>))();(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;third&#x27;</span>))();(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fourth&#x27;</span>))();</code></pre></div><p>要真正执行异步任务，可以改写前面的例子，让每个执行器都返回一个期约实例。这样就可以让每 个后续期约都等待之前的期约，也就是串行化异步任务。比如，可以像下面这样让每个期约在一定时间后解决：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p1 executor&#x27;</span>);    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>);&#125;);p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p2 executor&#x27;</span>);    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>);&#125;))    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p3 executor&#x27;</span>);        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>);    &#125;))    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p4 executor&#x27;</span>);        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>);    &#125;)); <span class="hljs-comment">// p1 executor（1 秒后）</span><span class="hljs-comment">// p2 executor（2 秒后）</span><span class="hljs-comment">// p3 executor（3 秒后）</span><span class="hljs-comment">// p4 executor（4 秒后）</span></code></pre></div><p>每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题。</p><p>因为 then()、catch()和 finally()都返回期约，所以串联这些方法也很直观。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;initial promise rejects&#x27;</span>);    <span class="hljs-title function_">reject</span>();&#125;);p.<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reject handler&#x27;</span>))    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolve handler&#x27;</span>))    .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally handler&#x27;</span>));    <span class="hljs-comment">// initial promise rejects</span><span class="hljs-comment">// reject handler</span><span class="hljs-comment">// resolve handler</span><span class="hljs-comment">// finally handler</span></code></pre></div><h3 id="4-2-期约合成"><a href="#4-2-期约合成" class="headerlink" title="4.2 期约合成"></a>4.2 期约合成</h3><p>Promise 提供两个将多个期约实例组合成一个期约的静态方法：Promise.all() 和 Promise.race()。 而合成后期约的行为取决于内部期约的行为。</p><h4 id="4-2-1-Promise-all"><a href="#4-2-1-Promise-all" class="headerlink" title="4.2.1 Promise.all()"></a>4.2.1 Promise.all()</h4><p>Promise.all() 静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个<strong>新</strong>期约：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(),    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()]);<span class="hljs-comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<span class="hljs-comment">// 空的可迭代对象等价于 Promise.resolve()</span><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([]);<span class="hljs-comment">// 无效的语法</span><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(); <span class="hljs-comment">// TypeError: cannot read Symbol.iterator of undefined</span></code></pre></div><p>合成的期约只会在每个包含的期约都解决之后才解决：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(),    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))]);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p); <span class="hljs-comment">// Promise &lt;pending&gt;</span>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;all() resolved!&#x27;</span>));<span class="hljs-comment">// all() resolved!（大约 1 秒后）</span></code></pre></div><p>如果<strong>至少有一个</strong>包含的期约待定，则合成的期约也会待定。如果<strong>有一个</strong>包含的期约拒绝，则合成的期约也会拒绝：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 永远待定</span><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123; &#125;)]);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1); <span class="hljs-comment">// Promise &lt;pending&gt;</span><span class="hljs-comment">// 一次拒绝会导致最终期约拒绝</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(),    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(),    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()]);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2); <span class="hljs-comment">// Promise &lt;rejected&gt;</span><span class="hljs-comment">// Uncaught (in promise) undefined</span></code></pre></div><p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约<strong>解决值</strong>的数组，按照迭代器顺序：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>),    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(),    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>)]);p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, values)); <span class="hljs-comment">// [3, undefined, 4]</span></code></pre></div><p>如果有期约拒绝，则<strong>第一个</strong>拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 虽然只有第一个期约的拒绝理由会进入</span><span class="hljs-comment">// 拒绝处理程序，第二个期约的拒绝也</span><span class="hljs-comment">// 会被静默处理，不会有错误跑掉</span><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>),    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">1000</span>))]);p.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, reason)); <span class="hljs-comment">// 3</span><span class="hljs-comment">// 没有未处理的错误</span></code></pre></div><h4 id="4-2-2-Promise-race"><a href="#4-2-2-Promise-race" class="headerlink" title="4.2.2 Promise.race()"></a>4.2.2 Promise.race()</h4><p>Promise.race() 静态方法返回一个包装期约，是一组集合中<strong>最先解决或拒绝</strong>的期约的<strong>镜像</strong>（新期约）。这个方法接收一个可迭代对象，返回一个<strong>新</strong>期约：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(),    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()]);<span class="hljs-comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<span class="hljs-comment">// 空的可迭代对象等价于 new Promise(() =&gt; &#123;&#125;)</span><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([]);<span class="hljs-comment">// 无效的语法</span><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>();<span class="hljs-comment">// TypeError: cannot read Symbol.iterator of undefined</span></code></pre></div><p>Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回<strong>新</strong>期约：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 解决先发生，超时后的拒绝被忽略</span><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>),    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">1000</span>))]);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1); <span class="hljs-comment">// Promise &lt;resolved&gt;: 3</span><span class="hljs-comment">// 拒绝先发生，超时后的解决被忽略</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">4</span>),    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))]);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2); <span class="hljs-comment">// Promise &lt;rejected&gt;: 4</span><span class="hljs-comment">// 迭代顺序决定了落定顺序</span><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>),    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">6</span>),    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">7</span>)]);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p3); <span class="hljs-comment">// Promise &lt;resolved&gt;: 5</span></code></pre></div><p>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 Promise.all() 类似，合成的期约会静默处理所有包含期约的拒绝操作，如下所示：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 虽然只有第一个期约的拒绝理由会进入</span><span class="hljs-comment">// 拒绝处理程序，第二个期约的拒绝也</span><span class="hljs-comment">// 会被静默处理，不会有错误跑掉</span><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>),    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">1000</span>))]);p.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, reason)); <span class="hljs-comment">// 3</span><span class="hljs-comment">// 没有未处理的错误</span></code></pre></div><h2 id="5-异步函数"><a href="#5-异步函数" class="headerlink" title="5 异步函数"></a>5 异步函数</h2><p>异步函数，也称为“async&#x2F;await”（语法关键字），是 ES6 期约模式在 ECMAScript 函数中的应用。 async&#x2F;await 是 ES8 规范新增的。这个特性从行为和语法上都增强了 JavaScript，让<strong>以同步方式写的代码能够异步执行</strong>。</p><p>下面来看一个最简单的例子，这个期约在超时之后会解决为一个值。如果程序中的其他代码要在这个值可用时访问它，则需要写一个<strong>解决处理程序</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)); <span class="hljs-comment">// 3</span></code></pre></div><p>这其实是很不方便的，因为其他代码都必须塞到<strong>期约处理程序</strong>中。</p><p>ES8 的 async&#x2F;await 旨在解决利用异步结构组织代码的问题。为此，ECMAScript 对函数进行了扩展， 为其增加了两个新关键字：async 和 await。</p><h3 id="5-1-async"><a href="#5-1-async" class="headerlink" title="5.1 async"></a>5.1 async</h3><p>async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; &#125;<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; &#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">baz</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123; &#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Qux</span> &#123;    <span class="hljs-keyword">async</span> <span class="hljs-title function_">qux</span>(<span class="hljs-params"></span>) &#123; &#125;&#125;</code></pre></div><p>使用 async 关键字可以让函数具有<strong>异步特征</strong>，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通 JavaScript 函数的正常行为。正如下面的例子所示，foo()函数仍然会在后面的指令之前被求值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-title function_">foo</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span></code></pre></div><p>不过，异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这个值会被 Promise.resolve() 包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;&#125;<span class="hljs-comment">// 给返回的期约添加一个解决处理程序</span><span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 先执行同步代码，再执行then方法中的异步代码</span><span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// 3 </span></code></pre></div><p>异步函数的返回值期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。</p><ul><li><p>如果返回的是实现 thenable 接口的对象，则这个对象可以由提供给 then() 的处理程序<strong>解包</strong>。</p></li><li><p>如果不是，则返回值就被当作已经解决的期约。</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 返回一个原始值</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;&#125;<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-comment">// foo</span><span class="hljs-comment">// 返回一个没有实现 thenable 接口的对象</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;bar&#x27;</span>];&#125;<span class="hljs-title function_">bar</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-comment">// [&#x27;bar&#x27;]</span><span class="hljs-comment">// 返回一个实现了 thenable 接口的非期约对象，解包</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> thenable = &#123;        <span class="hljs-title function_">then</span>(<span class="hljs-params">callback</span>) &#123; <span class="hljs-title function_">callback</span>(<span class="hljs-string">&#x27;baz&#x27;</span>); &#125;    &#125;;    <span class="hljs-keyword">return</span> thenable;&#125;<span class="hljs-title function_">baz</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-comment">// baz</span><span class="hljs-comment">// 返回一个期约，解包</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">qux</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;qux&#x27;</span>);&#125;<span class="hljs-title function_">qux</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-comment">// qux</span></code></pre></div><p>与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">throw</span> <span class="hljs-number">3</span>;&#125;<span class="hljs-comment">// 给返回的期约添加一个拒绝处理程序</span><span class="hljs-title function_">foo</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// 3</span></code></pre></div><p>不过，拒绝期约的错误不会被异步函数捕获：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>);&#125;<span class="hljs-comment">// 给返回的期约添加一个拒绝处理程序</span><span class="hljs-title function_">foo</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// Uncaught (in promise): 3</span></code></pre></div><h3 id="5-2-await"><a href="#5-2-await" class="headerlink" title="5.2 await"></a>5.2 await</h3><p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> p);&#125;<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// 3 </span></code></pre></div><p>注意，await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。await 关键字同样是尝试<strong>解包</strong>对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。</p><p>await 关键字的用法与 JavaScript 的一元操作一样。它可以单独使用，也可以在表达式中使用：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 异步打印&quot;foo&quot;</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));&#125;<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// foo</span><span class="hljs-comment">// 异步打印&quot;bar&quot;</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);&#125;<span class="hljs-title function_">bar</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-comment">// bar</span><span class="hljs-comment">// 1000 毫秒后异步打印&quot;baz&quot;</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;baz&#x27;</span>);&#125;<span class="hljs-title function_">baz</span>();<span class="hljs-comment">// baz（1000 毫秒后）</span></code></pre></div><p>await 关键字期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如果是实现 thenable 接口的对象，则这个对象可以由 await 来<strong>解包</strong>。如果不是，则这个值就被当作已经解决的期约。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 等待一个原始值</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-string">&#x27;foo&#x27;</span>);&#125;<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// foo</span><span class="hljs-comment">// 等待一个没有实现 thenable 接口的对象</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> [<span class="hljs-string">&#x27;bar&#x27;</span>]);&#125;<span class="hljs-title function_">bar</span>();<span class="hljs-comment">// [&#x27;bar&#x27;]</span><span class="hljs-comment">// 等待一个实现了 thenable 接口的非期约对象</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> thenable = &#123;        <span class="hljs-title function_">then</span>(<span class="hljs-params">callback</span>) &#123; <span class="hljs-title function_">callback</span>(<span class="hljs-string">&#x27;baz&#x27;</span>); &#125;    &#125;;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> thenable);&#125;<span class="hljs-title function_">baz</span>();<span class="hljs-comment">// baz</span><span class="hljs-comment">// 等待一个期约</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">qux</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;qux&#x27;</span>));&#125;<span class="hljs-title function_">qux</span>();<span class="hljs-comment">// qux</span></code></pre></div><p>等待会抛出错误的同步操作，会返回拒绝的期约：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">await</span> (<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-number">3</span>; &#125;)();&#125;<span class="hljs-comment">// 给返回的期约添加一个拒绝处理程序</span><span class="hljs-title function_">foo</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// 3 </span></code></pre></div><p>如前面的例子所示，单独的 Promise.reject()不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用 await 则会释放（unwrap）错误值（将拒绝期约返回）：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 这行代码不会执行</span>&#125;<span class="hljs-comment">// 给返回的期约添加一个拒绝处理程序</span><span class="hljs-title function_">foo</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// 3 </span></code></pre></div><h3 id="5-3-await-的限制"><a href="#5-3-await-的限制" class="headerlink" title="5.3 await 的限制"></a>5.3 await 的限制</h3><ol><li><p>await 关键字必须在异步函数中使用，不能在顶级上下文如<code>&lt;script&gt;</code>标签或模块中使用。</p></li><li><p>异步函数的特质不会扩展到嵌套函数。因此，await 关键字也只能直接出现在异步函数的定义中。在同步函数内部使用 await 会抛出 SyntaxError。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript设计模式】设计模式与开发实践</title>
    <link href="/archives/a700808d.html"/>
    <url>/archives/a700808d.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-原型模式"><a href="#1-原型模式" class="headerlink" title="1 原型模式"></a>1 原型模式</h2><p>原型模式是一种用来创建对象的模式。JavaScript没有选择类式继承，而是通过原型委托的方式来实现对象和对象之间的继承。</p><p>原型编程泛型的基本原则：</p><ul><li><p>所有的数据都是对象</p><p>在JavaScript中，除了undefined外一切皆对象（number、boolean、string类型数据可以通过包装类的方式成为对象）。JavaScript中，所有对象都是从Object.prototype这个对象克隆得到的。</p></li><li><p>得到一个对象的方法不是通过实例化类，而是找到一个对象作为原型并克隆它</p><p>new操作符后面跟上构造函数所执行的动作：</p><p>1首先创建一个对象，2把这个对象的re’s属性设置为构造函数的原型，3把构造函数的this指向新对象，4执行构造函数内部代码，5如果构造函数不返回对象那就返回新对象。34两步可以调用构造函数的call或apply方法。</p></li><li><p>对象记住它的原型</p><p>对象通过proto属性来记住它原型。</p></li><li><p>对象在无法响应某个请求时委托给原型</p><p>访问对象的某个属性时，如果对象身上没有这个属性，那就去它的原型身上去找，如果仍然没有找到，那就沿着原型链找下去，直到找到该属性或者到达原型链的终点，也就是Object.prototype的原型null。</p></li></ul><p>this总是指向调用所在函数时的环境（谁调用就指向谁）。this指向有四种：</p><ol><li>this所在函数作为对象的属性调用。此时this指向该对象。</li><li>this所在函数作为普通函数被调用。此时this指向全局对象。</li><li>this所在函数作为构造函数被调用。此时this指向新创建的对象。（通常情况下，this就指向返回的对象。如果构造函数<strong>显式</strong>返回一个<strong>对象</strong>，那么this不指向这个返回的对象。）</li><li>函数对象的call和apply方法。此时的this指向传入的参数。</li></ol><p>call和apply。都是用来改变函数运行时内部的this值的。区别在于apply接受两个参数，第一个参数是this指向，第二参数是类数组对象。apply会将类数组对象中的所有元素作为参数传给被调用的函数。call参数数量不固定，第一个参数依然是this指向，之后的参数全部传给被调用的函数。</p><p>（TODO）手写实现bind函数。</p><p>闭包。</p><p>高阶函数。高阶函数是指可以作为参数被传递或者作为返回值输出的函数。</p><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2 单例模式"></a>2 单例模式</h2><p>单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点。</p><h3 id="2-1-标准的单例模式"><a href="#2-1-标准的单例模式" class="headerlink" title="2.1 标准的单例模式"></a>2.1 标准的单例模式</h3><p>用一个变量来标志当前是否已经为某个类创建过对象。如果创建过，则在下一次获取该类的实例时，直接返回之前创建的对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Singleton</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instence</span> = <span class="hljs-literal">null</span>&#125;<span class="hljs-title class_">Singleton</span>.<span class="hljs-property">getInstence</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">instence</span>)&#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">instence</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(name)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">instence</span>&#125;<span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Singleton</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Singleton</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)  <span class="hljs-comment">// true</span></code></pre></div><p>或者将实例封装在闭包中：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Singlelon</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name&#125;<span class="hljs-title class_">Singlelon</span>.<span class="hljs-property">getInstance</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)&#123;        <span class="hljs-keyword">if</span>(!instance)&#123;            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singlelon</span>(name)        &#125;        <span class="hljs-keyword">return</span> instance    &#125;&#125;)()<span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Singlelon</span>.<span class="hljs-title function_">getInstance</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Singlelon</span>.<span class="hljs-title function_">getInstance</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)<span class="hljs-comment">// true</span></code></pre></div><p><strong>缺点</strong>：用户必须知道这是一个单例类，必须使用特定的Singleton.getIntance方法来获取实例。这和一般情况下使用new 不同，增加了行为的不一致性和类的不透明性。</p><h3 id="2-2-透明的单例模式"><a href="#2-2-透明的单例模式" class="headerlink" title="2.2 透明的单例模式"></a>2.2 透明的单例模式</h3><p>用户从这个类中创建对象时，可以像任何其他普通类一样：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Singlelon</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">Singlelon</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)&#123;        <span class="hljs-keyword">if</span>(!instance)&#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name            instance = <span class="hljs-variable language_">this</span>        &#125;        <span class="hljs-keyword">return</span> instance    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Singlelon</span>&#125;)()<span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singlelon</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-keyword">const</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singlelon</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2) <span class="hljs-comment">//true</span></code></pre></div><p>缺点：Singlelon 构造函数同时负责创建单例和管理单例（保证单例对象只有一个），违反了单一职责原则。</p><h3 id="2-3-抽取管理单例的逻辑-代理"><a href="#2-3-抽取管理单例的逻辑-代理" class="headerlink" title="2.3 抽取管理单例的逻辑 - 代理"></a>2.3 抽取管理单例的逻辑 - 代理</h3><p>其中一种解决方案是，将负责管理单例的逻辑移到代理类中：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Singlelon</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name&#125;<span class="hljs-keyword">let</span> <span class="hljs-title class_">ProxySinglelon</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)&#123;        <span class="hljs-keyword">if</span>(!instance)&#123;            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singlelon</span>(name)        &#125;        <span class="hljs-keyword">return</span> instance    &#125;&#125;)()<span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxySinglelon</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-keyword">const</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxySinglelon</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)</code></pre></div><h3 id="2-4-抽取管理单例的逻辑-封装"><a href="#2-4-抽取管理单例的逻辑-封装" class="headerlink" title="2.4 抽取管理单例的逻辑 - 封装"></a>2.4 抽取管理单例的逻辑 - 封装</h3><p>另一种解决方案是把管理单例的逻辑抽取出来，把这些逻辑封装在 getSingle 函数的内部，创建对象的方法 Constructor 被当作是参数动态传入 getSingle 函数。</p><div class="code-wrapper"><pre><code class="hljs shell">function getSingle(Constructor)&#123;    let result = null    return function()&#123;        return result || (result = Constructor(arguments))    &#125;&#125;function Singlelon(name)&#123;    this.name = name&#125;const s1 = getSingle(Singlelon)(&#x27;foo&#x27;)const s2 = getSingle(Singlelon)(&#x27;bar&#x27;)console.log(s1 === s2)</code></pre></div><h2 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3 策略模式"></a>3 策略模式</h2><p>策略模式：定义一系列算法，把它们一个个封装起来，并且使他们可以相互替换。目的是将算法的使用和算法的实现分离开。</p><p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用。</p><p>优点：</p><ol><li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</li><li>策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它 们易于切换，易于理解，易于扩展。</li></ol><p>在函数作为一等对象的语言中，策略模式是隐形的。 strategy 就是值为函数的变量。实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身 当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函 数发出“调用”的消息时，不同的函数会返回不同的执行结果。</p><h3 id="3-1-例子-计算奖金"><a href="#3-1-例子-计算奖金" class="headerlink" title="3.1 例子 - 计算奖金"></a>3.1 例子 - 计算奖金</h3><p>计算奖金，奖金的数目由薪水和绩效评级决定。绩效评级为S的，获得4倍薪水；A有3倍；B有2倍。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> strategies = &#123;    S : <span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>)&#123;        <span class="hljs-keyword">return</span> salary * <span class="hljs-number">4</span>    &#125;,    A : <span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>)&#123;        <span class="hljs-keyword">return</span> salary * <span class="hljs-number">3</span>    &#125;,    B : <span class="hljs-keyword">function</span>(<span class="hljs-params">salary</span>)&#123;        <span class="hljs-keyword">return</span> salary * <span class="hljs-number">2</span>    &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateBonus</span>(<span class="hljs-params">level, salary</span>)&#123;    <span class="hljs-keyword">return</span> strategies[level](salary)&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateBonus</span>(<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-number">100</span>))   <span class="hljs-comment">// 400</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateBonus</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">150</span>))   <span class="hljs-comment">// 450</span></code></pre></div><p>在此代码中，strategies 作为策略对象，calculateBonus 作为 contex，负责接受请求并委托给策略对象。</p><h3 id="3-2-例子-表单校验"><a href="#3-2-例子-表单校验" class="headerlink" title="3.2 例子 - 表单校验"></a>3.2 例子 - 表单校验</h3><p>注册页的几条校验逻辑：</p><ol><li>用户名不能为空</li><li>密码长度不能少于6位</li><li>手机号码必须符合格式</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 不同的表单校验策略</span><span class="hljs-comment"> */</span><span class="hljs-keyword">let</span> strategies = &#123;    <span class="hljs-attr">isNotEmpty</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value, errorMsg</span>)&#123;        <span class="hljs-keyword">if</span>(value === <span class="hljs-string">&#x27;&#x27;</span>)&#123;<span class="hljs-keyword">return</span> errorMsg&#125;    &#125;,    <span class="hljs-attr">minLength</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value, length, errorMsg</span>)&#123;        <span class="hljs-keyword">if</span>(value.<span class="hljs-property">length</span> &lt; length)&#123;<span class="hljs-keyword">return</span> errorMsg&#125;    &#125;,    <span class="hljs-attr">isMobile</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value, errorMsg</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;!/(^1[3|5|8][0-9]&#123;9&#125;$)/&#x27;</span>.<span class="hljs-title function_">test</span>( value ))&#123;<span class="hljs-keyword">return</span> errorMsg&#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 策略类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Validator</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">// ValidatorList 中存放的是校验函数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ValidatorList</span> = []&#125;<span class="hljs-title class_">Validator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">dom, rule, errorMsg</span>)&#123;    <span class="hljs-keyword">const</span> array = rule.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ValidatorList</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-keyword">const</span> strategy = array.<span class="hljs-title function_">shift</span>()        array.<span class="hljs-title function_">unshift</span>(dom.<span class="hljs-property">value</span>)        array.<span class="hljs-title function_">push</span>(errorMsg)        <span class="hljs-keyword">return</span> strategies[strategy].<span class="hljs-title function_">apply</span>(dom, array)    &#125;)&#125;<span class="hljs-title class_">Validator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">start</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ValidatorList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">func</span>=&gt;</span>&#123;        <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">func</span>()        <span class="hljs-keyword">if</span>(msg)&#123;            <span class="hljs-keyword">return</span> msg        &#125;    &#125;)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">validateFunc</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">const</span> validator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Validator</span>()    validator.<span class="hljs-title function_">add</span>(registerForm.<span class="hljs-property">userName</span>, <span class="hljs-string">&#x27;isNonEmpty&#x27;</span>, <span class="hljs-string">&#x27;用户名不能为空&#x27;</span>)    validator.<span class="hljs-title function_">add</span>(registerForm.<span class="hljs-property">password</span>, <span class="hljs-string">&#x27;minLength:6&#x27;</span>, <span class="hljs-string">&#x27;密码长度不能少于 6 位&#x27;</span>)    validator.<span class="hljs-title function_">add</span>(registerForm.<span class="hljs-property">phoneNumber</span>, <span class="hljs-string">&#x27;isMobile&#x27;</span>, <span class="hljs-string">&#x27;手机号码格式不正确&#x27;</span>)    <span class="hljs-keyword">const</span> errorMsg = validator.<span class="hljs-title function_">start</span>()    <span class="hljs-keyword">return</span> errorMsg&#125;<span class="hljs-keyword">const</span> registerForm = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;registerForm&#x27;</span>)registerForm.<span class="hljs-property">onsubmit</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-title function_">validateFunc</span>()    <span class="hljs-keyword">if</span>(errorMsg)&#123;        <span class="hljs-title function_">alert</span>(errorMsg)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Pro Git】Git常用命令总结</title>
    <link href="/archives/cc1c6456.html"/>
    <url>/archives/cc1c6456.html</url>
    
    <content type="html"><![CDATA[<h3 id="git-config-查看配置信息"><a href="#git-config-查看配置信息" class="headerlink" title="git config 查看配置信息"></a>git config 查看配置信息</h3><p>查看所有配置信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git config --list</code></pre></div><p>查看某一条配置信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git config user.name</code></pre></div><p>修改某一条配置信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git config user.name &lt;value&gt;</code></pre></div><p><strong>注</strong>：加 –global 参数后，可以查看或配置全局信息。之后该账户下面每个Git仓库都会使用该配置。</p><h3 id="git-init-初始化Git"><a href="#git-init-初始化Git" class="headerlink" title="git init 初始化Git"></a>git init 初始化Git</h3><p>进入需要Git进行管理的根目录下，然后：</p><div class="code-wrapper"><pre><code class="hljs shell">git init</code></pre></div><h3 id="git-clone-克隆远程仓库到本地"><a href="#git-clone-克隆远程仓库到本地" class="headerlink" title="git clone 克隆远程仓库到本地"></a>git clone 克隆远程仓库到本地</h3><div class="code-wrapper"><pre><code class="hljs shell">git clone &lt;地址&gt;</code></pre></div><p>地址可以是HTTP&#x2F;HTTPS协议，也可以是Git协议。</p><p>使用该命令后，默认将该地址设置为远程仓库并赋予别名origin。</p><p>如果想重新起一个名字而不是使用默认的origin，可以使用 -o 参数：</p><div class="code-wrapper"><pre><code class="hljs shell">git clone -o &lt;远程仓库别名&gt;</code></pre></div><h3 id="git-log-查看提交记录"><a href="#git-log-查看提交记录" class="headerlink" title="git log 查看提交记录"></a>git log 查看提交记录</h3><p>查看全部提交记录：</p><div class="code-wrapper"><pre><code class="hljs shell">git log</code></pre></div><p>使用 –graph 参数可以用简易图形方式呈现提交记录：</p><div class="code-wrapper"><pre><code class="hljs shell">git log --graph</code></pre></div><h3 id="git-status-查看当前文件状态"><a href="#git-status-查看当前文件状态" class="headerlink" title="git status 查看当前文件状态"></a>git status 查看当前文件状态</h3><blockquote><p>Git中有三种<strong>文件状态</strong>：已提交（committed）、已修改（modified）和已暂存（staged）。已提交指的是数据已经被保存到Git数据库中。已修改指的是文件修改过但是还没保存到数据库。已暂存指的是对已修改的文件进行了记录，下次提交这些记录会生效。</p></blockquote><p>查看详细的文件状态：</p><div class="code-wrapper"><pre><code class="hljs shell">git status</code></pre></div><p>使用 -s 参数，查看简略的文件状态：</p><div class="code-wrapper"><pre><code class="hljs shell">git status -s</code></pre></div><p>文件前面的字母表示的含义：</p><ul><li>A：首次添加到暂存区。</li><li>M：出现在左边表示已修改并加入到暂存区，出现在右边表示已修改但尚未加入到暂存区，左右都出现表示修改后并加入到暂存区并再次修改但未加入暂存区。</li><li>D：从暂存区中删除。</li><li>?：尚未跟踪过，也就是从来都没加入到暂存区过。</li></ul><h3 id="git-add-添加文件到下一次提交中"><a href="#git-add-添加文件到下一次提交中" class="headerlink" title="git add 添加文件到下一次提交中"></a>git add 添加文件到下一次提交中</h3><p>可以用于对新文件的跟踪，也可以用于对修改后的文件进行暂存：</p><div class="code-wrapper"><pre><code class="hljs shell">git add &lt;文件名&gt;</code></pre></div><p>暂存所有文件：</p><div class="code-wrapper"><pre><code class="hljs shell">git add .</code></pre></div><h3 id="git-diff-查看未暂存或已暂存的修改"><a href="#git-diff-查看未暂存或已暂存的修改" class="headerlink" title="git diff 查看未暂存或已暂存的修改"></a>git diff 查看未暂存或已暂存的修改</h3><p>查看未暂存的修改，也就是本地和上一次add之间的区别：</p><div class="code-wrapper"><pre><code class="hljs shell">git diff</code></pre></div><p>查看已暂存的修改，也就上一次add和上一次commit之间的区别：</p><div class="code-wrapper"><pre><code class="hljs shell">git diff --cached<span class="hljs-meta prompt_"># </span><span class="language-bash">或</span>git diff --staged</code></pre></div><h3 id="git-commit-提交更新"><a href="#git-commit-提交更新" class="headerlink" title="git commit 提交更新"></a>git commit 提交更新</h3><p>直接使用 git commit 会启动编辑器来填写提交信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git commit</code></pre></div><p>在命令同一行填写提交信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git commit -m &quot;提交信息&quot;</code></pre></div><p>忽略将文件添加到暂存区（git add）的过程，让文件从已修改状态直接到已提交状态：</p><div class="code-wrapper"><pre><code class="hljs shell">git commit -a -m &quot;提交信息&quot;</code></pre></div><p><strong>注</strong>：这个 -a 参数只适用于已被跟踪过的文件，如果文件没有被跟踪过，-a 参数无法生效。</p><h3 id="git-show-查看对象信息"><a href="#git-show-查看对象信息" class="headerlink" title="git show 查看对象信息"></a>git show 查看对象信息</h3><p>不加任何参数时，输查看最近一次提交的信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git show</code></pre></div><p>查看各种对象（提交记录、分支、标签等等）的信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git show &lt;对象&gt;</code></pre></div><h3 id="git-commit-–amend-撤销提交"><a href="#git-commit-–amend-撤销提交" class="headerlink" title="git commit –amend 撤销提交"></a>git commit –amend 撤销提交</h3><p>撤销上一次提交并进行一次新的提交：</p><div class="code-wrapper"><pre><code class="hljs shell">git commit --amend -m &quot;提交信息&quot;</code></pre></div><p>这条指令会撤销上一次提交，并且按照<strong>当前</strong>暂存区中的内容进行一次新的提交。</p><h3 id="git-reset-HEAD-lt-文件名-gt-撤销暂存"><a href="#git-reset-HEAD-lt-文件名-gt-撤销暂存" class="headerlink" title="git reset HEAD &lt;文件名&gt; 撤销暂存"></a>git reset HEAD &lt;文件名&gt; 撤销暂存</h3><p>如果暂存文件（git add）后反悔了，可以使用该命令将文件取消暂存（从已暂存退回已修改）：</p><div class="code-wrapper"><pre><code class="hljs shell">git reset HEAD &lt;文件名&gt;</code></pre></div><h3 id="git-checkout-–-lt-文件名-gt-撤销修改"><a href="#git-checkout-–-lt-文件名-gt-撤销修改" class="headerlink" title="git checkout – &lt;文件名&gt; 撤销修改"></a>git checkout – &lt;文件名&gt; 撤销修改</h3><p>把已修改（但是没有暂存）的文件撤回到上一次暂存或者提交时的样子：</p><div class="code-wrapper"><pre><code class="hljs shell">git checkout -- &lt;文件名&gt;</code></pre></div><p><strong>注</strong>：这是一个<span style="color:red">危险</span>的指令，没有暂存的修改撤销之后无法恢复。</p><h3 id="git-rm-移除文件"><a href="#git-rm-移除文件" class="headerlink" title="git rm 移除文件"></a>git rm 移除文件</h3><blockquote><p><strong>该命令行为存疑</strong>，尽量不使用该命令。</p></blockquote><p>把文件从Git仓库或暂存区中移除，并从工作区中移除：</p><div class="code-wrapper"><pre><code class="hljs shell">git rm &lt;文件&gt;</code></pre></div><p>使用 -f 命令强制删除：</p><div class="code-wrapper"><pre><code class="hljs shell">git rm -f &lt;文件&gt;</code></pre></div><p>使用 -r 命令删除文件夹：</p><div class="code-wrapper"><pre><code class="hljs shell">git rm -r &lt;文件夹&gt;</code></pre></div><p>如果想把文件从Git仓库或暂存区中移除但是仍然保留在工作目录中，可以使用 –cache 参数：</p><div class="code-wrapper"><pre><code class="hljs shell">git rm --cache &lt;文件名&gt;</code></pre></div><h3 id="git-mv-重命名"><a href="#git-mv-重命名" class="headerlink" title="git mv 重命名"></a>git mv 重命名</h3><p>重命名文件：</p><div class="code-wrapper"><pre><code class="hljs shell">git mv &lt;旧文件名&gt; &lt;新文件名&gt;</code></pre></div><h3 id="git-remote-查看远程仓库"><a href="#git-remote-查看远程仓库" class="headerlink" title="git remote 查看远程仓库"></a>git remote 查看远程仓库</h3><p>查看<strong>所有</strong>远程仓库，只显示别名：</p><div class="code-wrapper"><pre><code class="hljs shell">git remote</code></pre></div><p><strong>注</strong>：对于远程仓库克隆下来的项目，这个远程仓库默认的别名是 origin。</p><p>使用 -v 参数显示<strong>所有</strong>远程仓库的详细信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git remote -v</code></pre></div><p>查看<strong>某个</strong>远程仓库的详细信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git remote show &lt;别名&gt;</code></pre></div><p>查看远程仓库中分支、标签等引用列表：</p><div class="code-wrapper"><pre><code class="hljs shell">git ls-remote &lt;别名&gt;</code></pre></div><p>添加远程仓库并设置别名：</p><div class="code-wrapper"><pre><code class="hljs shell">git remote add &lt;别名&gt; &lt;地址&gt;</code></pre></div><p>修改远程仓库的别名：</p><div class="code-wrapper"><pre><code class="hljs shell">git remote rename &lt;旧别名&gt; &lt;新别名&gt;</code></pre></div><p>修改远程仓库地址：</p><div class="code-wrapper"><pre><code class="hljs shell">git remote set-url &lt;别名&gt; &lt;新地址&gt;</code></pre></div><p>删除某个远程仓库：</p><div class="code-wrapper"><pre><code class="hljs shell">git remote remove &lt;别名&gt;</code></pre></div><h3 id="git-fetch-从远程仓库中抓取最新数据"><a href="#git-fetch-从远程仓库中抓取最新数据" class="headerlink" title="git fetch 从远程仓库中抓取最新数据"></a>git fetch 从远程仓库中抓取最新数据</h3><p>从远程仓库（默认是origin）中抓取最新版本：</p><div class="code-wrapper"><pre><code class="hljs shell">git fetch &lt;远程仓库别名&gt;</code></pre></div><p><code>git fetch</code> 命令会将<strong>数据</strong>拉取到本地仓库 ，但是它并<strong>不会</strong>自动合并或修改当前的工作。 当准备好时，必须<strong>手动</strong>将其合并入当前工作（将远程分支上的数据merge到当前的分支）。</p><p>上面的命令会抓取远程仓库中所有分支的最新数据，并和本地同名的分支进行比对。</p><p>如果想只抓取某个分支的最近数据，那么需要：</p><div class="code-wrapper"><pre><code class="hljs shell">git fetch &lt;远程仓库别名&gt; &lt;远程仓库分支名&gt;</code></pre></div><blockquote><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p></blockquote><h3 id="git-pull-从远程仓库中抓取最新数据并更新本地"><a href="#git-pull-从远程仓库中抓取最新数据并更新本地" class="headerlink" title="git pull 从远程仓库中抓取最新数据并更新本地"></a>git pull 从远程仓库中抓取最新数据并更新本地</h3><p>从远程仓库（默认是origin）中抓取最新版本，并尝试合并到同名分支（可能出现冲突）：</p><div class="code-wrapper"><pre><code class="hljs shell">git pull &lt;远程仓库别名&gt;</code></pre></div><blockquote><p>如果你有一个分支设置为跟踪一个远程分支，可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p></blockquote><p>如果只想抓取某个分支上最新的数据并合并到同名的本地分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git pull &lt;远程仓库别名&gt; &lt;远程仓库分支名&gt;</code></pre></div><h3 id="git-push-推送到远程仓库"><a href="#git-push-推送到远程仓库" class="headerlink" title="git push 推送到远程仓库"></a>git push 推送到远程仓库</h3><p>将某分支的内容推送到远程仓库：</p><div class="code-wrapper"><pre><code class="hljs shell">git push &lt;远程仓库别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<span class="hljs-meta prompt_"># </span><span class="language-bash">当本地目前分支和想要推送的远程分支名相同时，可以简写：</span>git push &lt;远程仓库别名&gt; &lt;分支名&gt;</code></pre></div><blockquote><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作<strong>拉取</strong>下来并将其<strong>合并</strong>进你的工作后才能推送。</p></blockquote><p>使用 -u 参数之后，下次再推动到这个远程仓库和分支时可以省略仓库别名和分支名：</p><div class="code-wrapper"><pre><code class="hljs shell">git push -u &lt;远程仓库名&gt; &lt;远程分支名&gt;</code></pre></div><h3 id="git-tag-标签"><a href="#git-tag-标签" class="headerlink" title="git tag 标签"></a>git tag 标签</h3><p>列出所有标签：</p><div class="code-wrapper"><pre><code class="hljs shell">git tag</code></pre></div><blockquote><p>Git可以给某一次的提交打上标签，以示重要。Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。一个<strong>轻量标签</strong>很像一个不会改变的分支 - 它只是一个特定提交的引用。然而，<strong>附注标签</strong>是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p></blockquote><p>创建一个<strong>轻量标签</strong>，不需要任何参数：</p><div class="code-wrapper"><pre><code class="hljs shell">git tag &lt;标签名&gt;</code></pre></div><p>查看标签信息以及对应的提交信息：</p><div class="code-wrapper"><pre><code class="hljs shell">git show &lt;标签名&gt;</code></pre></div><p>创建一个<strong>附注标签</strong>，需要使用 -a  参数，使用 -m 参数填写标签信息： </p><div class="code-wrapper"><pre><code class="hljs shell">git tag -a &lt;标签名&gt; -m &lt;标签信息&gt;</code></pre></div><blockquote><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 <code>git push origin [tagname]</code>。</p></blockquote><p>将标签推送到远程仓库：</p><div class="code-wrapper"><pre><code class="hljs shell">git push &lt;分支名&gt; &lt;标签名&gt;</code></pre></div><p>也可以一次性将所有不在远程仓库中的标签推送过去：</p><div class="code-wrapper"><pre><code class="hljs shell">git push &lt;远程仓库别名&gt; --tags</code></pre></div><h3 id="git-branch-创建分支"><a href="#git-branch-创建分支" class="headerlink" title="git branch 创建分支"></a>git branch 创建分支</h3><blockquote><p>关于<em>分支</em>：<a href="https://www.progit.cn/#_git_branching">《Pro Git 中文版（第二版）》</a></p></blockquote><p>创建一个新的分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git branch &lt;分支名&gt;</code></pre></div><p>上面这个命令仅仅会创建一个新的分支，不会自动切换到新分支中去。</p><p>查看各个分支指向的对象：</p><div class="code-wrapper"><pre><code class="hljs shell">git log --oneline --decorate</code></pre></div><p>查看所有分支和当前分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git branch</code></pre></div><h3 id="git-branch-d-删除分支"><a href="#git-branch-d-删除分支" class="headerlink" title="git branch -d 删除分支"></a>git branch -d 删除分支</h3><p>删除分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git branch -d &lt;分支名&gt;</code></pre></div><p>注：如果分支上有未合并的工作，尝试删除时会失败。</p><p>查看已合并的分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git branch --merged</code></pre></div><p>查看未合并的分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git branch --no-merged</code></pre></div><h3 id="git-checkout-切换分支"><a href="#git-checkout-切换分支" class="headerlink" title="git checkout 切换分支"></a>git checkout 切换分支</h3><p>切换到已有的其他分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git checkout &lt;分支名&gt;</code></pre></div><p>如果想新建一个分支并且切换到新分支上去，需要使用 -b 参数：</p><div class="code-wrapper"><pre><code class="hljs shell">git checkout -b &lt;分支名&gt;</code></pre></div><p>如果想在远程分支的基础上建立一个新的分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git checkout -b &lt;分支名&gt; &lt;远程仓库别名&gt;</code></pre></div><p>如果想要将本地分支与远程分支设置为不同名字：</p><div class="code-wrapper"><pre><code class="hljs shell">git checkout -b &lt;本地分支名&gt; &lt;远程仓库别名&gt;/&lt;远程仓库分支名&gt;</code></pre></div><p>查看分支历史：</p><div class="code-wrapper"><pre><code class="hljs shell">git log --oneline --decorate --graph --all</code></pre></div><h3 id="git-merge-合并分支"><a href="#git-merge-合并分支" class="headerlink" title="git merge 合并分支"></a>git merge 合并分支</h3><p>合并分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git merge &lt;分支名&gt;</code></pre></div><p><strong>注</strong>：如果想要将dev分支上的内容合并到master分支上，需要先检出到master分支上，然后在master分支上运行<code>git merge dev</code>指令。</p><p>如果合并出现冲突，此时需要对出现冲突的文件进行手动处理。处理好冲突后，还需要使用<code>git add</code>命令暂存文件，并使用<code>git commit</code>再次进行提交。</p><h3 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h3><blockquote><p>远程跟踪分支是<strong>远程分支</strong>状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作（<code>git clone/git fetch/git pull/git push</code>）后，它们会自动移动。 远程跟踪分支像是你<strong>上次</strong>连接到远程仓库时，那些分支所处状态的书签。</p></blockquote><p>在和远程仓库进行通信（比如：<code>git clone/git fetch/git pull/git push</code>）之后，本地会存在<strong>远程分支的引用</strong>（叫做远程跟踪分支），引用以<code>&lt;远程仓库名&gt;/&lt;远程仓库中的分支名&gt;</code>命名。假如<code>git fetch</code>或者<code>git clone</code>之后，本地有了一个叫做<code>origin/dev</code>的<strong>远程分支引用</strong>。这个引用是不可修改的。之后，有其他人向这个远程分支上推送了新的代码。此时，我们本地的<code>origin/dev</code>不会自动更新，必须再次和远程仓库进行通信后（<code>git fetch</code>等等）才能更新。</p><p>在<code>git fetch</code>之后需要对远程跟踪分支进行手动合并：</p><div class="code-wrapper"><pre><code class="hljs shell">git merge origin/dev</code></pre></div><h3 id="git-push-lt-仓库-gt-推送分支"><a href="#git-push-lt-仓库-gt-推送分支" class="headerlink" title="git push &lt;仓库&gt; 推送分支"></a>git push &lt;仓库&gt; 推送分支</h3><p>本地的分支不会自动和远程仓库进行同步，必须要手动推送想要推送的分支到远程服务器：</p><div class="code-wrapper"><pre><code class="hljs shell">git push &lt;远程仓库别名&gt; &lt;想推送的分支名&gt;:&lt;远程仓库别名&gt;</code></pre></div><p>如果想推送的分支名和远程仓库分支名相同，可以简写：</p><div class="code-wrapper"><pre><code class="hljs shell">git push &lt;远程仓库别名&gt; &lt;分支名&gt;</code></pre></div><h3 id="git-push-lt-仓库-gt-–delete-删除远程分支"><a href="#git-push-lt-仓库-gt-–delete-删除远程分支" class="headerlink" title="git push &lt;仓库&gt; –delete 删除远程分支"></a>git push &lt;仓库&gt; –delete 删除远程分支</h3><p>删除远程仓库中的分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git push &lt;远程仓库别名&gt; --delete &lt;分支名&gt;</code></pre></div><h3 id="git-rebase-变基分支"><a href="#git-rebase-变基分支" class="headerlink" title="git rebase 变基分支"></a>git rebase 变基分支</h3><p>变基分支：</p><div class="code-wrapper"><pre><code class="hljs shell">git rebase &lt;分支名&gt;</code></pre></div><p><strong>注</strong>：如果想要将dev分支上修改变基到master分支上，需要先检出到master分支上，然后执行上述命令。</p><blockquote><p><strong>风险准则</strong>：<strong>不要对在你的仓库外有副本的分支执行变基。</strong>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><p><strong>总的原则</strong>：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。</p></blockquote><h3 id="git-merge-和-git-rebase-的区别？"><a href="#git-merge-和-git-rebase-的区别？" class="headerlink" title="git merge 和 git rebase 的区别？"></a>git merge 和 git rebase 的区别？</h3><p>git merge 和 git rebase 都是把另一个分支上的修改整合到当前分支上的操作。</p><p>merge 操作的原理是将两个分支的最新修改和他们的最近共同祖先进行三方合并。rebase 操作的原理是先找到两个分支的共同祖先，然后得到另一个分支相对于共同祖先的历次修改记录，并且将这些修改依次应用到当前分支上。</p><p>这两种做法在结果上没有区别。merge时需要一次合并信息，但是rebase不需要。所以rebase会让提交历史记录变得简洁。</p><h3 id="git-rebase-–onto-指定另一分支变基"><a href="#git-rebase-–onto-指定另一分支变基" class="headerlink" title="git rebase –onto 指定另一分支变基"></a>git rebase –onto 指定另一分支变基</h3><p>在 b1 分支中，找出 b1 和 b2 分支共同祖先之后的修改，然后将这些修改应用到 b3 分支中：</p><div class="code-wrapper"><pre><code class="hljs shell">git rebase --onto b3 b2 b1</code></pre></div><h3 id="git-reflog-引用日志"><a href="#git-reflog-引用日志" class="headerlink" title="git reflog 引用日志"></a>git reflog 引用日志</h3><p>引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史，每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。：</p><div class="code-wrapper"><pre><code class="hljs shell">git reflog</code></pre></div><h3 id="git-log-lt-分支1-gt-lt-分支2-gt-提交区间"><a href="#git-log-lt-分支1-gt-lt-分支2-gt-提交区间" class="headerlink" title="git log &lt;分支1&gt;..&lt;分支2&gt; 提交区间"></a>git log &lt;分支1&gt;..&lt;分支2&gt; 提交区间</h3><p>使用双点语法可以选出在一个分支中但是不再另一个分支中的提交。比如查看分支b2中还有哪些提交没有合并入b1：</p><div class="code-wrapper"><pre><code class="hljs shell">git log b1..b2</code></pre></div><h3 id="git-add-i-交互式暂存"><a href="#git-add-i-交互式暂存" class="headerlink" title="git add -i 交互式暂存"></a>git add -i 交互式暂存</h3><p>进入交互式暂存：</p><div class="code-wrapper"><pre><code class="hljs shell">git add -i</code></pre></div><h3 id="git-stash-贮藏修改"><a href="#git-stash-贮藏修改" class="headerlink" title="git stash 贮藏修改"></a>git stash 贮藏修改</h3><p>如果工作到一半时需要切换分支，但是不想将完成一半的工作提交，可以使用git stash把当前修改贮藏到栈中：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash</code></pre></div><p>使用–keep-index参数可以指定Git不贮藏任何通过git add命令已暂存的东西：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash --keep-index</code></pre></div><blockquote><p>当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。</p></blockquote><p>默认情况下，git stash只会贮藏已经被跟踪的文件，如果想把未跟踪的文件也贮藏起来，可以使用-u参数：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash -u</code></pre></div><p>使用–patch参数，Git 不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash --patch</code></pre></div><h3 id="git-stash-list-查看已贮藏的修改"><a href="#git-stash-list-查看已贮藏的修改" class="headerlink" title="git stash list 查看已贮藏的修改"></a>git stash list 查看已贮藏的修改</h3><p>查看已经贮藏的修改列表：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash list</code></pre></div><h3 id="git-stash-apply-应用最近贮藏的修改"><a href="#git-stash-apply-应用最近贮藏的修改" class="headerlink" title="git stash apply 应用最近贮藏的修改"></a>git stash apply 应用最近贮藏的修改</h3><p>应用最近一次贮藏的修改：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash apply</code></pre></div><p>应用一个更旧的贮藏，可以通过名字指定：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash apply stash@&#123;2&#125;</code></pre></div><blockquote><p>可以在一个分支上保存一个储藏，切换到另一个分支，然后尝试重新应用这些修改。</p></blockquote><h3 id="git-stash-pop-应用并删除最近贮藏的修改："><a href="#git-stash-pop-应用并删除最近贮藏的修改：" class="headerlink" title="git stash pop 应用并删除最近贮藏的修改："></a>git stash pop 应用并删除最近贮藏的修改：</h3><p>出栈：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash pop</code></pre></div><h3 id="git-stash-drop-删除一个贮藏的修改："><a href="#git-stash-drop-删除一个贮藏的修改：" class="headerlink" title="git stash drop 删除一个贮藏的修改："></a>git stash drop 删除一个贮藏的修改：</h3><p>删除最近一次贮藏的修改：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash drop</code></pre></div><p>删除指定的贮藏记录：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash drop stash@&#123;2&#125;</code></pre></div><h3 id="git-stash-branch-lt-分支名-gt-从贮藏创建分支"><a href="#git-stash-branch-lt-分支名-gt-从贮藏创建分支" class="headerlink" title="git stash branch &lt;分支名&gt; 从贮藏创建分支"></a>git stash branch &lt;分支名&gt; 从贮藏创建分支</h3><blockquote><p>如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试储藏的改动，可以运行 <code>git stash branch</code> 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏。</p></blockquote><h3 id="git-clean-删除没有跟踪的文件"><a href="#git-clean-删除没有跟踪的文件" class="headerlink" title="git clean 删除没有跟踪的文件"></a>git clean 删除没有跟踪的文件</h3><p>如果想将工作目录中没有被跟踪的文件删除，可以使用：</p><div class="code-wrapper"><pre><code class="hljs shell">git clean</code></pre></div><p>上面的命令只能删除文件，如果想删除文件夹，可以使用-d参数：</p><div class="code-wrapper"><pre><code class="hljs shell">git clean -d</code></pre></div><p>使用-f参数强制执行：</p><div class="code-wrapper"><pre><code class="hljs shell">git clean -d -f</code></pre></div><p>使用-n参数，只查看将要删除什么不会进行删除：</p><div class="code-wrapper"><pre><code class="hljs shell">git clean -d -n</code></pre></div><p>默认情况下，<code>git clean</code> 命令只会移除没有忽略的未跟踪文件。 任何与 <code>.gitiignore</code> 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 <code>.o</code> 文件，可以给 clean 命令增加一个 <code>-x</code> 选项：</p><div class="code-wrapper"><pre><code class="hljs shell">git clean -n -d -x</code></pre></div><p>也可以使用-i来进行交互式操作：</p><div class="code-wrapper"><pre><code class="hljs shell">git clean -n -d -i</code></pre></div><h3 id="git-stash-–all-清理工作目录并贮藏"><a href="#git-stash-–all-清理工作目录并贮藏" class="headerlink" title="git stash –all 清理工作目录并贮藏"></a>git stash –all 清理工作目录并贮藏</h3><p>git clean 清理之后无法找回，如果不想完全删除，可以使用 git stash –all 来贮存：</p><div class="code-wrapper"><pre><code class="hljs shell">git stash --all</code></pre></div><h3 id="git-grep-从工作目录或者历史中查找字符串"><a href="#git-grep-从工作目录或者历史中查找字符串" class="headerlink" title="git grep 从工作目录或者历史中查找字符串"></a>git grep 从工作目录或者历史中查找字符串</h3><p>可以从当前目录和历史提交中查找字符串或者正则表达式：</p><div class="code-wrapper"><pre><code class="hljs shell">git grep &lt;字符串或正则表达式&gt;</code></pre></div><h3 id="git-提交工作流钩子"><a href="#git-提交工作流钩子" class="headerlink" title="git 提交工作流钩子"></a>git 提交工作流钩子</h3><p>前四个钩子涉及提交的过程。</p><p><code>pre-commit</code> 钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 <code>git commit --no-verify</code> 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 <code>lint</code> 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p><p><code>prepare-commit-msg</code> 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。</p><p><code>commit-msg</code> 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</p><p><code>post-commit</code> 钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 <code>git log -1 HEAD</code> 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【代码随想录】1_数组_2_移除元素</title>
    <link href="/archives/a92514c8.html"/>
    <url>/archives/a92514c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p><a href="https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">代码随想录链接</a></p><p><a href="https://leetcode.cn/problems/remove-element/">LeetCode题目链接</a></p><p><strong>思路</strong>：</p><p><strong>就地</strong>移除数组中的元素考虑使用<strong>双指针</strong>法。双指针法分为快慢双指针法和相向双指针法。</p><p><strong>快慢双指针法</strong>可以确保数组中元素的相对位置不变。</p><p><strong>相向双指针法</strong>可能会改变数组中元素的相对位置，但是可以确保移动最少的元素。</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><blockquote><p>快慢指针法新数组最后几位不是待删元素。如果想确保原数组相对位置不变，又想将待删元素全部移动到数组最后，参照（283.移动零）</p></blockquote><h2 id="第一种双指针：快慢双指针"><a href="#第一种双指针：快慢双指针" class="headerlink" title="第一种双指针：快慢双指针"></a>第一种双指针：快慢双指针</h2><p>方法：</p><ul><li>快指针负责找到数组中非待删元素，然后赋值给慢指针；</li><li>慢指针负责更新数组</li><li>退出循环时，慢指针的位置就是新数组元素个数</li></ul><p>优点：</p><ul><li>新数组可以确保元素中元素的相对位置不变。</li></ul><p>缺点：</p><ul><li>效率不高。比如：当数组中只有第一个元素需要移除时，这种方法会移动所有其他元素。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, val</span>) &#123;  <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (nums[i] !== val) &#123;      nums[length++] = nums[i]    &#125;  &#125;  <span class="hljs-keyword">return</span> length;&#125;;</code></pre></div><h2 id="第二种双指针：相向双指针"><a href="#第二种双指针：相向双指针" class="headerlink" title="第二种双指针：相向双指针"></a>第二种双指针：相向双指针</h2><p>方法：</p><ul><li>左指针向右找待删元素，右指针向左找非待删元素</li><li>如果想<strong>保留</strong>原数组中的待删元素，可以将两个位置的元素进行<strong>交换</strong>；如果不想保留原数组中的待删元素，可以将右指针位置元素直接覆盖掉左指针位置的元素。</li><li>退出循环后， 左指针的位置就是新数组元素个数。</li></ul><p>优点：</p><ul><li>可以节省元素移动次数</li></ul><p>缺点：</p><ul><li>原数组中元素相对位置保持不变</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, val</span>) &#123;  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; nums[left] !== val) &#123; left++ &#125;    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; nums[right] === val) &#123; right++ &#125;    <span class="hljs-comment">// 覆盖</span>    <span class="hljs-keyword">if</span> (left &lt; right) &#123; nums[left++] = nums[right--] &#125;  &#125;  <span class="hljs-keyword">return</span> left&#125;;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, val</span>) &#123;  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; nums[left] !== val) &#123; left++ &#125;    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; nums[right] === val) &#123; right-- &#125;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        <span class="hljs-comment">// 交换</span>      <span class="hljs-title function_">swap</span>(nums, left, right)    &#125;  &#125;  <span class="hljs-keyword">return</span> left&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">nums, x, y</span>)&#123;  <span class="hljs-keyword">const</span> temp = nums[x]  nums[x] = nums[y]  nums[y] = temp&#125;</code></pre></div><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">LeetCode题目地址</a></p><p>思路：</p><p>快慢双指针，快指针负责找不等于慢指针的元素，慢指针负责更新数组。退出循环时，慢指针的位置是新数组的最后一个元素，因此返回长度需要+1。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;    <span class="hljs-keyword">let</span> <span class="hljs-attr">length</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-property">length</span>; i++)&#123;        <span class="hljs-keyword">if</span>(nums[i] !== nums[length])&#123;            nums[length+<span class="hljs-number">1</span>] = nums[i]            length++        &#125;    &#125;    <span class="hljs-keyword">return</span> length+<span class="hljs-number">1</span>&#125;</code></pre></div><p>优化：</p><p>比如，当数组中没有重复元素时，这种方法会将所有元素原地复制一边。因此在赋值之前加个判断：当快指针比慢指针最少快两个元素时才进行赋值（保证快慢指针之间有重复元素）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;    <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-property">length</span>; i++)&#123;        <span class="hljs-keyword">if</span>(nums[i] !== nums[length])&#123;            <span class="hljs-keyword">if</span>(i - length &gt;<span class="hljs-number">1</span>)&#123;                nums[length+<span class="hljs-number">1</span>] = nums[i]            &#125;            length++        &#125;    &#125;    <span class="hljs-keyword">return</span> length+<span class="hljs-number">1</span>&#125;;</code></pre></div><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h3><p>LeetCode<a href="https://leetcode.cn/problems/move-zeroes/">题目地址</a></p><p>思路：</p><p>两次循环，第一次按标准的快慢指针找出新数组，此时待删元素（此题中为0）有的被覆盖，快慢指针之间的元素不全为0。因此需要第二次循环，从慢指针开始到数组末尾全部置0。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">nums: number[]</span>): <span class="hljs-keyword">void</span> &#123;    <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-property">length</span>;i++)&#123;        <span class="hljs-keyword">if</span>(nums[i] !== <span class="hljs-number">0</span>)&#123;            nums[j++] = nums[i]        &#125;    &#125;    <span class="hljs-keyword">while</span>(j&lt;nums.<span class="hljs-property">length</span>)&#123;nums[j++] = <span class="hljs-number">0</span>&#125;&#125;;</code></pre></div><p>优化：</p><p>可以利用快排中的 patition 函数思想，只用一次循环即可。</p><p>&#x2F;&#x2F; todo</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【代码随想录】1_数组_1_二分查找</title>
    <link href="/archives/87492e24.html"/>
    <url>/archives/87492e24.html</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">代码随想录链接</a></p><p><a href="https://leetcode.cn/problems/binary-search/">LeetCode题目链接</a></p><p><strong>思路</strong>：</p><p>数组查找题目，当数组<strong>有序</strong>并且<strong>无重复</strong>元素时应该考虑<strong>二分法</strong>。</p><p>二分法有两种模板，第一种是在<strong>左闭右闭</strong>区间中查找，第二种是在<strong>左闭右开</strong>区间中查找。</p><p>时间复杂度：O(log n)</p><p>空间复杂度：O(1)</p><h2 id="第一种模板：左闭右闭"><a href="#第一种模板：左闭右闭" class="headerlink" title="第一种模板：左闭右闭"></a>第一种模板：左闭右闭</h2><p><strong>注意</strong>：</p><p>未找到 target 退出循环时， left 一定等于 right + 1，也就是  left 在 right 右边第一个位置。这时候的 left 就是 target 应该插入的位置。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><span class="hljs-comment"> * 第一种二分查找写法，while(left&lt;=right)&#123;&#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> search = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;    <span class="hljs-keyword">const</span> middle = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (target &lt; nums[middle]) &#123;      right = middle - <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[middle]) &#123;      left = middle + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> middle;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;;</code></pre></div><h2 id="第二种模板：左闭右开"><a href="#第二种模板：左闭右开" class="headerlink" title="第二种模板：左闭右开"></a>第二种模板：左闭右开</h2><p><strong>注意</strong>：</p><p>未找到 target 退出循环时，left 一定等于 right。这时候 left 就是 target 应该插入的位置。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><span class="hljs-comment"> * 第二种二分写法，while(left&lt;right)&#123;&#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> search = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span>; <span class="hljs-comment">// 不包括右区间，所以这里不能-1</span>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;    <span class="hljs-keyword">const</span> middle = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;      right = middle;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;      left = middle + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> middle;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;;</code></pre></div><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h3><p><a href="https://leetcode.cn/problems/search-insert-position/">LeetCode题目链接</a></p><p><strong>思路</strong>：</p><p>二分法，找第一个大于等于 target 的位置。如果没有找到，那么 left 的位置就是 target 应该插入的位置。</p><p>如果使用第一种二分法， left 等于 right + 1；如果使用第二种二分法，left 等于 right。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><span class="hljs-comment"> * 第一种二分法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> searchInsert = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;    <span class="hljs-keyword">const</span> middle = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;      right = middle - <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;      left = middle + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> middle;    &#125;  &#125;  <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;&#125;;</code></pre></div><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode题目地址</a></p><p><strong>思路</strong>：</p><p>二分法，直到找到一个该元素。找到一个该元素之后，以该位置为中心，向两边寻找边界。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> searchRange = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;        <span class="hljs-keyword">const</span> mid = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;            left = mid + <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;            right = mid - <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            left = right = mid            <span class="hljs-keyword">while</span>(nums[left] === target) &#123; left-- &#125;            <span class="hljs-keyword">while</span>(nums[right] === target) &#123; right++ &#125;            <span class="hljs-keyword">return</span> [left + <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]&#125;;</code></pre></div><h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69.x的平方根"></a>69.x的平方根</h3><p><a href="https://leetcode.cn/problems/sqrtx/">LeetCode题目地址</a></p><p><strong>思路</strong>：<br>二分法，从0到x。返回的条件是 $mid^2$ 等于 x $mid^2$ 或者小于 x，并且 $(mid + 1)^2$大于x 。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><span class="hljs-comment"> */</span> <span class="hljs-keyword">var</span> mySqrt = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> right = x    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;        <span class="hljs-keyword">const</span> mid = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span>(mid**<span class="hljs-number">2</span> &lt; x)&#123;            <span class="hljs-keyword">const</span> rear = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span>(rear**<span class="hljs-number">2</span> &gt; x)&#123;                <span class="hljs-keyword">return</span> mid            &#125;<span class="hljs-keyword">else</span>&#123;                left = mid + <span class="hljs-number">1</span>            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid**<span class="hljs-number">2</span> &gt; x)&#123;            right = mid -<span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> mid        &#125;    &#125;&#125;</code></pre></div><h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a>367. 有效的完全平方数</h3><p><a href="https://leetcode.cn/problems/valid-perfect-square/">LeetCode题目地址</a></p><p><strong>思路</strong>：</p><p>二分法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">num</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isPerfectSquare = <span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) &#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> right = num    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;        <span class="hljs-keyword">const</span> mid = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span>(mid**<span class="hljs-number">2</span> &lt; num)&#123;            left = mid + <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid**<span class="hljs-number">2</span> &gt; num)&#123;            right = mid - <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】24.网络请求与远程资源</title>
    <link href="/archives/f049ac93.html"/>
    <url>/archives/f049ac93.html</url>
    
    <content type="html"><![CDATA[<h1 id="网络请求与远程资源"><a href="#网络请求与远程资源" class="headerlink" title="网络请求与远程资源"></a>网络请求与远程资源</h1><h2 id="1-XMLHttpRequest-对象"><a href="#1-XMLHttpRequest-对象" class="headerlink" title="1 XMLHttpRequest 对象"></a>1 XMLHttpRequest 对象</h2><p>所有现代浏览器都通过 XMLHttpRequest 构造函数原生支持 XHR 对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</code></pre></div><h3 id="1-1-open-send-和abort"><a href="#1-1-open-send-和abort" class="headerlink" title="1.1 open() send()和abort()"></a>1.1 open() send()和abort()</h3><h4 id="1-1-1-open-准备请求"><a href="#1-1-1-open-准备请求" class="headerlink" title="1.1.1 open() 准备请求"></a>1.1.1 open() 准备请求</h4><p>使用 XHR 对象首先要调用 open() 方法，这个方法接收 3 个参数：请求类型（”get”、”post”等）、请求URL，以及表示请求是否<strong>异步</strong>（是否阻塞代码执行）的布尔值。下面是一个例子：</p><div class="code-wrapper"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;example.php&quot;</span>, <span class="hljs-literal">false</span>);</code></pre></div><p>这行代码就可以向 example.php 发送一个同步的 GET 请求。关于这行代码需要说明几点。首先，这里的 URL 是相对于代码所在页面的，当然也可以使用绝对 URL。其次，调用 open() 不会实际发送请求，只是为发送请求做好准备。</p><blockquote><p>注意：只能访问<strong>同源</strong> URL，也就是域名相同、端口相同、协议相同。如果请求的 URL 与发送请求的页面在任何方面有所不同，则会抛出安全错误。</p></blockquote><h4 id="1-1-2-send-发送请求"><a href="#1-1-2-send-发送请求" class="headerlink" title="1.1.2 send() 发送请求"></a>1.1.2 send() 发送请求</h4><p>要发送定义好的请求，必须像下面这样调用 send() 方法：</p><div class="code-wrapper"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-literal">false</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);</code></pre></div><p>send() 方法接收一个参数，是作为<strong>请求体</strong>发送的数据。如果不需要发送请求体，则必须传 null，因为这个参数在某些浏览器中是必需的。调用 send() 之后，请求就会发送到服务器。</p><p>因为这个请求是<strong>同步</strong>的，所以 JavaScript 代码会等待服务器响应之后再继续执行。收到响应后，XHR 对象的以下属性会被填充上数据。</p><ul><li>responseText：作为响应体返回的文本。</li><li>responseXML：如果响应的内容类型是”text&#x2F;xml”或”application&#x2F;xml”，那就是包含响应数据的 XML DOM 文档。</li><li>status：响应的 HTTP 状态。</li><li>statusText：响应的 HTTP 状态描述。</li></ul><img src="../images/【JavaScript】24_网络请求与远程资源/image-20221229102420941.png" alt="image-20221229102420941" style="zoom:33%;" /><h4 id="1-1-3-status状态码-responseText响应体-readyState阶段码-onreadystatechange阶段码变化事件"><a href="#1-1-3-status状态码-responseText响应体-readyState阶段码-onreadystatechange阶段码变化事件" class="headerlink" title="1.1.3 status状态码 responseText响应体 readyState阶段码 onreadystatechange阶段码变化事件"></a>1.1.3 status状态码 responseText响应体 readyState阶段码 onreadystatechange阶段码变化事件</h4><p>收到响应后，第一步要检查 status 属性以确保响应成功返回。一般来说，HTTP 状态码为 2xx 表示成功。此时，responseText 或 responseXML（如果内容类型正确）属性中会有内容。如果 HTTP 状态码是 304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。为确保收到正确的响应，应该检查这些状态码，如下所示：</p><div class="code-wrapper"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-literal">false</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;    <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);&#125;</code></pre></div><p>以上代码可能显示服务器返回的内容，也可能显示错误消息，取决于 HTTP 响应的状态码。为确定下一步该执行什么操作，最好检查 status 而不是 statusText 属性，因为后者已经被证明在跨浏览器的情况下不可靠。无论是什么响应内容类型，responseText 属性始终会保存响应体，而 responseXML 则对于非 XML 数据是 null。</p><p>虽然可以像前面的例子一样发送同步请求，但多数情况下最好使用<strong>异步</strong>请求，这样可以不阻塞 JavaScript 代码继续执行。XHR 对象有一个 readyState 属性，表示当前处在请求&#x2F;响应过程的哪个阶段。这个属性有如下可能的值：</p><ul><li>0：未初始化（Uninitialized）。尚未调用 open() 方法。</li><li>1：已打开（Open）。已调用 open() 方法，尚未调用 send() 方法。</li><li>2：已发送（Sent）。已调用 send() 方法，尚未收到响应。</li><li>3：接收中（Receiving）。已经收到部分响应。</li><li>4：完成（Complete）。已经收到所有响应，可以使用了。</li></ul><p><strong>每次 readyState 从一个值变成另一个值，都会触发 onreadystatechange 事件</strong>。可以借此机会检查 readyState 的值。一般来说，我们唯一关心的 readyState 值是 4，表示数据已就绪。为保证跨浏览器兼容，onreadystatechange 事件处理程序应该在调用 open() 之前赋值。来看下面的例子：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;            <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);        &#125;    &#125;&#125;;xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-literal">true</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);</code></pre></div><p>以上代码使用 DOM Level 0 风格为 XHR 对象添加了事件处理程序，因为并不是所有浏览器都支持 DOM Level 2 风格。与其他事件处理程序不同，onreadystatechange 事件处理程序不会收到 event 对象。在事件处理程序中，必须使用 XHR 对象本身来确定接下来该做什么。 </p><h4 id="1-1-4-abort-取消请求"><a href="#1-1-4-abort-取消请求" class="headerlink" title="1.1.4 abort() 取消请求"></a>1.1.4 abort() 取消请求</h4><p>在收到响应之前如果想取消异步请求，可以调用 abort() 方法：</p><div class="code-wrapper"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">abort</span>();</code></pre></div><p>调用这个方法后，XHR 对象会停止触发事件，并阻止访问这个对象上任何与响应相关的属性。中断请求后，应该取消对 XHR 对象的引用。由于内存问题，不推荐重用 XHR 对象。</p><h3 id="1-2-HTTP-头部"><a href="#1-2-HTTP-头部" class="headerlink" title="1.2 HTTP 头部"></a>1.2 HTTP 头部</h3><p>每个 HTTP 请求和响应都会携带一些头部字段，这些字段可能对开发者有用。XHR 对象会通过一些方法暴露与请求和响应相关的头部字段。<br>默认情况下，XHR 请求会发送以下头部字段：</p><ul><li>Accept：浏览器可以处理的内容类型。</li><li>Accept-Charset：浏览器可以显示的字符集。</li><li>Accept-Encoding：浏览器可以处理的压缩编码类型。</li><li>Accept-Language：浏览器使用的语言。</li><li>Connection：浏览器与服务器的连接类型。</li><li>Cookie：页面中设置的Cookie。</li><li>Host：发送请求的页面所在的域。</li><li>Referer：发送请求的页面的URI。注意，这个字段在 HTTP 规范中就拼错了，所以考虑到兼容<br>性也必须将错就错。（正确的拼写应该是Referrer）</li><li>User-Agent：浏览器的用户代理字符串。</li></ul><p>虽然不同浏览器发送的确切头部字段可能各不相同，但这些通常都是会发送的。</p><h4 id="1-2-1-setRequestHeader-设置请求头部"><a href="#1-2-1-setRequestHeader-设置请求头部" class="headerlink" title="1.2.1 setRequestHeader() 设置请求头部"></a>1.2.1 setRequestHeader() 设置请求头部</h4><p>如果需要发送额外的请求头部，可以使用 setRequestHeader()方法。这个方法接收两个参数：头部字段的名称和值。为保证请求头部被发送，必须在open() 之后、send() 之前调用 setRequestHeader()，如下面的例子所示：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;            <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);        &#125;    &#125;&#125;;xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;example.php&quot;</span>, <span class="hljs-literal">true</span>);xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;MyHeader&quot;</span>, <span class="hljs-string">&quot;MyValue&quot;</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);</code></pre></div><p>服务器通过读取自定义头部可以确定适当的操作。自定义头部一定要区别于浏览器正常发送的头部，否则可能影响服务器正常响应。有些浏览器允许重写默认头部，有些浏览器则不允许。</p><h4 id="1-2-2-getResponseHeader-获取响应头部"><a href="#1-2-2-getResponseHeader-获取响应头部" class="headerlink" title="1.2.2 getResponseHeader() 获取响应头部"></a>1.2.2 getResponseHeader() 获取响应头部</h4><p>服务器可以使用头部向浏览器传递额外的结构化数据。</p><p>可以使用 getResponseHeader() 方法从 XHR 对象获取响应头部，只要传入要获取头部的名称即可。如果想取得所有响应头部，可以使用 getAllResponseHeaders() 方法，这个方法会返回包含所有响应头部的<strong>字符串</strong>（而不是对象）。下面是调用这两个方法的例子：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myHeader = xhr.<span class="hljs-title function_">getResponseHeader</span>(<span class="hljs-string">&quot;content-length&quot;</span>); <span class="hljs-keyword">let</span> allHeaders = xhr.<span class="hljs-title function_">getAllResponseHeaders</span>();</code></pre></div><p>getAllResponseHeaders() 方法通常返回类似如下的字符串：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Date</span>: Sun, <span class="hljs-number">14</span> Nov <span class="hljs-number">2004</span> <span class="hljs-number">18</span>:<span class="hljs-number">04</span>:<span class="hljs-number">03</span> GMT<span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">29</span> (Unix)<span class="hljs-attribute">Vary</span>: Accept<span class="hljs-attribute">X</span>-Powered-By: PHP/<span class="hljs-number">4</span>.<span class="hljs-number">3</span>.<span class="hljs-number">8</span><span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Content</span>-Type: text/html; charset=iso-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span></code></pre></div><p>通过解析以上头部字段的输出，就可以知道服务器发送的所有头部，而不需要单独去检查了。</p><h3 id="1-3-GET-请求"><a href="#1-3-GET-请求" class="headerlink" title="1.3 GET 请求"></a>1.3 GET 请求</h3><p>最常用的请求方法是 GET 请求，用于向服务器查询某些信息。必要时，需要在 GET 请求的 URL 后面添加查询字符串参数。对 XHR 而言，查询字符串必须正确<strong>编码</strong>后添加到 URL 后面，然后再传给 open() 方法。</p><p>发送 GET 请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用encodeURIComponent() 编码，所有名&#x2F;值对必须以和号（&amp;）分隔，如下面的例子所示：</p><div class="code-wrapper"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;example.php?name1=value1&amp;name2=value2&quot;</span>, <span class="hljs-literal">true</span>);</code></pre></div><p>可以使用以下函数将查询字符串参数添加到现有的 URL 末尾：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addURLParam</span>(<span class="hljs-params">url, name, value</span>) &#123;    url += (url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;?&quot;</span>) == -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;?&quot;</span> : <span class="hljs-string">&quot;&amp;&quot;</span>);    url += <span class="hljs-built_in">encodeURIComponent</span>(name) + <span class="hljs-string">&quot;=&quot;</span> + <span class="hljs-built_in">encodeURIComponent</span>(value);    <span class="hljs-keyword">return</span> url;&#125;</code></pre></div><p>这里定义了一个 addURLParam() 函数，它接收 3 个参数：要添加查询字符串的 URL、查询参数和参数值。首先，这个函数会检查 URL 中是否已经包含问号（以确定是否已经存在其他参数）。如果没有，则加上一个问号；否则就加上一个和号。然后，分别对参数名和参数值进行编码，并添加到 URL 末尾。</p><p>最后一步是返回更新后的 URL。</p><p>可以使用这个函数构建请求 URL，如下面的例子所示：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-string">&quot;example.php&quot;</span>;<span class="hljs-comment">// 添加参数</span>url = <span class="hljs-title function_">addURLParam</span>(url, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>);url = <span class="hljs-title function_">addURLParam</span>(url, <span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-string">&quot;Professional JavaScript&quot;</span>);<span class="hljs-comment">// 初始化请求</span>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, url, <span class="hljs-literal">false</span>);</code></pre></div><p>这里使用 addURLParam() 函数可以保证通过 XHR 发送请求的 URL 格式正确。</p><h3 id="1-4-POST-请求"><a href="#1-4-POST-请求" class="headerlink" title="1.4 POST 请求"></a>1.4 POST 请求</h3><p>第二个最常用的请求是 POST 请求，用于向服务器发送应该保存的数据。每个 POST 请求都应该在请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据可以是任意格式。要初始化 POST 请求，open() 方法的第一个参数要传”post”，比如：</p><div class="code-wrapper"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;example.php&quot;</span>, <span class="hljs-literal">true</span>);</code></pre></div><p>接下来就是要给 send() 方法传入要发送的数据。因为 XHR 最初主要设计用于发送 XML，所以可以传入序列化之后的 XML DOM 文档作为请求体。当然，也可以传入任意字符串。</p><p>默认情况下，对服务器而言，POST 请求与提交表单是不一样的。服务器逻辑需要读取原始 POST 数据才能取得浏览器发送的数据。不过，可以使用 XHR 模拟表单提交。为此：</p><ol><li>第一步需要把 Content-Type 头部设置为<code>application/x-www-formurlencoded</code>，这是提交表单时使用的内容类型。</li><li>第二步是创建对应格式的字符串。POST 数据此时使用与查询字符串相同的格式。如果网页中确实有一个表单需要序列化并通过 XHR 发送到服务器，则可以使用 serialize() 函数来创建相应的字符串，如下所示：</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">submitData</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;            <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;                <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);            &#125;        &#125;    &#125;;    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;postexample.php&quot;</span>, <span class="hljs-literal">true</span>);    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);    <span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;user-info&quot;</span>);    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title function_">serialize</span>(form));&#125;</code></pre></div><h3 id="1-5-XMLHttpRequest-Level-2"><a href="#1-5-XMLHttpRequest-Level-2" class="headerlink" title="1.5 XMLHttpRequest Level 2"></a>1.5 XMLHttpRequest Level 2</h3><p>XHR 对象作为事实标准的迅速流行，也促使W3C 为规范这一行为而制定了正式标准。</p><p>XMLHttpRequest Level 1 只是把已经存在的 XHR 对象的实现细节明确了一下。XMLHttpRequest Level 2 又进一步发展了 XHR 对象。并非所有浏览器都实现了 XMLHttpRequest Level 2 的所有部分，但所有浏览器都实现了其中部分功能。</p><h4 id="1-5-1-FormData-类型"><a href="#1-5-1-FormData-类型" class="headerlink" title="1.5.1 FormData 类型"></a>1.5.1 FormData 类型</h4><p>现代 Web 应用程序中经常需要对表单数据进行序列化，因此 XMLHttpRequest Level 2 新增了 FormData 类型。FormData 类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR 发送。下面的代码创建了一个 FormData 对象，并填充了一些数据：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();data.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>);</code></pre></div><p>append() 方法接收两个参数：键和值，相当于表单字段名称和该字段的值。可以像这样添加任意多个键&#x2F;值对数据。此外，通过直接给 FormData 构造函数传入一个表单元素，也可以将表单中的数据作为键&#x2F;值对填充进去：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>]);</code></pre></div><p>有了 FormData 实例，可以像下面这样直接传给 XHR 对象的 send() 方法：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;            <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);        &#125;    &#125;&#125;;xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;postexample.php&quot;</span>, <span class="hljs-literal">true</span>);<span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;user-info&quot;</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(form));</code></pre></div><p>使用 FormData 的另一个方便之处是不再需要给 XHR 对象显式设置任何请求头部了。XHR 对象能够识别作为 FormData 实例传入的数据类型并自动配置相应的头部。</p><h4 id="1-5-2-timeout-超时"><a href="#1-5-2-timeout-超时" class="headerlink" title="1.5.2 timeout 超时"></a>1.5.2 timeout 超时</h4><p>IE8 给 XHR 对象增加了一个 timeout 属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。之后所有浏览器都在自己的 XHR 实现中增加了这个属性。在给 timeout 属性设置了一个时间且在该时间过后没有收到响应时，XHR 对象就会触发 timeout 事件，调用 ontimeout 事件处理程序。这个特性后来也被添加到了XMLHttpRequest Level 2 规范。下面看一个例子：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;                <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);            &#125;        &#125; <span class="hljs-keyword">catch</span> (ex) &#123;            <span class="hljs-comment">// 假设由ontimeout 处理</span>        &#125;    &#125;&#125;;xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;timeout.php&quot;</span>, <span class="hljs-literal">true</span>);xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 设置1 秒超时</span>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request did not return in a second.&quot;</span>);&#125;;xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);</code></pre></div><p>这个例子演示了使用 timeout 设置超时。给 timeout 设置 1000 毫秒意味着，如果请求没有在1秒钟内返回则会中断。此时则会触发 ontimeout 事件处理程序，readyState 仍然会变成4，因此也会调用 onreadystatechange 事件处理程序。不过，如果在超时之后访问 status 属性则会发生错误。为做好防护，可以把检查 status 属性的代码封装在 try&#x2F;catch 语句中。</p><h4 id="1-5-3-overrideMimeType-方法"><a href="#1-5-3-overrideMimeType-方法" class="headerlink" title="1.5.3 overrideMimeType()方法"></a>1.5.3 overrideMimeType()方法</h4><p>Firefox 首先引入了 overrideMimeType() 方法用于重写 XHR 响应的 MIME 类型。这个特性后来也被添加到了XMLHttpRequest Level 2。因为响应返回的 MIME 类型决定了XHR 对象如何处理响应，所以如果有办法覆盖服务器返回的类型，那么是有帮助的。</p><p>假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是 text&#x2F;plain。结果就会导致虽然数据是 XML，但 responseXML 属性值是 null。此时调用 overrideMimeType() 可以保证将响应当成 XML 而不是纯文本来处理：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;text.php&quot;</span>, <span class="hljs-literal">true</span>);xhr.<span class="hljs-title function_">overrideMimeType</span>(<span class="hljs-string">&quot;text/xml&quot;</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);</code></pre></div><p>这个例子强制让 XHR 把响应当成  XML 而不是纯文本来处理。为了正确覆盖响应的 MIME 类型，必须在调用 send()之前调用 overrideMimeType()。</p><h2 id="2-Progress-Events-进度事件"><a href="#2-Progress-Events-进度事件" class="headerlink" title="2 Progress Events 进度事件"></a>2 Progress Events 进度事件</h2><p>Progress Events 是 W3C 的工作草案，定义了客户端-服务器端通信。这些事件最初只针对 XHR，现在也推广到了其他类似的 API。有以下 6 个进度相关的事件。</p><ul><li>loadstart：在接收到响应的第一个字节时触发。</li><li>progress：在接收响应期间反复触发。</li><li>error：在请求出错时触发。</li><li>abort：在调用 abort() 终止连接时触发。</li><li>load：在成功接收完响应时触发。</li><li>loadend：在通信完成时，且在 error、abort 或 load 之后触发。</li></ul><p>每次请求都会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后以 loadend 事件结束。这些事件大部分都很好理解，但其中有两个需要说明一下。</p><h3 id="2-1-load-事件"><a href="#2-1-load-事件" class="headerlink" title="2.1 load 事件"></a>2.1 load 事件</h3><p>Firefox 最初在实现 XHR 的时候，曾致力于简化交互模式。最终，增加了一个 load 事件用于<strong>替代 readystatechange 事件</strong>。load 事件在响应接收完成后立即触发，这样就不用检查 readyState 属性了。</p><p>onload 事件处理程序会收到一个 event 对象，其 target 属性设置为 XHR 实例，在这个实例上可以访问所有XHR 对象属性和方法。不过，并不是所有浏览器都实现了这个事件的 event 对象。考虑到跨浏览器兼容，还是需要像下面这样使用XHR 对象变量：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;        <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);    &#125;&#125;;xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;altevents.php&quot;</span>, <span class="hljs-literal">true</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);</code></pre></div><p>只要是从服务器收到响应，无论状态码是什么，都会触发 load 事件。这意味着还需要检查 status 属性才能确定数据是否有效。Firefox、Opera、Chrome 和 Safari 都支持 load 事件。</p><h3 id="2-2-progress-事件"><a href="#2-2-progress-事件" class="headerlink" title="2.2 progress 事件"></a>2.2 progress 事件</h3><p>Mozilla 在 XHR 对象上另一个创新是 progress 事件，在浏览器接收数据期间，这个事件会反复触发。每次触发时，onprogress 事件处理程序都会收到 event 对象，其 target 属性是XHR 对象，且包含3 个额外属性：lengthComputable、position 和 totalSize。其中：</p><ul><li>lengthComputable 是一个布尔值，表示进度信息是否可用；</li><li>position 是接收到的字节数；</li><li>totalSize 是响应的Content-Length 头部定义的总字节数。</li></ul><p>有了这些信息，就可以给用户提供进度条了。以下代码演示了如何向用户展示进度：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;        <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);    &#125;&#125;;xhr.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-keyword">let</span> divStatus = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;status&quot;</span>);    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">lengthComputable</span>) &#123;        divStatus.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;Received &quot;</span> + event.<span class="hljs-property">position</span> + <span class="hljs-string">&quot; of &quot;</span> +            event.<span class="hljs-property">totalSize</span> +            <span class="hljs-string">&quot; bytes&quot;</span>;    &#125;&#125;;xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;altevents.php&quot;</span>, <span class="hljs-literal">true</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);</code></pre></div><p>为了保证正确执行，必须在调用 open() 之前添加 onprogress 事件处理程序。在前面的例子中，每次触发 progress 事件都会更新 HTML 元素中的信息。假设响应有 Content-Length 头部，就可以利用这些信息计算出已经收到响应的百分比。</p><h2 id="3-跨源资源共享"><a href="#3-跨源资源共享" class="headerlink" title="3 跨源资源共享"></a>3 跨源资源共享</h2><p>通过 XHR 进行Ajax 通信的一个主要限制是跨源安全策略。默认情况下，XHR 只能访问与发起请求的页面在同一个域内的资源。这个安全限制可以防止某些恶意行为。不过，浏览器也需要支持合法跨源访问的能力。跨源资源共享（CORS，Cross-Origin Resource Sharing）定义了浏览器与服务器如何实现跨源通信。</p><p>CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 text&#x2F;plain 类型，这样的请求在发送时会有一个额外的头部叫 Origin。Origin 头部包含发送请求的页面的源（协议、域名和端口），以便服务器确定是否为其提供响应。下面是 Origin 头部的一个示例：</p><div class="code-wrapper"><pre><code class="hljs awk">Origin: http:<span class="hljs-regexp">//</span>www.nczonline.net</code></pre></div><p>如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；或者如果资源是公开的，那么就包含”*”。比如：</p><div class="code-wrapper"><pre><code class="hljs awk">Access-Control-Allow-Origin: http:<span class="hljs-regexp">//</span>www.nczonline.net</code></pre></div><p>如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。注意，无论请求还是响应都不会包含 cookie 信息。现代浏览器通过 XMLHttpRequest 对象原生支持 CORS。在尝试访问不同源的资源时，这个行为会被自动触发。要向不同域的源发送请求，可以使用标准 XHR 对象并给 open() 方法传入一个绝对 URL，比如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;            <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="hljs-property">status</span>);        &#125;    &#125;&#125;;xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;http://www.somewhere-else.com/page/&quot;</span>, <span class="hljs-literal">true</span>);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);</code></pre></div><p>跨域 XHR 对象允许访问 status 和 statusText 属性，也允许同步请求。出于安全考虑，跨域 XHR 对象也施加了一些额外限制。</p><ul><li>不能使用 setRequestHeader() 设置自定义头部。</li><li>不能发送和接收 cookie。</li><li>getAllResponseHeaders() 方法始终返回空字符串。</li></ul><p>因为无论同域还是跨域请求都使用同一个接口，所以最好在访问本地资源时使用相对 URL，在访问远程资源时使用绝对 URL。这样可以更明确地区分使用场景，同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题。</p><h3 id="3-1-预检请求"><a href="#3-1-预检请求" class="headerlink" title="3.1 预检请求"></a>3.1 预检请求</h3><p>CORS 通过一种叫预检请求（preflighted request）的服务器验证机制，允许使用自定义头部、除GET和POST 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。这个请求使用 OPTIONS 方法发送并包含以下头部。</p><ul><li>Origin：与简单请求相同。</li><li>Access-Control-Request-Method：请求希望使用的方法。</li><li>Access-Control-Request-Headers：（可选）要使用的逗号分隔的自定义头部列表。</li></ul><p>下面是一个假设的POST 请求，包含自定义的 NCZ 头部：</p><div class="code-wrapper"><pre><code class="hljs oxygene">Origin: http:<span class="hljs-comment">//www.nczonline.net</span>Access-Control-Request-<span class="hljs-keyword">Method</span>: POSTAccess-Control-Request-Headers: NCZ</code></pre></div><p>在这个请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送如下头部与浏览器沟通这些信息。</p><ul><li><p>Access-Control-Allow-Origin：与简单请求相同。</p></li><li><p>Access-Control-Allow-Methods：允许的方法（逗号分隔的列表）。</p></li><li><p>Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）。</p></li><li><p>Access-Control-Max-Age：缓存预检请求的秒数。</p></li></ul><p>例如：</p><div class="code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">Access</span>-Control-Allow-Origin: http://www.nczonline.net<span class="hljs-keyword">Access</span>-Control-Allow-Methods: POST, GET<span class="hljs-keyword">Access</span>-Control-Allow-Headers: NCZ<span class="hljs-keyword">Access</span>-Control-<span class="hljs-built_in">Max</span>-Age: <span class="hljs-number">1728000</span></code></pre></div><p>预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的请求时才会多发送一次额外的 HTTP 请求。</p><h3 id="3-2-凭据请求"><a href="#3-2-凭据请求" class="headerlink" title="3.2 凭据请求"></a>3.2 凭据请求</h3><p>默认情况下，跨源请求不提供凭据（cookie、HTTP 认证和客户端SSL 证书）。可以通过将 withCredentials 属性设置为true 来表明请求会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下 HTTP 头部：</p><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Credentials: <span class="hljs-literal">true</span></code></pre></div><p>如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给 JavaScript（responseText 是空字符串，status 是0，onerror()被调用）。注意，服务器也可以在预检请求的响应中发送这个HTTP 头部，以表明这个源允许发送凭据请求。</p><h2 id="4-Fetch-API"><a href="#4-Fetch-API" class="headerlink" title="4 Fetch API"></a>4 Fetch API</h2><p>Fetch API 能够执行 XHR 能执行的所有任务，更加易用，接口更佳现代化。</p><h3 id="4-1-基本用法"><a href="#4-1-基本用法" class="headerlink" title="4.1 基本用法"></a>4.1 基本用法</h3><p>fetch() 方法暴露在全局作用域中。调用 fetch() 方法即可发送请求。</p><h4 id="4-1-1-发送请求"><a href="#4-1-1-发送请求" class="headerlink" title="4.1.1 发送请求"></a>4.1.1 发送请求</h4><p>fetch() 方法有一个必需的参数 input，可以是 URL 或者一个 Requset 实例。也可以传一个可选的参数 init，代表自定义请求配置。返回值是一个 Promise 对象。</p><p><strong>GET 请求</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>)</code></pre></div><p><strong>POST 请求</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>, &#123;    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,        <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;bar&#x27;</span>    &#125;),    <span class="hljs-attr">headers</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(&#123;        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>    &#125;)&#125;)</code></pre></div><p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch#%E8%AF%AD%E6%B3%95">自定义请求配置</a></strong></p><ul><li><code>method</code>: 请求使用的方法，如 <code>GET</code>、<code>POST</code>。</li><li><code>headers</code>: 请求的头信息，形式为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers"><code>Headers</code></a> 的对象或包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>ByteString</code></a> 值的对象字面量。</li><li><code>body</code>: 请求的 body 信息：可能是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a>、<code>BufferSource</code>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData"><code>FormData</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>USVString</code></a> 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。</li><li><code>mode</code>: 请求的模式，如 <code>cors</code>、<code>no-cors</code> 或者 <code>same-origin</code>。</li><li><code>credentials</code>: 请求的 credentials，如 <code>omit</code>、<code>same-origin</code> 或者 <code>include</code>。为了在当前域名内自动发送 cookie，必须提供这个选项，从 Chrome 50 开始，这个属性也可以接受 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FederatedCredential"><code>FederatedCredential</code> (en-US)</a> 实例或是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PasswordCredential"><code>PasswordCredential</code> (en-US)</a> 实例。</li><li><code>cache</code>: 请求的 cache 模式：<code>default</code>、 <code>no-store</code>、 <code>reload</code> 、 <code>no-cache</code>、 <code>force-cache</code> 或者 <code>only-if-cached</code>。</li><li><code>redirect</code>: 可用的 redirect 模式：<code>follow</code> (自动重定向), <code>error</code> (如果产生重定向将自动终止并且抛出一个错误），或者 <code>manual</code> (手动处理重定向)。在 Chrome 中默认使用 <code>follow</code>（Chrome 47 之前的默认值是 <code>manual</code>）。</li><li><code>referrer</code>: 一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>USVString</code></a> 可以是 <code>no-referrer</code>、<code>client</code> 或一个 URL。默认是 <code>client</code>。</li><li><code>referrerPolicy</code>: 指定了 HTTP 头部 referer 字段的值。可能为以下值之一：<code>no-referrer</code>、 <code>no-referrer-when-downgrade</code>、<code>origin</code>、<code>origin-when-cross-origin</code>、 <code>unsafe-url</code>。</li><li><code>integrity</code>: 包括请求的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Subresource_Integrity">subresource integrity</a> 值（例如： <code>sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=</code>）。</li></ul><h4 id="4-1-2-获取响应"><a href="#4-1-2-获取响应" class="headerlink" title="4.1.2 获取响应"></a>4.1.2 获取响应</h4><p>请求完成、资源可用时，期约会解决为一个 Response 对象。这个对象是 API 的封装，可以通过它取得相应资源。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response&#x27;</span>, response)    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data&#x27;</span>, data)&#125;)</code></pre></div><img src="../images/【JavaScript】24_网络请求与远程资源/image-20230114194634842.png" alt="image-20230114194634842" style="zoom:33%;" /><img src="../images/【JavaScript】24_网络请求与远程资源/image-20230114194706800.png" alt="image-20230114194706800" style="zoom:33%;" /><h4 id="4-1-3-返回-Promise-对象"><a href="#4-1-3-返回-Promise-对象" class="headerlink" title="4.1.3 返回 Promise 对象"></a>4.1.3 返回 Promise 对象</h4><p>只要接收到了服务器返回的响应，就返回<strong>解决</strong>的 Promise 对象，解决值是一个 Response 实例；如果没收到服务器的响应，返回<strong>拒绝</strong>的 Promise 对象，拒绝原因是一个 TypeError 对象。</p><ul><li><p>请求成功（即状态码是200），会执行<strong>解决</strong>处理程序。即使请求失败（即状态码是404或500），也会执行<strong>解决</strong>处理程序。如果想区分这两种情况，应该判断 Response 实例的 ok 属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/bar&#x27;</span>)    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>); <span class="hljs-comment">// 200</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">ok</span>); <span class="hljs-comment">// true</span>&#125;);<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/does-not-exist&#x27;</span>)    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>); <span class="hljs-comment">// 404</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">ok</span>); <span class="hljs-comment">// false</span>&#125;);</code></pre></div></li><li><p>如果没有接收到服务器的响应（如请求超时、违反 CORS、无网络连接等），则会执行<strong>拒绝</strong>处理程序。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/no-response&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, error)&#125;)</code></pre></div></li></ul><h3 id="4-2-请求模式"><a href="#4-2-请求模式" class="headerlink" title="4.2 请求模式"></a>4.2 请求模式</h3><p>使用 init 对象参数，可以配置 fetch() 在请求体中发送各种序列化的数据。</p><h4 id="4-2-1-发送-JSON-数据"><a href="#4-2-1-发送-JSON-数据" class="headerlink" title="4.2.1 发送 JSON 数据"></a>4.2.1 发送 JSON 数据</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> payload = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;);<span class="hljs-keyword">let</span> jsonHeaders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(&#123;    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;);<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>, &#123;    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-comment">// 发送请求体时必须使用一种 HTTP 方法</span>    <span class="hljs-attr">body</span>: payload,    <span class="hljs-attr">headers</span>: jsonHeaders&#125;);</code></pre></div><h4 id="4-2-2-发送请求参数"><a href="#4-2-2-发送请求参数" class="headerlink" title="4.2.2 发送请求参数"></a>4.2.2 发送请求参数</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> payload = <span class="hljs-string">&#x27;foo=bar&amp;baz=qux&#x27;</span>;<span class="hljs-keyword">let</span> paramHeaders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(&#123;    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span>&#125;);<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/send-me-params&#x27;</span>, &#123;    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-comment">// 发送请求体时必须使用一种 HTTP 方法</span>    <span class="hljs-attr">body</span>: payload,    <span class="hljs-attr">headers</span>: paramHeaders&#125;);</code></pre></div><h4 id="4-2-3-发送文件"><a href="#4-2-3-发送文件" class="headerlink" title="4.2.3 发送文件"></a>4.2.3 发送文件</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> imageFormData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<span class="hljs-keyword">let</span> imageInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input[type=&#x27;file&#x27;]&quot;</span>);imageFormData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;image&#x27;</span>, imageInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]);<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/img-upload&#x27;</span>, &#123;    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,    <span class="hljs-attr">body</span>: imageFormData&#125;);</code></pre></div><h3 id="4-3-中断请求"><a href="#4-3-中断请求" class="headerlink" title="4.3 中断请求"></a>4.3 中断请求</h3><p>支持通过 <code>AbortController/AbortSignal</code> 对中断请求。调用 AbortController. abort() 会中断所有网络传输，特别适合希望停止传输大型负载的情况。中断进行中的 fetch() 请求会导致包含错误的拒绝。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> abortController = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>, &#123; <span class="hljs-attr">signal</span>: abortController.<span class="hljs-property">signal</span> &#125;)    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aborted!&#x27;</span>))<span class="hljs-comment">// 10 毫秒后中断请求</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> abortController.<span class="hljs-title function_">abort</span>(), <span class="hljs-number">10</span>)</code></pre></div><h3 id="4-4-Headers-对象"><a href="#4-4-Headers-对象" class="headerlink" title="4.4 Headers 对象"></a>4.4 Headers 对象</h3><p>Headers 对象是所有请求和响应头部的容器，存在于 Request 实例和 Response 实例中。Request 实例中的 Headers 对象可以通过 <code>Request.prototype.headers</code> 访问。Response 实例中的 Headers 对象可以通过 <code>Response.prototype.headers</code>访问。</p><h4 id="4-4-1-实例方法"><a href="#4-4-1-实例方法" class="headerlink" title="4.4.1 实例方法"></a>4.4.1 实例方法</h4><p>Headers 有与 Map 类型相似的 get()、set()、has() 和 delete() 等实例方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]])headers.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(headers.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))     <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(headers.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))     <span class="hljs-comment">// bar</span>headers.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(headers.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))     <span class="hljs-comment">// undefined</span></code></pre></div><p>不同于 Map，初始化 Headers 时可以传入一个对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;)</code></pre></div><p>一个 HTTP 头部可以有多个值，Headers 对象通过 append() 方法支持添加多个值。Headers 实例中还不存在的头部上调用 append() 方法相当于调用 set()。后续调用会以逗号为分隔符拼接多个值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>()headers.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)headers.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(headers.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))<span class="hljs-comment">// bar, baz</span></code></pre></div><h3 id="4-5-Request-对象"><a href="#4-5-Request-对象" class="headerlink" title="4.5 Request 对象"></a>4.5 Request 对象</h3><p>Request 对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式，即 json() 方法、text() 方法等。</p><h4 id="4-5-1-创建"><a href="#4-5-1-创建" class="headerlink" title="4.5.1 创建"></a>4.5.1 创建</h4><p>可以通过构造函数初始化 Request 对象。为此需要传入一个 input 参数，一般是 URL。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resquest</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>)</code></pre></div><p>Request 构造函数也接收第二个参数——一个 init 对象。这个 init 对象与前面介绍的 fetch() 的 init 对象一样。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/2&#x27;</span>,&#123;<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;DELETE&#x27;</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request)</code></pre></div><img src="../images/【JavaScript】24_网络请求与远程资源/image-20230114225647962.png" alt="image-20230114225647962" style="zoom:33%;" /><h4 id="4-5-2-克隆"><a href="#4-5-2-克隆" class="headerlink" title="4.5.2 克隆"></a>4.5.2 克隆</h4><p>有两种不同的方式来创建 Request 对象的副本：使用 Request 构造函数和使用实例的 clone() 方法。</p><p>注：只有 bodyUsed 属性为 false 的 Request 对象才能被克隆。不然会抛出 TypeError 异常。</p><h5 id="使用-Request-构造函数"><a href="#使用-Request-构造函数" class="headerlink" title="使用 Request 构造函数"></a><strong>使用 Request 构造函数</strong></h5><p>把已有的 Request 对象作为参数传入构造函数：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>)<span class="hljs-keyword">const</span> request2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(request1)</code></pre></div><p>也可以再传入一个 init 对象，来代替已有的配置：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/2&#x27;</span>)<span class="hljs-keyword">const</span> request2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(request1, &#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;DELETE&#x27;</span> &#125;)</code></pre></div><p>注，这种方式得到的不是一摸一样的副本：</p><ul><li>request1 的 bodyUsed 属性会被标记为 true。</li><li>如果源对象与创建的新对象不同源，则 referrer 属性会被清除。</li><li>如果源对象的 mode 为 navigate，则会被转换为 same-origin。</li></ul><h5 id="使用-clone-方法"><a href="#使用-clone-方法" class="headerlink" title="使用 clone() 方法"></a>使用 clone() 方法</h5><p>第二种克隆 Request 对象的方式是使用 clone()方法。这个方法会创建一模一样的副本，任何值都不会被覆盖， bodyUsed 属性也不会改变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/2&#x27;</span>)<span class="hljs-keyword">const</span> request2 = request1.<span class="hljs-title function_">clone</span>()</code></pre></div><h4 id="4-5-3-用法"><a href="#4-5-3-用法" class="headerlink" title="4.5.3 用法"></a>4.5.3 用法</h4><p>调用 fetch() 方法时，可以直接传入 Request 对象，也可以再传入 init 对象来覆盖  Request 对象中的配置。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts/2&#x27;</span>)<span class="hljs-title function_">fetch</span>(req, &#123;<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;DELETE&#x27;</span>&#125;)</code></pre></div><p>注意：fetch() 方法不能使用 bodyUsed 属性为 true 的 Request 对象。否则抛出 TypeError 异常。</p><h3 id="4-6-Response-对象"><a href="#4-6-Response-对象" class="headerlink" title="4.6 Response 对象"></a>4.6 Response 对象</h3><p>Response 对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使 用响应体的不同方式。</p><h4 id="4-6-1-获取"><a href="#4-6-1-获取" class="headerlink" title="4.6.1 获取"></a>4.6.1 获取</h4><p>fetch() 解决为一个成功的期约后，得到的值就是一个 Response 对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)&#125;)</code></pre></div><img src="../images/【JavaScript】24_网络请求与远程资源/image-20230114232638771.png" alt="image-20230114232638771" style="zoom:33%;" /><h4 id="4-6-2-克隆"><a href="#4-6-2-克隆" class="headerlink" title="4.6.2 克隆"></a>4.6.2 克隆</h4><p>注：只有 bodyUsed 属性为 false 的 Response 对象才能被克隆。不然会抛出 TypeError 异常。</p><p>使用 clone() 方法来克隆：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> c = response.<span class="hljs-title function_">clone</span>()    &#125;)</code></pre></div><h4 id="4-6-3-用法"><a href="#4-6-3-用法" class="headerlink" title="4.6.3 用法"></a>4.6.3 用法</h4><p>Response 对象包含一组只读属性：</p><p><img src="/../images/%E3%80%90JavaScript%E3%80%9124_%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B5%84%E6%BA%90/image-20230114232809848.png" alt="image-20230114232809848"></p><p>注：有响应体的 Response 对象只能读取一次。（不包含响应体的 Response 对象不受此限制。）</p><h3 id="4-7-Body-接口"><a href="#4-7-Body-接口" class="headerlink" title="4.7 Body 接口"></a>4.7 Body 接口</h3><p>Request 和 Response 都实现了 Body 接口。这个接口为两个类型提供了只读的 body 属性（实现为 ReadableStream）、只读的 bodyUsed 布尔值（表示 body 流是否已读）和一组方法，用于从流中读取内容并将结果转换为某种 JavaScript 对象类型。</p><h4 id="4-7-1-对于-Request-对象"><a href="#4-7-1-对于-Request-对象" class="headerlink" title="4.7.1 对于 Request 对象"></a>4.7.1 对于 Request 对象</h4><p>可以使用以下方法：</p><ul><li><p><code>Body.arrayBuffer()</code> </p><ul><li>返回解决一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>表示的请求主体的 promise.</li></ul></li><li><p><code>Body.blob()</code> </p><ul><li>返回解决一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a>表示的请求主体的 promise.</li></ul></li><li><p><code>Body.formData()</code></p><ul><li>返回解决一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData"><code>FormData</code></a>表示的请求主体的 promise.</li></ul></li><li><p><code>Body.json()</code> </p><ul><li>返回解决一个<code>JSON</code>表示的请求主体的 promise.</li></ul></li><li><p><code>Body.text()</code> </p><ul><li>返回解决一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>USVString</code></a>(文本) 表示的请求主体的 promise.</li></ul></li></ul><h4 id="4-7-2-对于-Response-对象"><a href="#4-7-2-对于-Response-对象" class="headerlink" title="4.7.2 对于 Response 对象"></a>4.7.2 对于 Response 对象</h4><ul><li><p><code>Body.arrayBuffer()</code> </p><ul><li>读取 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> 格式的 Promise 对象。</li></ul></li><li><p><code>Body.blob()</code> </p><ul><li>读取 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a> 格式的 Promise 对象。</li></ul></li><li><p><code>Body.formData()</code></p><ul><li>读取<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData"><code>FormData</code></a> 格式的 Promise 对象。</li></ul></li><li><p><code>Body.json()</code></p><ul><li>读取 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <code>JSON</code> 格式的 Promise 对象。</li></ul></li><li><p><code>Body.text()</code></p><ul><li>读取 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>USVString</code></a> 格式的 Promise 对象。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】23.JSON</title>
    <link href="/archives/a0f7377d.html"/>
    <url>/archives/a0f7377d.html</url>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JavaScript 对象简谱（JSON,JavaScript Object Notation）是 JavaScript 的严格子集。理解JSON 最关键的一点是要把它当成一种<strong>数据格式</strong>，而不是编程语言。JSON 属于JavaScript，它们只是拥有相同的语法而已。JSON 也不是只能在JavaScript 中使用，它是一种通用数据格式。很多语言都有解析和序列化 JSON 的内置能力。</p><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h2><p>JSON 语法支持表示3 种类型的值。 </p><ul><li>简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊<br>值 undefined 不可以。</li><li>对象：第一种复杂数据类型，对象表示有序键&#x2F;值对。每个值可以是简单值，也可以是复杂类型。</li><li>数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以<br>是任意类型，包括简单值、对象，甚至其他数组。</li></ul><p>JSON 没有变量、函数或对象实例的概念。JSON 的所有记号都只为表示结构化<strong>数据</strong>。</p><h3 id="1-1-简单值"><a href="#1-1-简单值" class="headerlink" title="1.1 简单值"></a>1.1 简单值</h3><p>最简单的JSON 可以是一个数值。例如，下面这个数值是有效的JSON：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-number">5</span></code></pre></div><p>下面这个字符串也是有效的JSON：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;Hello world!&quot;</span></code></pre></div><p>JavaScript 字符串与JSON 字符串的主要区别是，JSON 字符串必须使用<strong>双引号</strong>（单引号会导致语法错误）。</p><p>布尔值和 null 也是有效的 JSON 值：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-literal"><span class="hljs-keyword">true</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-literal"><span class="hljs-keyword">null</span></span></code></pre></div><h3 id="1-2-对象"><a href="#1-2-对象" class="headerlink" title="1.2 对象"></a>1.2 对象</h3><p>JSON 表示对象的语法是：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Nicholas&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">29</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>与 JavaScript 对象字面量相比，JSON 主要有两处不同。首先，没有变量声明（JSON 中没有变量）。其次，最后没有分号（不需要，因为不是 JavaScript 语句）。同样，用引号将属性名包围起来才是有效的 JSON。属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象，比如：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Nicholas&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">29</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Merrimack College&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;North Andover, MA&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>与 JavaScript 不同，JSON 中的<strong>对象属性名</strong>必须始终带<strong>双引号</strong>。</p><h3 id="1-3-数组"><a href="#1-3-数组" class="headerlink" title="1.3 数组"></a>1.3 数组</h3><p>JSON 的第二种复杂数据类型是数组。数组在 JSON 中使用 JavaScript 的数组字面量形式表示。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-number">25</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;hi&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">]</span></code></pre></div><p>对象和数组通常会作为JSON 数组的顶级结构（尽管不是必需的），以便创建大型复杂数据结构。</p><h2 id="2-序列化和反序列化"><a href="#2-序列化和反序列化" class="headerlink" title="2 序列化和反序列化"></a>2 序列化和反序列化</h2><h3 id="2-1-JSON-对象"><a href="#2-1-JSON-对象" class="headerlink" title="2.1 JSON 对象"></a>2.1 JSON 对象</h3><p>JSON 对象有两个方法：stringify() 和 parse()。在简单的情况下，这两个方法分别可以将 JavaScript 序列化为 JSON 字符串，以及将 JSON 解析（反序列化）为原生 JavaScript 值。例如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>,    <span class="hljs-attr">authors</span>: [        <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>,        <span class="hljs-string">&quot;Matt Frisbie&quot;</span>    ],    <span class="hljs-attr">edition</span>: <span class="hljs-number">4</span>,    <span class="hljs-attr">year</span>: <span class="hljs-number">2017</span>&#125;;<span class="hljs-keyword">let</span> jsonText = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(book);</code></pre></div><p>这个例子使用 JSON.stringify() 把一个 JavaScript 对象序列化为一个 JSON 字符串，保存在变量 jsonText 中。默认情况下，JSON.stringify() 会输出<strong>不包含空格或缩进</strong>的 JSON 字符串，因此 jsonText 的值是这样的：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Professional JavaScript&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;authors&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;Matt Frisbie&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;edition&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;year&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2017</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>在序列化 JavaScript 对象时，所有<strong>函数和原型成员</strong>都会有意地在结果中<strong>省略</strong>。此外，值为 <strong>undefined</strong><br>的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表示。</p><p>JSON 字符串可以直接传给 JSON.parse()，然后得到相应的 JavaScript 值。比如，可以使用以下代码创建与 book 对象类似的新对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bookCopy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonText);</code></pre></div><p>注意，book 和 bookCopy 是两个完全不同的对象，没有任何关系。但是它们拥有相同的属性和值。</p><p>如果给 JSON.parse() 传入的 JSON 字符串无效，则会导致抛出错误。</p><h3 id="2-2-JSON-stringify-序列化"><a href="#2-2-JSON-stringify-序列化" class="headerlink" title="2.2 JSON.stringify() 序列化"></a>2.2 JSON.stringify() 序列化</h3><p>JSON.stringify() 方法除了要序列化的对象，还可以接收两个参数。这两个参数可以用于指定其他序列化 JavaScript 对象的方式。第一个参数是<strong>过滤器</strong>，可以是数组或函数；第二个参数是用于<strong>缩进</strong>结果JSON 字符串的选项。</p><h4 id="2-2-1-过滤结果"><a href="#2-2-1-过滤结果" class="headerlink" title="2.2.1 过滤结果"></a>2.2.1 过滤结果</h4><p>如果第二个参数是一个<strong>数组</strong>，那么 JSON.stringify() 返回的结果只会包含该数组中列出的对象属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>,    <span class="hljs-attr">authors</span>: [        <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>,        <span class="hljs-string">&quot;Matt Frisbie&quot;</span>    ],    <span class="hljs-attr">edition</span>: <span class="hljs-number">4</span>,    <span class="hljs-attr">year</span>: <span class="hljs-number">2017</span>&#125;;<span class="hljs-keyword">let</span> jsonText = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(book, [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;edition&quot;</span>]);</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Professional JavaScript&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;edition&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">4</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>如果第二个参数是一个<strong>函数</strong>（称为 replacer）。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值不属于某个键&#x2F;值对时会是空字符串。</p><p>为了改变对象的序列化，返回的值就是相应 key 应该包含的结果。注意，返回 undefined 会导致属性被忽略。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>,  <span class="hljs-attr">authors</span>: [<span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>, <span class="hljs-string">&quot;Matt Frisbie&quot;</span>],  <span class="hljs-attr">edition</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">year</span>: <span class="hljs-number">2017</span>,&#125;;<span class="hljs-keyword">let</span> jsonText = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(book, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> &#123;  <span class="hljs-keyword">switch</span> (key) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;authors&quot;</span>:      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;,&quot;</span>);    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;year&quot;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-number">5000</span>;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;edition&quot;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">return</span> value;<span class="hljs-comment">// 提供默认返回值</span>  &#125;&#125;);</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Professional JavaScript&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;authors&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Nicholas C. Zakas,Matt Frisbie&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;year&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">5000</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>最后一定要提供<strong>默认返回值</strong>，以便返回其他属性传入的值。</p><h4 id="2-2-2-字符串缩进"><a href="#2-2-2-字符串缩进" class="headerlink" title="2.2.2 字符串缩进"></a>2.2.2 字符串缩进</h4><p>JSON.stringify() 方法的第三个参数控制缩进和空格。</p><p>在这个参数是<strong>数值</strong>时，表示每一级缩进的空格数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>,    <span class="hljs-attr">authors</span>: [        <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>,        <span class="hljs-string">&quot;Matt Frisbie&quot;</span>    ],    <span class="hljs-attr">edition</span>: <span class="hljs-number">4</span>,    <span class="hljs-attr">year</span>: <span class="hljs-number">2017</span>&#125;;<span class="hljs-keyword">let</span> jsonText = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(book, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Professional JavaScript&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;authors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-string">&quot;Matt Frisbie&quot;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;edition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;year&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2017</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>注意，除了缩进，JSON.stringify() 方法还为方便阅读插入了换行符。这个行为对于所有有效的缩进参数都会发生。</p><p>如果缩进参数是一个<strong>字符串</strong>而非数值，那么 JSON 字符串中就会使用这个字符串而不是空格来缩进。使用字符串，也可以将缩进字符设置为 Tab 或任意字符，如两个连字符：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> jsonText = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(book, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;--&quot;</span> );</code></pre></div><p>这样，jsonText 的值会变成如下格式：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>--<span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Professional JavaScript&quot;</span><span class="hljs-punctuation">,</span>--<span class="hljs-attr">&quot;authors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>----<span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span><span class="hljs-punctuation">,</span>----<span class="hljs-string">&quot;Matt Frisbie&quot;</span>--<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>--<span class="hljs-attr">&quot;edition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span>--<span class="hljs-attr">&quot;year&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2017</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>使用字符串时有 10 个字符的长度限制。如果字符串长度超过 10，则会在第 10 个字符处截断。</p><h4 id="2-2-3-toJSON-方法"><a href="#2-2-3-toJSON-方法" class="headerlink" title="2.2.3 toJSON() 方法"></a>2.2.3 toJSON() 方法</h4><p>有时候，对象需要在 JSON.stringify() 之上自定义 JSON 序列化。此时，可以在要序列化的对象中添加 toJSON() 方法，序列化时会基于这个方法返回适当的 JSON 表示。事实上，原生 Date 对象就有一个 toJSON() 方法，能够自动将 JavaScript 的 Date 对象转换为 ISO 8601 日期字符串（本质上与在 Date 对象上调用 toISOString() 方法一样）。</p><p>下面的对象为自定义序列化而添加了一个 toJSON() 方法：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>,    <span class="hljs-attr">authors</span>: [        <span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>,        <span class="hljs-string">&quot;Matt Frisbie&quot;</span>    ],    <span class="hljs-attr">edition</span>: <span class="hljs-number">4</span>,    <span class="hljs-attr">year</span>: <span class="hljs-number">2017</span>,    <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>;    &#125;&#125;;<span class="hljs-keyword">let</span> jsonText = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(book);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonText);</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;Professional JavaScript&quot;</span></code></pre></div><p>这里 book 对象中定义的 toJSON() 方法简单地返回了图书的书名（this.title）。与 Date 对象类似，这个对象会被序列化为简单字符串而非对象。toJSON() 方法可以返回任意<strong>序列化值</strong>，都可以起到相应的作用。如果对象被嵌入在另一个对象中，返回 undefined 会导致值变成 null；或者如果是顶级对象，则本身就是 undefined。注意，箭头函数不能用来定义 toJSON() 方法。主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适。</p><p>toJSON() 方法可以与过滤函数一起使用，因此理解不同序列化流程的顺序非常重要。在把对象传给 JSON.stringify()时会执行如下步骤。</p><p>(1) 如果可以获取实际的值，则调用 toJSON() 方法获取实际的值，否则使用默认的序列化。</p><p>(2) 如果提供了第二个参数，则应用过滤。传入过滤函数的值就是第 (1) 步返回的值。</p><p>(3) 第 (2) 步返回的每个值都会相应地进行序列化。</p><p>(4) 如果提供了第三个参数，则相应地进行缩进。</p><p>理解这个顺序有助于决定是创建 toJSON() 方法，还是使用过滤函数，抑或是两者都用。</p><h3 id="2-3-JSON-parse-反序列化"><a href="#2-3-JSON-parse-反序列化" class="headerlink" title="2.3 JSON.parse() 反序列化"></a>2.3 JSON.parse() 反序列化</h3><p>JSON.parse() 方法也可以接收一个额外的参数，这个函数会针对每个键&#x2F;值对都调用一次。为区别于传给JSON.stringify() 的起过滤作用的替代函数（replacer），这个函数被称为还原函数（reviver）。</p><p>实际上它们的格式完全一样，即还原函数也接收两个参数，属性名（key）和属性值（value），另外也需要返回值。如果还原函数返回 undefined，则结果中就会<strong>删除</strong>相应的键。如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。还原函数经常被用于把日期字符串转换为 Date 对象。例如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Professional JavaScript&quot;</span>,  <span class="hljs-attr">authors</span>: [<span class="hljs-string">&quot;Nicholas C. Zakas&quot;</span>, <span class="hljs-string">&quot;Matt Frisbie&quot;</span>],  <span class="hljs-attr">edition</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">year</span>: <span class="hljs-number">2017</span>,  <span class="hljs-attr">releaseDate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2017</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1</span>),&#125;;<span class="hljs-keyword">let</span> jsonText = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(book);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonText);<span class="hljs-comment">// &#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],&quot;edition&quot;:4,&quot;year&quot;:2017,&quot;releaseDate&quot;:&quot;2017-11-30T16:00:00.000Z&quot;&#125;</span><span class="hljs-keyword">let</span> bookCopy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonText, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span>  key == <span class="hljs-string">&quot;releaseDate&quot;</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(value) : value);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bookCopy.<span class="hljs-property">releaseDate</span>.<span class="hljs-title function_">getFullYear</span>());  <span class="hljs-comment">// 2017</span></code></pre></div><p>以上代码在 book 对象中增加了 releaseDate 属性，是一个 Date 对象。这个对象在被序列化为 JSON 字符串后，又被重新解析为一个对象 bookCopy。这里的还原函数会查找”releaseDate”键，如果找到就会根据它的日期字符串创建新的 Date 对象。得到的 bookCopy.releaseDate 属性又变回了 Date 对象，因此可以调用其 getFullYear() 方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】22.模块</title>
    <link href="/archives/871431d2.html"/>
    <url>/archives/871431d2.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-模块模式"><a href="#1-模块模式" class="headerlink" title="1 模块模式"></a>1 模块模式</h2><p>在 ECMAScript 2015 模块规范出现之前，使用模块模式的库必须基于 JavaScript 语法特性<strong>伪造</strong>出类似模块的行为。 </p><p><strong>模块模式</strong>的思想：把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入哪些外部代码。这些思想是 JavaScript <strong>模块系统</strong>的基础。</p><h3 id="1-1-模块标识符"><a href="#1-1-模块标识符" class="headerlink" title="1.1 模块标识符"></a>1.1 模块标识符</h3><p>每个模块都有一个可用于引用它的标识符。模块的标识符可用于检索模块。完善的模块系统不会存在标识冲突的问题，任何模块都应该无歧义的引用其它模块。</p><h3 id="1-2-模块依赖"><a href="#1-2-模块依赖" class="headerlink" title="1.2 模块依赖"></a>1.2 模块依赖</h3><p>模块系统的核心是管理依赖。本地模块为了正常运行可能声明一组所需的外部模块。模块系统应该检索这些依赖以保证本地模块的运行。</p><h3 id="1-3-模块加载"><a href="#1-3-模块加载" class="headerlink" title="1.3 模块加载"></a>1.3 模块加载</h3><p>当一个外部模块被指定为依赖时，本地模块希望在执行前，依赖就已经准备好并已初始化。</p><h3 id="1-4-入口"><a href="#1-4-入口" class="headerlink" title="1.4 入口"></a>1.4 入口</h3><p>因为 JavaScript 是顺序执行的，因此相互依赖的模块必须指定一个模块作为入口，也就是代码的起点。</p><h3 id="1-5-异步依赖"><a href="#1-5-异步依赖" class="headerlink" title="1.5 异步依赖"></a>1.5 异步依赖</h3><p>因为 JavaScript 可以异步执行，所以可以按需加载。可以让 JavaScript 在必要的时候加载模块，并在模块记载完成后提供回调。</p><h3 id="1-6-动态依赖"><a href="#1-6-动态依赖" class="headerlink" title="1.6 动态依赖"></a>1.6 动态依赖</h3><p>有些模块系统允许开发者在程序中动态添加模块。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(...)&#123;<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;...&#x27;</span>)&#125;</code></pre></div><h3 id="1-7-静态分析"><a href="#1-7-静态分析" class="headerlink" title="1.7 静态分析"></a>1.7 静态分析</h3><p>发送到浏览器的代码经常会被静态分析，分析工具会检查代码结构并推断其行为。对静态分析友好的代码，可以让模块打包系统更容易将代码分析为较少的文件。复杂的模块行为，比如动态依赖，会导致静态分析更困难。</p><h3 id="1-8-循环依赖"><a href="#1-8-循环依赖" class="headerlink" title="1.8 循环依赖"></a>1.8 循环依赖</h3><p>在有循环依赖的模块系统中，模块的加载顺序可能出人意料。不过只要恰当封装模块，加载顺序不会影响程序的运行。</p><h2 id="2-ES6-之前的模块加载器"><a href="#2-ES6-之前的模块加载器" class="headerlink" title="2 ES6 之前的模块加载器"></a>2 ES6 之前的模块加载器</h2><p>在 ES6 原生支持模块之前，使用模块的 JavaScript 代码希望使用默认没有的语言特性。因此需要按照符合某种规范的<strong>模块语法</strong>来编写代码。另外还需要单独的<strong>模块工具</strong>将模块语法与运行时连接起来。 这里的模块语法和模块工具通常需要额外加载库或者在构建时完成预处理。</p><h3 id="2-1-CommonJS（同步模块）"><a href="#2-1-CommonJS（同步模块）" class="headerlink" title="2.1 CommonJS（同步模块）"></a>2.1 CommonJS（同步模块）</h3><h4 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1 简介"></a>2.1.1 简介</h4><p>CommonJS 规范概述了<strong>同步声明依赖</strong>的模块定义。这个规范主要用于在<strong>服务端</strong>实现模块化代码，也可以用于定义在浏览器中使用的模块依赖。CommonJS 模块语法<strong>不能</strong>在浏览器中直接运行。</p><blockquote><p>Node.js 使用了轻微修改版本的 CommonJS。</p></blockquote><h4 id="2-1-2-语法"><a href="#2-1-2-语法" class="headerlink" title="2.1.2 语法"></a>2.1.2 语法</h4><p>CommonJS 规范定义使用 require() 指定依赖，使用 module.exports 对象定义自己的公共 API。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> moduleB = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./moduleB&quot;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">stuff</span>: moduleB.<span class="hljs-title function_">doStuff</span>()&#125;;</code></pre></div><blockquote><p>Node.js 中模块标识符可能指向文件，也可能指向含有 index.js 文件的目录。</p></blockquote><h4 id="2-1-3-特点"><a href="#2-1-3-特点" class="headerlink" title="2.1.3 特点"></a>2.1.3 特点</h4><p>CommonJS 规范的特点：</p><ul><li>无论一个模块在 require() 中被引用多少次，模块永远是单例，只会被加载一次。</li><li>模块第一次加载后会被缓存，后续加载会取得缓存的模块。</li><li>模块加载顺序由<strong>依赖图</strong>决定。</li><li>模块加载是同步操作。</li><li>模块<strong>不会</strong>指定自己的标识符，它们的标识符由其在模块文件层级中的位置决定。指向模块定义的路径可能引用一个目录，也可能是一个 JavaScript 文件。</li></ul><h4 id="2-1-4-用途"><a href="#2-1-4-用途" class="headerlink" title="2.1.4 用途"></a>2.1.4 用途</h4><p>模块的一个主要用途是托管类的定义。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// moduleA</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = A<span class="hljs-comment">// B</span><span class="hljs-keyword">var</span> A = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./moduleA&#x27;</span>)<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()</code></pre></div><p>也可以将类实例作为导出值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()</code></pre></div><h4 id="2-1-5-打包"><a href="#2-1-5-打包" class="headerlink" title="2.1.5 打包"></a>2.1.5 打包</h4><p>CommonJS 依赖几个全局属性如 require 和 module.exports。如果想在浏览器中直接使用 CommonJS 模块，就要对其非原生模块语法进行转换。模块级代码也需要和浏览器进行封装隔离，因为没有封装的 CommonJS 代码在浏览器中会创建全局变量，不符合模块模式。</p><p>常见解决方法是对模块文件进行打包，将模块代码封装在函数闭包中，最终只提供一个文件。</p><h3 id="2-2-AMD（异步模块定义）"><a href="#2-2-AMD（异步模块定义）" class="headerlink" title="2.2 AMD（异步模块定义）"></a>2.2 AMD（异步模块定义）</h3><h4 id="2-2-1-简介"><a href="#2-2-1-简介" class="headerlink" title="2.2.1 简介"></a>2.2.1 简介</h4><p>CommonJS 以服务端为目标环境，而 AMD 以浏览器为目标执行环境。AMD 的一般策略是让模块声明自己的依赖，而运行在浏览器中的模块系统按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块。</p><p>AMD 模块实现的核心是用函数包装模块的定义。这样可以防止声明全局变量，并允许加载器库控制合适加载模块。包装函数便于模块代码的移植，因为包装函数内部所有模块代码使用的都是原生 JavaScript 结构。</p><h4 id="2-2-2-语法"><a href="#2-2-2-语法" class="headerlink" title="2.2.2 语法"></a>2.2.2 语法</h4><p>包装模块的函数是全局 define 的参数，它由 AMD 加载库的实现定义。AMD 模块可以使用字符串标识符指定自己的依赖，而 AMD 加载器会在所有依赖模块加载完毕后立即调用模块工厂函数。与 CommonJS 不同，AMD 支持可选的为模块指定字符串标识符。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ID 为&#x27;moduleA&#x27;的模块定义。moduleA 依赖moduleB，</span><span class="hljs-comment">// moduleB 会异步加载</span><span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;moduleA&#x27;</span>, [<span class="hljs-string">&#x27;moduleB&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">moduleB</span>) &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">stuff</span>: moduleB.<span class="hljs-title function_">doStuff</span>()  &#125;;&#125;);</code></pre></div><p>AMD 也支持 require 和 exports 对象，通过它们可以在 AMD 模块工厂函数内部定义 CommonJS 风格的模块。</p><h3 id="2-3-UMD（通用模块定义）"><a href="#2-3-UMD（通用模块定义）" class="headerlink" title="2.3  UMD（通用模块定义）"></a>2.3  UMD（通用模块定义）</h3><p>为了统一 CommonJS 和 AMD 生态系统，通用模块定义（UMD）规范应运而生。UMD 可以创建这两个系统都可以使用的模块代码。</p><h2 id="3-ES6-模块"><a href="#3-ES6-模块" class="headerlink" title="3 ES6 模块"></a>3 ES6 模块</h2><p>ES6 引入了模块规范，全方位简化了之前的模块加载器。ES6 模块是 AMD 和 CommonJS 的集大成者。</p><h3 id="3-1-模块标签及定义"><a href="#3-1-模块标签及定义" class="headerlink" title="3.1 模块标签及定义"></a>3.1 模块标签及定义</h3><p>ECMAScript 6 模块是作为一整块 JavaScript 代码而存在的。带有 <code>type=&quot;module&quot;</code> 属性的 <code>&lt;script&gt;</code>标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。模块可以嵌入在网页中，也可以作为外部文件引入：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-comment">// 模块代码</span></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>即使与常规 JavaScript 文件处理方式不同，JavaScript 模块文件也没有专门的<strong>内容类型</strong>（MIME 类型）。</p><p>与传统脚本不同，所有模块都会像<code>&lt;script defer&gt;</code>加载的脚本一样按<strong>顺序</strong>执行。解析到 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签后会立即下载模块文件，但执行会延迟到文档解析完成。无论对嵌入的模块代码，还是引入的外部模块文件，都是这样。<code>&lt;script type=&quot;module&quot;&gt;</code> 在页面中出现的顺序就是它们执行的顺序。与 <code>&lt;script defer&gt;</code> 一样，修改模块标签的位置，无论是在 <code>&lt;head&gt;</code>还是在 <code>&lt;body&gt;</code>中，只会影响文件什么时候加载，而不会影响模块什么时候加载。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;B&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;C&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>// 执行结果：C A B</code></pre></div><p>也可以给模块标签添加 async 属性。这样影响就是双重的：不仅模块执行顺序不再与<code>&lt;script&gt;</code>标签在页面中的顺序绑定，模块也不会等待文档完成解析才执行。不过，入口模块仍必须等待其依赖加载完成。</p><p>与<code>&lt;script type=&quot;module&quot;&gt;</code>标签关联的 ES6 模块被认为是模块图中的入口模块。一个页面上有多少个入口模块没有限制，重复加载同一个模块也没有限制。同一个模块无论在一个页面中被加载多少次，也不管它是如何加载的，实际上都只会加载一次。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><span class="language-xml"><span class="language-handlebars">import &#x27;./moduleA.js&#x27;</span></span><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">    </span></span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span></span></span></span><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./moduleA.js&#x27;</span></span></span></span></span></span><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">&lt;script&gt;</span></span></span></span></span><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">    </span></span></span></span></span><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./moduleA.js&quot;</span>&gt;</span></span></span></span></span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./moduleA.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>// moduleA 只会被加载一次</code></pre></div><p>嵌入的模块定义代码不能使用 import 加载到其他模块。只有通过外部文件加载的模块才可以使用 import 加载。因此，嵌入模块只适合作为入口模块。</p><h3 id="3-2-模块加载"><a href="#3-2-模块加载" class="headerlink" title="3.2 模块加载"></a>3.2 模块加载</h3><p>ECMAScript 6 模块的独特之处在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。有些浏览器还没有原生支持 ES6 模块，因此可能还需要第三方工具。事实上，很多时候使用第三方工具可能会更方便。</p><p>完全支持 ECMAScript 6 模块的浏览器可以从顶级模块加载整个依赖图，且是异步完成的。浏览器会解析入口模块，确定依赖，并发送对依赖模块的请求。这些文件通过网络返回后，浏览器就会解析它们的内容，确定它们的依赖，如果这些二级依赖还没有加载，则会发送更多请求。这个异步递归加载过程会持续到整个应用程序的依赖图都解析完成。解析完依赖图，应用程序就可以正式加载模块了。</p><p>这个过程与 AMD 风格的模块加载非常相似。模块文件按需加载，且后续模块的请求会因为每个依赖模块的网络延迟而同步延迟。即，如果 moduleA 依赖 moduleB，moduleB 依赖 moduleC。浏览器在对 moduleB 的请求完成之前并不知道要请求 moduleC。这种加载方式效率很高，也不需要外部工具，但加载大型应用程序的深度依赖图可能要花费很长时间。</p><h3 id="3-3-模块行为"><a href="#3-3-模块行为" class="headerlink" title="3.3 模块行为"></a>3.3 模块行为</h3><p>ECMAScript 6 模块借用了 CommonJS 和 AMD 的很多优秀特性。</p><ul><li><p>模块代码只在加载后执行。</p></li><li><p>模块只能加载一次。</p></li><li><p>模块是单例。</p></li><li><p>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。</p></li><li><p>模块可以请求加载其他模块。</p></li><li><p>支持循环依赖。</p></li></ul><p>ES6 模块系统也增加了一些<strong>新行为</strong>。</p><ul><li>ES6 模块默认在严格模式下执行。</li><li>ES6 模块不共享全局命名空间。</li><li>模块顶级 this 值是 undefined（常规脚本中是 window）。</li><li>模块中的 var 声明不会添加到 window 对象。</li><li>ES6 模块是异步加载和执行的。</li></ul><p>浏览器运行时在知道应该把某个文件当成模块时，会有条件地按照上述 ECMAScript 6 模块行为来施加限制。与<code>&lt;script type=&quot;module&quot;&gt;</code>关联或者通过 import 语句加载的 JavaScript 文件会被认定为模块。</p><h3 id="3-4-模块导出"><a href="#3-4-模块导出" class="headerlink" title="3.4 模块导出"></a>3.4 模块导出</h3><p>ES6 模块支持两种导出：<strong>命名导出</strong>和<strong>默认导出</strong>。</p><p>使用 export 关键字导出模块。导出语句必须在模块<strong>顶级</strong>，不能嵌套在某个块中：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 允许</span><span class="hljs-keyword">export</span> ...<span class="hljs-comment">// 不允许</span><span class="hljs-keyword">if</span> (condition) &#123;<span class="hljs-keyword">export</span> ...&#125;</code></pre></div><p>导出值对模块内部 JavaScript 的执行没有直接影响，因此 export 语句与导出值的相对位置或者 export 关键字在模块中出现的顺序没有限制。export 语句甚至可以出现在它要导出的值之前：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 允许</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> &#123; foo &#125;;<span class="hljs-comment">// 允许</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-comment">// 允许，但应该避免</span><span class="hljs-keyword">export</span> &#123; foo &#125;;<span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;</code></pre></div><h4 id="3-4-1-命名导出"><a href="#3-4-1-命名导出" class="headerlink" title="3.4.1 命名导出"></a>3.4.1 命名导出</h4><p><strong>命名导出</strong>（named export）就好像<strong>模块是被导出值的容器</strong>。<strong>行内命名导出</strong>，顾名思义，可以在同一行执行变量声明。下面展示了一个声明变量同时又导出变量的例子。外部模块可以导入这个模块，而 foo 将成为这个导入模块的一个属性：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js 导出</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-comment">// b.js 导入，必须和导出的命名一致</span><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo) <span class="hljs-comment">// foo</span></code></pre></div><p>变量声明跟导出可以不在一行。可以在 export 子句中执行声明并将标识符导出到模块的其他地方：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js 导出</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> &#123; foo &#125;;<span class="hljs-comment">// b.js 导入</span><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo) <span class="hljs-comment">// foo</span></code></pre></div><p>导出时也可以提供别名，别名必须在 export 子句的大括号语法中指定。因此，声明值、导出值和为导出值提供别名不能在一行完成。在下面的例子中，导入这个模块的外部模块可以使用 myFoo 访问导出的值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js 导出</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> myFoo &#125;;<span class="hljs-comment">// b.js 导入</span><span class="hljs-keyword">import</span> &#123;myFoo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myFoo)<span class="hljs-comment">// foo</span></code></pre></div><p>因为 ES6 命名导出可以将模块作为容器，所以可以在一个模块中声明多个命名导出。导出的值可以在导出语句中声明，也可以在导出之前声明：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js 导出</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bar = <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;baz&#x27;</span>;<span class="hljs-comment">// b.js 导入</span><span class="hljs-keyword">import</span> &#123;foo, bar, baz&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo, bar, baz)<span class="hljs-comment">// foo, bar, baz</span></code></pre></div><p>考虑到导出多个值是常见的操作，ES6 模块也支持对导出声明分组，可以同时为部分或全部导出值指定别名：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js 导出</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">const</span> bar = <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;baz&#x27;</span>;<span class="hljs-keyword">export</span> &#123; foo, bar <span class="hljs-keyword">as</span> myBar, baz &#125;;<span class="hljs-comment">// b.js 导入</span><span class="hljs-keyword">import</span> &#123;foo, myBar, baz&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo, myBar, baz) <span class="hljs-comment">// foo, bar, baz</span></code></pre></div><h4 id="3-4-2-默认导出"><a href="#3-4-2-默认导出" class="headerlink" title="3.4.2 默认导出"></a>3.4.2 默认导出</h4><p><strong>默认导出</strong>（default export）就好像<strong>模块与被导出的值是一回事</strong>。默认导出使用 default 关键字将一个值声明为默认导出，<strong>每个模块只能有一个默认导出</strong>。重复的默认导出会导致 SyntaxError。下面的例子定义了一个默认导出，外部模块可以导入这个模块，而这个模块本身就是 foo 的值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js 导出</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo;<span class="hljs-comment">// b.js 导入，可以和导出的值命名不一致</span><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">// foo</span></code></pre></div><p>另外，ES6 模块系统会识别作为别名提供的 default 关键字。此时，虽然对应的值是使用命名语法导出的，实际上则会成为默认导出：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;; <span class="hljs-comment">// 等同于export default foo;</span></code></pre></div><h4 id="3-4-3-同时导出"><a href="#3-4-3-同时导出" class="headerlink" title="3.4.3 同时导出"></a>3.4.3 同时导出</h4><p>因为命名导出和默认导出不会冲突，所以ES6 支持在一个模块中同时定义这两种导出：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js 导出</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">const</span> bar = <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-keyword">export</span> &#123; bar &#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo;<span class="hljs-comment">// b.js 导入</span><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar, a) <span class="hljs-comment">// bar foo</span></code></pre></div><p>这两个 export 语句可以组合为一行：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">const</span> bar = <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>, bar &#125;;</code></pre></div><h4 id="3-4-4-export-语句规范"><a href="#3-4-4-export-语句规范" class="headerlink" title="3.4.4 export 语句规范"></a>3.4.4 export 语句规范</h4><p>ES6 规范对不同形式的 export 语句中可以使用什么不可以使用什么规定了限制。某些形式允许声明和赋值，某些形式只允许表达式，而某些形式则只允许简单标识符。注意，有的形式使用了分号，有的则没有：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 命名行内导出</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;baz&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>, bar = <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;&#125;<span class="hljs-comment">// 命名子句导出</span><span class="hljs-keyword">export</span> &#123; foo &#125;;<span class="hljs-keyword">export</span> &#123; foo, bar &#125;;<span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> myFoo, bar &#125;;<span class="hljs-comment">// 默认导出</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">123</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> /[a-z]*/;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;;<span class="hljs-keyword">export</span> &#123; foo, bar <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>*() &#123;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> &#123;&#125;<span class="hljs-comment">// 会导致错误的不同形式：</span><span class="hljs-comment">// 行内默认导出中不能出现变量声明</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-comment">// 只有标识符可以出现在 export 子句中</span><span class="hljs-keyword">export</span> &#123; <span class="hljs-number">123</span> <span class="hljs-keyword">as</span> foo &#125;<span class="hljs-comment">// 别名只能在export 子句中出现</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-keyword">as</span> myFoo;</code></pre></div><blockquote><p>注意：什么可以或不可以与 export 关键字出现在同一行可能很难记住。一般来说，声明、赋值和导出标识符最好分开。这样就不容易搞错了，同时也可以让 export 语句集中在一块。</p></blockquote><h3 id="3-5-模块导入"><a href="#3-5-模块导入" class="headerlink" title="3.5 模块导入"></a>3.5 模块导入</h3><p>模块可以通过使用 import 关键字使用其他模块导出的值。与 export 类似，import 必须出现在模块的<strong>顶级</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 允许</span><span class="hljs-keyword">import</span> ...<span class="hljs-comment">// 不允许</span><span class="hljs-keyword">if</span> (condition) &#123;<span class="hljs-keyword">import</span> ...&#125;</code></pre></div><p>import 语句被提升到模块顶部。因此，与 export 关键字类似，import 语句与使用导入值的语句的相对位置并不重要。不过，还是推荐把导入语句放在模块顶部。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 允许</span><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fooModule.js&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// &#x27;foo&#x27;</span><span class="hljs-comment">// 允许，但应该避免</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// &#x27;foo&#x27;</span><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fooModule.js&#x27;</span>;</code></pre></div><p>注意：</p><ol><li><p>模块标识符可以是相对于当前模块的相对路径，也可以是指向模块文件的绝对路径。它必须是纯字符串，不能是动态计算的结果。例如，不能是拼接的字符串。</p></li><li><p>如果在浏览器中通过标识符原生加载模块，则文件必须带有 .js 扩展名，不然可能无法正确解析。不过，如果是通过构建工具或第三方模块加载器打包或解析的 ES6 模块，则可能不需要包含文件扩展名。</p></li><li><p>不是必须通过导出的成员才能导入模块。如果不需要模块的特定导出，但仍想加载和执行模块以利用其副作用，可以只通过路径加载它：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// foo.js</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// b.js</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;<span class="hljs-comment">// foo</span></code></pre></div></li><li><p>导入对模块而言是只读的，实际上相当于 const 声明的变量。在使用执行批量导入时，赋值给别名的命名导出就好像使用 Object.freeze() 冻结过一样。直接修改导出的值是不可能的，但可以修改导出对象的属性。</p><p>同样，也不能给导出的集合添加或删除导出的属性。要修改导出的值，必须使用有内部变量和属性访问权限的导出方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> foo, * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <span class="hljs-comment">// 错误</span><span class="hljs-title class_">Foo</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;foo&#x27;</span>; <span class="hljs-comment">// 错误</span>foo.<span class="hljs-property">bar</span> = <span class="hljs-string">&#x27;bar&#x27;</span>; <span class="hljs-comment">// 允许</span></code></pre></div></li></ol><p>命名导出和默认导出的区别也反映在它们的导入上。</p><h4 id="3-5-1-命名导入"><a href="#3-5-1-命名导入" class="headerlink" title="3.5.1 命名导入"></a>3.5.1 命名导入</h4><p>命名导出可以使用<strong>批量</strong>获取并赋值给保存导出集合的别名，而无须列出每个标识符：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// foo.js 导出</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>, bar = <span class="hljs-string">&#x27;bar&#x27;</span>, baz = <span class="hljs-string">&#x27;baz&#x27;</span>;<span class="hljs-keyword">export</span> &#123; foo, bar, baz &#125;<span class="hljs-comment">// bar.js 导入</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">foo</span>); <span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">bar</span>); <span class="hljs-comment">// bar</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">baz</span>); <span class="hljs-comment">// baz</span></code></pre></div><p>要导入时<strong>指定</strong>，需要把标识符放在 import 子句中。使用 import 子句可以为导入的值指定别名：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// foo.js 命名导出</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>, bar = <span class="hljs-string">&#x27;bar&#x27;</span>, baz = <span class="hljs-string">&#x27;baz&#x27;</span>;<span class="hljs-keyword">export</span> &#123; foo, bar, baz &#125;<span class="hljs-comment">// bar.js 导入</span><span class="hljs-keyword">import</span> &#123; foo, bar, baz <span class="hljs-keyword">as</span> myBaz &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// bar</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myBaz); <span class="hljs-comment">// baz</span></code></pre></div><h4 id="3-5-2-默认导入"><a href="#3-5-2-默认导入" class="headerlink" title="3.5.2 默认导入"></a>3.5.2 默认导入</h4><p>默认导出就好像整个模块就是导出的值一样。可以使用 default 关键字并提供别名来导入。也可以不使用大括号，此时指定的标识符就是默认导出的别名：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// foo.js 默认导出</span><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo<span class="hljs-comment">// 等效</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;<span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;</code></pre></div><h4 id="3-5-3-同时导入"><a href="#3-5-3-同时导入" class="headerlink" title="3.5.3 同时导入"></a>3.5.3 同时导入</h4><p>如果模块同时导出了命名导出和默认导出，则可以在import 语句中同时取得它们。可以依次列出特定导出的标识符来取得，也可以使用*来取得：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> foo, &#123; bar, baz &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo, bar, baz &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;<span class="hljs-keyword">import</span> foo, * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;</code></pre></div><h3 id="3-6-模块转移导出"><a href="#3-6-模块转移导出" class="headerlink" title="3.6 模块转移导出"></a>3.6 模块转移导出</h3><p>模块导入的值可以直接通过管道转移到导出。此时，也可以将默认导出转换为命名导出，或者相反。<br>如果想把一个模块的所有命名导出集中在一块，可以像下面这样在 bar.js 中使用 * 导出：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 bar.js 中</span><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;</code></pre></div><p>这样，foo.js 中的所有命名导出都会出现在导入 bar.js 的模块中。如果 foo.js 有默认导出，则该语法会忽略它。使用此语法也要注意导出名称是否冲突。如果 foo.js 导出 baz，bar.js 也导出baz，则最终导出的是 bar.js 中的值。这个“重写”是静默发生的：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 foo.js 中</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;origin:foo&#x27;</span>;<span class="hljs-comment">// 在 bar.js 中</span><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;origin:bar&#x27;</span>;<span class="hljs-comment">// 在 main.js 中</span><span class="hljs-keyword">import</span> &#123; baz &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar.js&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz); <span class="hljs-comment">// origin:bar</span></code></pre></div><p>此外也可以明确列出要从外部模块转移本地导出的值。该语法支持使用别名：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123; foo, bar <span class="hljs-keyword">as</span> myBar &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;</code></pre></div><p>类似地，外部模块的默认导出可以重用为当前模块的默认导出：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;</code></pre></div><p>这样不会复制导出的值，只是把导入的引用传给了原始模块。在原始模块中，导入的值仍然是可用的，与修改导入相关的限制也适用于再次导出的导入。<br>在重新导出时，还可以在导入模块修改命名或默认导出的角色。比如，可以像下面这样将命名导出指定为默认导出：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;</code></pre></div><h3 id="3-7-工作者模块"><a href="#3-7-工作者模块" class="headerlink" title="3.7 工作者模块"></a>3.7 工作者模块</h3><p>ECMAScript 6 模块与 Worker 实例完全兼容。在实例化时，可以给工作者传入一个指向模块文件的路径，与传入常规脚本文件一样。Worker 构造函数接收第二个参数，用于说明传入的是模块文件。<br>下面是两种类型的 Worker 的实例化行为：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 第二个参数默认为&#123; type: &#x27;classic&#x27; &#125;</span><span class="hljs-keyword">const</span> scriptWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;scriptWorker.js&#x27;</span>);<span class="hljs-keyword">const</span> moduleWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;moduleWorker.js&#x27;</span>, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;module&#x27;</span> &#125;);</code></pre></div><p>在基于模块的工作者内部，self.importScripts() 方法通常用于在基于脚本的工作者中加载外部脚本，调用它会抛出错误。这是因为模块的 import 行为包含了 importScripts()。</p><h3 id="3-8-兼容"><a href="#3-8-兼容" class="headerlink" title="3.8 兼容"></a>3.8 兼容</h3><p>ECMAScript 模块的兼容是个渐进的过程，能够同时兼容支持和不支持的浏览器对早期采用者是有价值的。对于想要尽可能在浏览器中原生使用 ECMAScript 6 模块的用户，可以提供两个版本的代码：基于模块的版本与基于脚本的版本。如果嫌麻烦，可以使用第三方模块系统（如 SystemJS ）或在构建时将 ES6 模块进行转译，这都是不错的方案。</p><p>第一种方案涉及在服务器上检查浏览器的用户代理，与支持模块的浏览器名单进行匹配，然后基于匹配结果决定提供哪个版本的 JavaScript 文件。这个方法不太可靠，而且比较麻烦，不推荐。</p><p>更好、更优雅的方案是利用脚本的type 属性和 nomodule 属性。浏览器在遇到<code>&lt;script&gt;</code>标签上无法识别的 type 属性时会拒绝执行其内容。对于不支持模块的浏览器，这意味着<code>&lt;script type=&quot;module&quot;&gt;</code>不会被执行。因此，可以在<code>&lt;script type=&quot;module&quot;&gt;</code>标<br>签旁边添加一个回退<code>&lt;script&gt;</code>标签：</p><div class="code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-comment">// 不支持模块的浏览器不会执行这里的代码</span>&lt;script type=<span class="hljs-string">&quot;module&quot;</span> src=<span class="hljs-string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;<span class="hljs-comment">// 不支持模块的浏览器会执行这里的代码</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>当然，这样一来支持模块的浏览器就有麻烦了。此时，前面的代码会执行两次，显然这不是我们想要的结果。为了避免这种情况，原生支持 ECMAScript 6 模块的浏览器也会识别 nomodule 属性。此属性通知支持 ES6 模块的浏览器不执行脚本。不支持模块的浏览器无法识别该属性，从而忽略这个属性的存在。因此，下面代码会生成一个设置，在这个设置中，支持模块和不支持模块的浏览器都只会执行一段脚本：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 支持模块的浏览器会执行这段脚本</span><span class="hljs-comment">// 不支持模块的浏览器不会执行这段脚本</span>&lt;script type=<span class="hljs-string">&quot;module&quot;</span> src=<span class="hljs-string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;<span class="hljs-comment">// 支持模块的浏览器不会执行这段脚本</span><span class="hljs-comment">// 不支持模块的浏览器会执行这段脚本</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】21.错误处理与调试</title>
    <link href="/archives/915d16bc.html"/>
    <url>/archives/915d16bc.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1 错误处理"></a>1 错误处理</h2><h3 id="1-1-try-x2F-catch-语句"><a href="#1-1-try-x2F-catch-语句" class="headerlink" title="1.1 try&#x2F;catch 语句"></a>1.1 try&#x2F;catch 语句</h3><p>任何可能出错的代码都放在 try 块中，而错误处理的代码放在 catch 块中。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">// 可能出错的代码</span>&#125;<span class="hljs-keyword">catch</span>(error)&#123;<span class="hljs-comment">// 出错时的错误处理</span>&#125;</code></pre></div><p>如果 try 块中有代码发生错误，代码会立即推出执行，并跳到 catch 块中。catch 块此时接受到一个对象，该对象包含发生错误的信息。该对象至少包含两个属性：message（错误消息）和 name（错误类型）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 可能出错的代码</span>&#125; <span class="hljs-keyword">catch</span> (error) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">name</span>);&#125;</code></pre></div><blockquote><p><strong>注意</strong>：当 try 块中发生错误时，浏览器会认为错误已 catch 块被处理，不会再报错。</p></blockquote><h4 id="1-1-1-finally-子句"><a href="#1-1-1-finally-子句" class="headerlink" title="1.1.1 finally 子句"></a>1.1.1 finally 子句</h4><p>try&#x2F;catch 语句中可选的 finally 子句会始终执行。如果 try 块或 catch 块中的代码执行完，则会接着执行 finally 块中的代码。</p><blockquote><p><strong>注意</strong>：只要代码中包含了 finally 子句，那么 try 块和 catch 块中的 return 语句会被忽略。</p></blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 因为有 finally 子句，所以 try 块中 return 语句被忽略</span>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// return 语句会被忽略</span>  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  &#125;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>());  <span class="hljs-comment">// 2</span></code></pre></div><h4 id="1-1-2-错误类型"><a href="#1-1-2-错误类型" class="headerlink" title="1.1.2 错误类型"></a>1.1.2 错误类型</h4><p>共有 8 中错误类型：</p><ul><li><p>Error。Error 是基类型，其它错误类型继承该类型。浏览器很少会抛出 Error 类型错误，该类型主要用于开发者自定义错误（继承 Error 类来自定义错误）。</p></li><li><p>InternalError。在底层 JavaScript 引擎异常时浏览器会抛出该错误。例如：递归导致的栈溢出。</p></li><li><p>EvalError。使用 eval() 函数时发生的错误时抛出该错误。比如： eval 属性没有被直接调用或者 eval 属性被赋值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">eval</span>()<span class="hljs-comment">// 抛出EvalError</span><span class="hljs-built_in">eval</span> = foo<span class="hljs-comment">// 抛出EvalError</span></code></pre></div></li><li><p>RangeError。数值越界时抛出该错误。比如：定义数组长度时传入负值。</p></li><li><p>ReferenceError。找不到对象时抛出该错误。比如：访问不存在的变量。</p></li><li><p>SyntaxError。 JavaScript 出现语法错误时抛出该错误。JavaScript 语法错误会导致 JavaScript 无法执行。比如：使用 let 在同一块中定义两个同名变量。</p></li><li><p>TypeError。变量不是预期类型或者访问不存在的方法时抛出该错误。</p></li><li><p>URIError。使用 encodeURI() 或者 decodeURI() 但是传入了格式错误的 URI 时抛出该错误。</p></li></ul><h3 id="1-2-throw-抛出错误"><a href="#1-2-throw-抛出错误" class="headerlink" title="1.2 throw 抛出错误"></a>1.2 throw 抛出错误</h3><p>throw 操作符可以用于在任何时候抛出自定义错误。throw 操作符必须有一个值，但是值的类型不限。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">throw</span> <span class="hljs-number">1</span><span class="hljs-keyword">throw</span> <span class="hljs-literal">true</span><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;error&#x27;</span><span class="hljs-keyword">throw</span> &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;</code></pre></div><p>执行到 throw 操作符时，代码会立即停止执行，除非 try&#x2F;catch 捕获了抛出的值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">catch</span>(error)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);&#125;</code></pre></div><p>可以抛出一个错误类型实例。每种错误类型接收一个参数，即错误消息。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;this is a error&#x27;</span>)</code></pre></div><h2 id="2-调试技术"><a href="#2-调试技术" class="headerlink" title="2 调试技术"></a>2 调试技术</h2><h3 id="2-1-把消息记录到控制台"><a href="#2-1-把消息记录到控制台" class="headerlink" title="2.1 把消息记录到控制台"></a>2.1 把消息记录到控制台</h3><p>浏览器支持使用 console 对象直接将 JavaScript 消息写入控制台。这个对象有以下方法：</p><ul><li><code>error(message)</code>。在控制台中记录错误消息。</li><li><code>info(message)</code>。在控制台中记录消息内容。</li><li><code>log(message)</code>。在控制台中记录常规消息。</li><li><code>warn(message)</code>。在控制台中记录警告消息。</li></ul><p>效果如下：</p><img src="../images/红宝书-21-第21章：错误处理与调试/image-20220707145516571.png" alt="image-20220707145516571" style="zoom:33%;" /><h3 id="2-2-debugger-调试器"><a href="#2-2-debugger-调试器" class="headerlink" title="2.2 debugger 调试器"></a>2.2 debugger 调试器</h3><p>debugger 这个关键字，用于调用存在的调试功能。在运行时碰见这个关键字时，浏览器会打开开发者工具面板并启用调试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【你不知道的JavaScript】1.作用域和闭包</title>
    <link href="/archives/1081e6d1.html"/>
    <url>/archives/1081e6d1.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-作用域是什么"><a href="#1-作用域是什么" class="headerlink" title="1 作用域是什么"></a>1 作用域是什么</h1><h2 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a>1.1 编译原理</h2><p>编译的三个步骤：</p><ol><li><p>分词&#x2F;词法分析（tokenizing&#x2F;lexing）</p><p>这个过程中，字符串将被分解成词法单元（token）。比如：<code>var a = 2</code> 将被分解为 <code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>。</p><blockquote><p><strong>分词</strong>和<strong>词法分析</strong>的区别：词法单元生成器在判断 <code>a</code> 是一个独立的词法单元还是其它词法单元的一部分时，如果调用的是<strong>有状态</strong>的解析规则，那么这个过程就被称为<strong>词法分析</strong>。否则成为<strong>分词</strong>。</p></blockquote></li><li><p>解析&#x2F;语法分析（parsing）</p><p>这个过程是将 token 序列转换成一个由元素逐级嵌套所组成的抽象语法树（AST）。</p></li><li><p>代码生成</p><p>将 AST 转换成可执行代码的过程成为代码生成。</p></li></ol><p>任何 JavaScript 代码片段在执行前都要进行编译，在此期间会对运行性能进行优化。</p><h2 id="1-2-理解作用域"><a href="#1-2-理解作用域" class="headerlink" title="1.2 理解作用域"></a>1.2 理解作用域</h2><p>术语表：</p><ol><li><p>引擎</p><p>负责整个 JavaScript 程序的编译及执行过程。</p></li><li><p>编译器</p><p>负责语法分析及代码生成。</p></li><li><p>作用域</p><p>负责收集并维护由所有变量组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p></li></ol><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果当前变量没有声明过），然后，运行时引擎会在作用域中的查找该变量，如果能找到就会对它赋值。</p><p>引擎执行代码时，会通过查找变量来判断它是否已声明过。查找的过程由作用域协助，但是引擎执行怎样的查找，会影响最终的查找结果。</p><h3 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h3><p>查询类型分为两种，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。更准确的讲，RHS 查询就是简单地查找某个变量的源值，而 LHS 查询则是试图找到变量的<strong>容器</strong>本身，从而对其进行赋值。从这个角度上讲，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</p><p>例如：</p><p>对于代码 <code>console.log(a)</code>，其中对 a 的引用是一个 RHS 引用，因此这里 a 并没有被赋予任何值。相反，需要查找并取得 a 的值，这样才能将值传递给 <code>console.log()</code>。</p><p>对于代码 <code>a = 2</code>，这里对 a 的引用是 LHS 引用。因为，此时并不关心当前的值是什么，只想为 <code>= 2</code> 这个赋值操作找到一个目标。</p><blockquote><p>LHS 和 RHS 的含义是赋值操作的左侧或者右侧，但是并不意味着就是 <code>=</code> 的左侧或者右侧。因此在概念上，最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。</p></blockquote><h2 id="1-3-作用域嵌套"><a href="#1-3-作用域嵌套" class="headerlink" title="1.3 作用域嵌套"></a>1.3 作用域嵌套</h2><p>作用域是根据名称查找变量的一套规则。当一个块或者函数嵌套在另一个块或者函数中时，也就是发生了作用域嵌套。遍历嵌套作用域链的规则：引擎从当前执行做哟关于开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层作用域时查找过程停止。</p><h2 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h2><p>区分 LHS 和 RHS 是一件重要的事情。因为在变量还没有声明的情况下，这两种查询的行为是不一样的。</p><p>如果 RHS 查询在所有的嵌套作用域中都找不到所需的变量，引擎就会抛出 ReferenceError 异常。相较之下，如果 LHS 查询在所有嵌套作用域中找到目标变量时，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎（非严格模式）。</p><p>如果 RHS 查询找到了一个变量，但是对该变量的值进行不合理的操作，那么就会抛出 TypeError。</p><p>ReferenceError 同作用域判别失败，而 TypeError 则代表作用域判别成功了，但是对结果的操作不合理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】20.BOM</title>
    <link href="/archives/f59c0ea7.html"/>
    <url>/archives/f59c0ea7.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-window-对象"><a href="#1-window-对象" class="headerlink" title="1 window 对象"></a>1 window 对象</h2><p>window 对象是 ECMAScript 中的 Global 对象。</p><h3 id="1-1-Global-作用域"><a href="#1-1-Global-作用域" class="headerlink" title="1.1 Global 作用域"></a>1.1 Global 作用域</h3><p>在全局作用域中定义的全局变量和全局函数都会变成 window 对象的属性和方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-comment">// 全局变量</span>bar = <span class="hljs-string">&quot;bar&quot;</span>;<span class="hljs-comment">// 全局变量</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">foo</span>);<span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">bar</span>);<span class="hljs-comment">// bar</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;  baz = <span class="hljs-string">&quot;baz&quot;</span>;<span class="hljs-comment">// 局部变量</span>  <span class="hljs-keyword">var</span> qux = <span class="hljs-string">&quot;qux&quot;</span>;<span class="hljs-comment">// 局部变量</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">baz</span>);<span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">qux</span>);<span class="hljs-comment">// undefined</span></code></pre></div><blockquote><p><strong>注意</strong>：JavaScript 中很多对象暴露在全局作用域中，比如：location 和 navigator。因此它们都是 window 对象上的属性。</p></blockquote><h3 id="1-2-top、parent、self-窗口关系"><a href="#1-2-top、parent、self-窗口关系" class="headerlink" title="1.2 top、parent、self 窗口关系"></a>1.2 top、parent、self 窗口关系</h3><p>top 对象始终指向最上层窗口，即浏览器窗口本身。parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 parent 等于 top。还有一个 self 对象始终指向 window 对象。</p><p>上面的 top、self、parent 对象都是 window 身上的属性，因此可以把多个窗口的 window 对象串联起来，比如说 <code> window.parent.parent</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span> === <span class="hljs-variable language_">window</span>.<span class="hljs-property">self</span>); <span class="hljs-comment">// true</span></code></pre></div><h3 id="1-3-open-打开新窗口"><a href="#1-3-open-打开新窗口" class="headerlink" title="1.3 open() 打开新窗口"></a>1.3 open() 打开新窗口</h3><p>window.open() 用于导航到指定 URL 或者打开新窗口。这个方法接收4个参数：要加载的 URL、目标窗口、特性字符串和一个布尔值（代表新窗口在历史记录中是否代替当前窗口）。</p><p>如果第二个参数是已经存在的窗口的名字，则会在对应窗口打开 URL。否则会打开一个新窗口并将其命名为该参数。第二个参数也可以是特殊的窗口名，比如：<code>_self</code>、<code>_parent</code>、<code>_top</code>或者 <code>_blank</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>, <span class="hljs-string">&#x27;win-2&#x27;</span>);<span class="hljs-comment">// 执行上述代码会新打开一个窗口并将其命名为 `win-2`。在该新窗口的控制台中查看`window.name`显示为`win-2`。</span></code></pre></div><p>如果第二个参数是打开新窗口，可以使用第三个参数（特性字符串）指定新窗口的配置。详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open">MDN</a> 文档。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>, <span class="hljs-string">&#x27;win-3&#x27;</span>, <span class="hljs-string">&#x27;width=300,height=300,top=100,left=100&#x27;</span>);<span class="hljs-comment">// 执行上述代码会新打开一个窗口并将其命名为 win-3 。该新窗口大小 300 * 300，距离屏幕左上各 100 像素。</span></code></pre></div><p>window.open() 方法返回新窗口的引用。该引用和 window 对象没有区别，可以控制新窗口。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> win3 = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>, <span class="hljs-string">&#x27;win-3&#x27;</span>, <span class="hljs-string">&#x27;width=300,height=300,top=100,left=100&#x27;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;    win3.<span class="hljs-title function_">close</span>();<span class="hljs-comment">// 2s后关闭该新窗口</span>&#125;,<span class="hljs-number">2000</span>)</code></pre></div><blockquote><p>如果弹窗被屏蔽，windows.open() 会返回 null。</p></blockquote><h3 id="1-4-定时器"><a href="#1-4-定时器" class="headerlink" title="1.4 定时器"></a>1.4 定时器</h3><p>setTimeout() 方法用于指定一段时间后执行某些代码，setInterval() 方法用于指定每隔一段时间执行某些代码。</p><h4 id="1-4-1-setTimeout"><a href="#1-4-1-setTimeout" class="headerlink" title="1.4.1 setTimeout()"></a>1.4.1 setTimeout()</h4><p>setTimeout() 方法通常接受两个参数，第一个是要执行的代码，第二个是执行回调函数前等待的时间（毫秒）。第一个参数可以是代码的字符串，也可以是一个函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种写法</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&#x27;console.log(&quot;hello&quot;)&#x27;</span>, <span class="hljs-number">1000</span>);<span class="hljs-comment">// 第二种写法</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>);&#125;, <span class="hljs-number">1000</span>);</code></pre></div><blockquote><p>第二个参数是要等待的毫秒数，而不是执行代码的确切时间。JavaScript 是<strong>单线程</strong>的，每次只能执行一段代码。JavaScript 维护了一个<strong>任务队列</strong>，并按照加入队列的先后顺序依次执行任务。setTimeout() 的第二个参数只是告诉 JavaScript 引擎在固定毫秒后<strong>将任务添加到队列</strong>中。具体什么时候执行该任务，取决于队列中的情况。如果队列中没有任务，则立即执行。如果有其它任务未执行，需要等待前面的任务全部执行完毕。</p></blockquote><p>调用 setTimeout() 会返回一个用于标识的 id。可以通过该 id 来取消尚未执行的任务。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>);&#125;, <span class="hljs-number">1000</span>);<span class="hljs-built_in">clearTimeout</span>(id);<span class="hljs-comment">// 取消任务</span></code></pre></div><blockquote><p>setTimeout() 所要执行的函数会在全局作用域下的一个匿名函数中运行。因此，函数的 this 指向 window（非严格模式），想要保留函数定义时的 this 值，需要使用箭头函数。</p></blockquote><h4 id="1-4-2-setInterval"><a href="#1-4-2-setInterval" class="headerlink" title="1.4.2 setInterval()"></a>1.4.2 setInterval()</h4><p>setInterval() 和 setTimeout() 类似，只不过，setInterval() 会每隔一段时间执行一次任务，直到取消循环或者页面卸载。</p><blockquote><p>setInterval() 会每隔固定时间将任务添加到任务队列，并不关心这些任务什么时候会被执行。因此无法保证两个任务执行的间隔时间。</p></blockquote><h3 id="1-5-系统对话框"><a href="#1-5-系统对话框" class="headerlink" title="1.5 系统对话框"></a>1.5 系统对话框</h3><p>alert()、confirm()、promt() 方法可以调用对话框向用户显示消息。这些对话框和浏览器中现实的网页无关。它们的外观由系统和浏览器决定。这些对话框都是同步的模态框，也就是说当它们在显示的时候，代码会停止运行，在它们消失的时候，代码才会恢复执行。</p><h4 id="1-5-1-alert-警告框"><a href="#1-5-1-alert-警告框" class="headerlink" title="1.5.1 alert() 警告框"></a>1.5.1 alert() 警告框</h4><p>alert() 警告框用来显示消息，只有一个确认按钮。alert() 接收一个参数，即显示的字符串。若传入的该参数不是字符串，则会调用 toString() 方法将其转成字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);</code></pre></div><img src="../images/红宝书-20-第12章：BOM/image-20220706170228063.png" alt="image-20220706170228063" style="zoom:33%;" /> <h4 id="1-5-2-confirm-确认框"><a href="#1-5-2-confirm-确认框" class="headerlink" title="1.5.2 confirm() 确认框"></a>1.5.2 confirm() 确认框</h4><p>confirm() 确定框也是用来显示消息，但是有取消和确认两个按钮。confirm() 接收一个参数，即显示的字符串。confirm() 返回一个布尔值，该值取决于用户的操作。用户点击确认，confirm() 返回 true；点击取消，confirm() 返回 false。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;是否确认&quot;</span>)) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;确认&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;取消&quot;</span>);&#125;</code></pre></div><img src="../images/红宝书-20-第12章：BOM/image-20220706171712531.png" alt="image-20220706171712531" style="zoom:33%;" /><h4 id="1-5-3-promt-提示框"><a href="#1-5-3-promt-提示框" class="headerlink" title="1.5.3 promt() 提示框"></a>1.5.3 promt() 提示框</h4><p>promt() 提示框的用于提示用户输入信息，可以显示文本并提供取消和确认两个按钮。promt() 接收两个参数，第一个参数时显示的字符串，第二个是文本框默认值。promt() 返回值取决于用户的操作。用户点击确认，返回文本框中的内容；点击取消，返回 null。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;what is your name?&quot;</span>);<span class="hljs-keyword">if</span> (res !== <span class="hljs-literal">null</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello &quot;</span> + res);&#125;</code></pre></div><h4 id="1-5-4-find-搜索和-print-打印"><a href="#1-5-4-find-搜索和-print-打印" class="headerlink" title="1.5.4 find() 搜索和 print() 打印"></a>1.5.4 find() 搜索和 print() 打印</h4><p>find() 和 print() 对话框都是异步显示的，即控制权立即返回给脚本。find() 打开查找对话框，print() 打开打印对话框。</p><h2 id="2-location-对象"><a href="#2-location-对象" class="headerlink" title="2 location 对象"></a>2 location 对象</h2><p>location 既是 window 的属性也是 document 的属性。location 保存着 hash、hostname、port 等属性。</p><img src="../images/红宝书-20-第12章：BOM/image-20220706173319423.png" alt="image-20220706173319423" style="zoom:33%;" /><h3 id="2-1-查询字符串"><a href="#2-1-查询字符串" class="headerlink" title="2.1 查询字符串"></a>2.1 查询字符串</h3><p>URLSearchParams 提供了一组标准的 API，通过它可以检查和修改查询字符串。给 URLSearchParams 构造函数传入一个查询字符串，即可创建一个实例。实例上有 has()、get()、delete() 等方法。 该实例也是一个可迭代对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> qs = <span class="hljs-string">&#x27;?count=10&amp;page=2&#x27;</span>;<span class="hljs-keyword">let</span> search = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(qs);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(search.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;count&#x27;</span>));<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(search.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;page&#x27;</span>));<span class="hljs-comment">// 2</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> search)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);&#125;<span class="hljs-comment">// [&#x27;count&#x27;, &#x27;10&#x27;]</span><span class="hljs-comment">// [&#x27;page&#x27;, &#x27;2&#x27;]</span></code></pre></div><h3 id="2-2-操作地址"><a href="#2-2-操作地址" class="headerlink" title="2.2 操作地址"></a>2.2 操作地址</h3><p>可以通过 location 对象修改当前浏览器的地址。</p><h4 id="2-2-1-assign-跳转到新地址"><a href="#2-2-1-assign-跳转到新地址" class="headerlink" title="2.2.1 assign() 跳转到新地址"></a>2.2.1 assign() 跳转到新地址</h4><p>location.assign(‘xxx’) 会立即导航到新的 URL，同时在浏览器历史记录中新增一条记录。下面两种操作会调用 assign() 因此有同样效果：</p><div class="code-wrapper"><pre><code class="hljs javascript">location = <span class="hljs-string">&#x27;xxx&#x27;</span>location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;xxx&#x27;</span></code></pre></div><p>修改 location 对象的属性值也会修改当前加载的页面。其中，hash、search、hostname、pathname 和 port 属性被设置为新值后都会修改当前页面的 URL。</p><h4 id="2-2-2-replace-替换到新地址"><a href="#2-2-2-replace-替换到新地址" class="headerlink" title="2.2.2 replace() 替换到新地址"></a>2.2.2 replace() 替换到新地址</h4><p>如果不想增加历史记录，可以使用 location.replace() 方法。</p><h4 id="2-2-3-reload-重新加载"><a href="#2-2-3-reload-重新加载" class="headerlink" title="2.2.3 reload() 重新加载"></a>2.2.3 reload() 重新加载</h4><p>location.reload() 可以重新加载当前页面。不传参数，页面可能会从缓存中加载；传递参数 <code>true</code>，页面会强制加载。</p><blockquote><p>脚本中 reload() 后的代码可能执行也可能不执行。因此，最好把 reload() 当作最后一行代码。</p></blockquote><h2 id="3-navigator-对象"><a href="#3-navigator-对象" class="headerlink" title="3 navigator 对象"></a>3 navigator 对象</h2><p>只读属性 <strong><code>Window.navigator</code></strong> 会返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator"><code>Navigator</code></a> 对象的引用，可以用于请求运行当前代码的应用程序的相关信息。</p><img src="../images/【JavaScript】20_BOM/image-20221228164613272.png" alt="image-20221228164613272" style="zoom: 33%;" /><h2 id="4-screen-对象"><a href="#4-screen-对象" class="headerlink" title="4 screen 对象"></a>4 screen 对象</h2><p>返回当前 window 的 screen 对象。screen 对象实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Screen"><code>Screen</code></a>接口，它是个特殊的对象，返回当前渲染窗口中和屏幕有关的属性。</p><img src="../images/【JavaScript】20_BOM/image-20221228164635219.png" alt="image-20221228164635219" style="zoom:50%;" /><h2 id="5-history-对象"><a href="#5-history-对象" class="headerlink" title="5 history 对象"></a>5 history 对象</h2><img src="../images/【JavaScript】20_BOM/image-20221228164658905.png" alt="image-20221228164658905" style="zoom:50%;" /><p>go() 方法可以在用户的历史记录中前进或者后退。</p><p>go() 可以接收一个整数。正数代表前进的步数，负数代表后退的步数。</p><div class="code-wrapper"><pre><code class="hljs javascript">history.<span class="hljs-title function_">go</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">// 历史记录中前进1步</span>history.<span class="hljs-title function_">go</span>(-<span class="hljs-number">3</span>)<span class="hljs-comment">// 历史记录中后退3步</span></code></pre></div><p>go() 也可以接受一个地址字符串。浏览器会导航到最近的该地址的历史记录，可能是前进也可能是后退。如果历史记录中没有匹配项，那么就什么都不做。</p><div class="code-wrapper"><pre><code class="hljs javascript">history.<span class="hljs-title function_">go</span>(<span class="hljs-string">&#x27;www.baidu.com&#x27;</span>)  <span class="hljs-comment">// 导航到最近的该地址的历史记录</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript】Promise-2-自定义封装</title>
    <link href="/archives/bdb1cf7f.html"/>
    <url>/archives/bdb1cf7f.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-初始结构搭建"><a href="#1-初始结构搭建" class="headerlink" title="1 初始结构搭建"></a>1 初始结构搭建</h2><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h3><p>目录结构：</p><div class="code-wrapper"><pre><code class="hljs awk">─ 自定义封装Promise<span class="hljs-regexp">//</span> 根文件夹    ├─ index.html<span class="hljs-regexp">//</span> 将两个js文件放入html中，便于浏览器打开    ├─ index.js<span class="hljs-regexp">//</span> 测试 Promise 效果的地方    └─ promise.js<span class="hljs-regexp">//</span> 重写 Promise 构造函数</code></pre></div><p>index.html 中：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./promise.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="1-2-起步"><a href="#1-2-起步" class="headerlink" title="1.2 起步"></a>1.2 起步</h3><p>首先，在 index.js 中写一个基本的 Promise 使用方法：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;OK&quot;</span>);&#125;);p.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  &#125;,  <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);  &#125;);</code></pre></div><p>然后在 Promise.js 中重写 Promise 构造函数，并为 Promise 的原型添加 then() 方法。</p><p>Promise 构造函数接收一个执行器函数作为参数，这个执行器函数需要两个函数参数（这里命名为 resolve 和 reject）。 resolve() 和 reject() 都需要一个参数。</p><p>在 Promise 构造函数中定义好 resolve() 和 reject() 这两个函数参数，并同步执行执行器：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;  <span class="hljs-comment">// 声明 resolve 和 reject 两个函数参数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;&#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">data</span>) &#123;&#125;      <span class="hljs-comment">// 同步调用执行器函数</span>  <span class="hljs-title function_">executor</span>(resolve, reject);&#125;<span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;&#125;;</code></pre></div><h2 id="2-resolve-和-reject"><a href="#2-resolve-和-reject" class="headerlink" title="2 resolve() 和 reject()"></a>2 resolve() 和 reject()</h2><p>resolve() 和 reject() 函数主要完成两个功能，第一是修改 Promise 对象的状态，第二是返回结果值或原因。</p><p>注意 resolve() 和 reject() 两个函数中 this 的指向不是实例对象，而是 window。因此，需要先保存实例对象的 this 值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;  <span class="hljs-comment">// 添加属性</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;pending&quot;</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">//   保存实例对象的 this</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 声明 resolve 和 reject 两个函数参数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;rejected&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;  &#125;  <span class="hljs-comment">// 同步调用执行器函数</span>  <span class="hljs-title function_">executor</span>(resolve, reject);&#125;</code></pre></div><h2 id="3-throw-抛出异常"><a href="#3-throw-抛出异常" class="headerlink" title="3 throw 抛出异常"></a>3 throw 抛出异常</h2><p>throw 抛出异常之后，Promise 对象的状态改为 rejected，并且失败的原因即 throw 抛出的参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;  <span class="hljs-comment">// 添加属性</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;pending&quot;</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">//   保存实例对象的 this</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 声明 resolve 和 reject 两个函数参数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;rejected&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;  &#125;  <span class="hljs-comment">// 同步调用执行器函数</span>  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-title function_">executor</span>(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-comment">// 捕获异常，修改状态</span>    <span class="hljs-title function_">reject</span>(e);  &#125;&#125;</code></pre></div><h2 id="4-状态只允许修改一次"><a href="#4-状态只允许修改一次" class="headerlink" title="4 状态只允许修改一次"></a>4 状态只允许修改一次</h2><p>Promise 状态只能由 pending 改为 fulfilled或由 pending 改为 rejected，并且只能修改一次。一旦 Promise 的状态发生修改，再次修改状态会静默失败。</p><p>每次修改 Promise 状态前需要加一个判断，如果 Promise 状态不是 pending，则不执行状态转换。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;  <span class="hljs-comment">// 添加属性</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;pending&quot;</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">//   保存实例对象的 this</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 声明 resolve 和 reject 两个函数参数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;rejected&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;  &#125;  <span class="hljs-comment">// 同步调用执行器函数</span>  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-title function_">executor</span>(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-comment">// 捕获异常，修改状态</span>    <span class="hljs-title function_">reject</span>(e);  &#125;&#125;</code></pre></div><h2 id="5-执行同步任务回调"><a href="#5-执行同步任务回调" class="headerlink" title="5 执行同步任务回调"></a>5 执行同步任务回调</h2><p>Promise 实例上的 then 方法，接收两个回调函数作为参数。如果 Promise 实例对象的状态为 fulfilled，则调用第一个回调函数；如果 Promise 实例对象的状态为 rejected，则调用第二个回调函数。这两个函数的参数都是实例身上的结果。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;  <span class="hljs-comment">// 调用回调函数</span>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;    <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;    <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);  &#125;&#125;;</code></pre></div><h2 id="6-执行异步任务回调"><a href="#6-执行异步任务回调" class="headerlink" title="6 执行异步任务回调"></a>6 执行异步任务回调</h2><p>现在自定义的 Promise 构造函数的构造器中只能执行同步的代码。如果执行异步代码（比如定时器），then() 处理程序无法执行。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;ok&quot;</span>);<span class="hljs-comment">// 同步代码</span>&#125;);p.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// ok  then()处理程序可以正常执行</span>  &#125;,  <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);  &#125;);</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;ok&quot;</span>);<span class="hljs-comment">// 异步代码</span>  &#125;, <span class="hljs-number">1000</span>);&#125;);p.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 无法执行正常输出</span>  &#125;,  <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);  &#125;);</code></pre></div><p>这是因为，执行 p.then() 的时候 p 的状态是 pending，此时 p.then() 方法还不能处理 pending 状态，因此不会执行任何代码。</p><p>想要在 p 将 pending 状态修改为 fulfilled 或者 rejected 之后再调用 p.then() 方法中的 onResolved 或者 onRejected，就必须将 onResolved 和 onRejected 都保存下来，并且在 resolve() 和 reject() 方法的最后调用  onResolved 和 onRejected。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;  <span class="hljs-comment">// 添加属性</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;pending&quot;</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// 保存回调</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callback</span> = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 保存实例对象的 this</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 声明 resolve 和 reject 两个函数参数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;    <span class="hljs-comment">// 调用 onResolved</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">callback</span>.<span class="hljs-property">onResolved</span>) &#123;      self.<span class="hljs-property">callback</span>.<span class="hljs-title function_">onResolved</span>(data);    &#125;  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;rejected&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;    <span class="hljs-comment">// 调用 onRejected</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">callback</span>.<span class="hljs-property">onRejected</span>) &#123;      self.<span class="hljs-property">callback</span>.<span class="hljs-title function_">onRejected</span>(data);    &#125;  &#125;  <span class="hljs-comment">// 同步调用执行器函数</span>  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-title function_">executor</span>(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-comment">// 捕获异常，修改状态</span>    <span class="hljs-title function_">reject</span>(e);  &#125;&#125;<span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;  <span class="hljs-comment">// 调用回调函数</span>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;    <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;    <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callback</span> = &#123;      onResolved,      onRejected,    &#125;;  &#125;&#125;;</code></pre></div><h2 id="7-执行多个回调"><a href="#7-执行多个回调" class="headerlink" title="7 执行多个回调"></a>7 执行多个回调</h2><p>如果为 Promise 对象指定多个成功回调或失败回调，Promise 对象在成功后会执行所有成功回调，在失败后会执行所有失败回调。</p><p>现在的代码中，如果给 Promise 对象指定多个成功回调，那么只会执行最后定义的那个。因为之前定义的回调都被后一个给覆盖了。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;ok&quot;</span>);  &#125;, <span class="hljs-number">1000</span>);&#125;);p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;first&quot;</span>, value);<span class="hljs-comment">// 不会执行</span>&#125;);p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;second&quot;</span>, value);<span class="hljs-comment">// second ok</span>&#125;);</code></pre></div><p>想要解决这个问题，就要把 Promise 构造函数中只保存一对成功和失败回调的 callback 修改为能保存多个回调的 callbacks 数组。 </p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;  <span class="hljs-comment">// 添加属性</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;pending&quot;</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// 保存回调</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span> = [];  <span class="hljs-comment">// 保存实例对象的 this</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 声明 resolve 和 reject 两个函数参数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;    <span class="hljs-comment">// 调用 onResolved</span>    self.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;      item.<span class="hljs-title function_">onResolved</span>(data);    &#125;);  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;rejected&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;    <span class="hljs-comment">// 调用 onRejected</span>    self.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;      item.<span class="hljs-title function_">onRejected</span>(data);    &#125;);  &#125;  <span class="hljs-comment">// 同步调用执行器函数</span>  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-title function_">executor</span>(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-comment">// 捕获异常，修改状态</span>    <span class="hljs-title function_">reject</span>(e);  &#125;&#125;<span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;  <span class="hljs-comment">// 调用回调函数</span>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;    <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;    <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123; onResolved, onRejected &#125;);  &#125;&#125;;</code></pre></div><h2 id="8-同步修改状态时-then-方法返回值"><a href="#8-同步修改状态时-then-方法返回值" class="headerlink" title="8 同步修改状态时 then() 方法返回值"></a>8 同步修改状态时 then() 方法返回值</h2><p>then() 方法是有返回值的，then() 方法的返回值是一个 Promise 对象。</p><p>传给 then() 方法的成功回调函数参数中，如果返回值是 Promise 对象，那么 then() 方法返回的 Promise 对象的状态取决于函数参数中返回值的状态；如果返回值不是 Promise 对象，那么 then() 方法会将其包装成一个成功的 Promise 对象；如果抛出错误，那么 then() 方法的返回 Promise 对象为失败状态，并且结果值是抛出的信息。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 调用回调函数</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 获取函数执行结果</span>        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;          <span class="hljs-comment">// 执行结果是 Promise 实例时</span>          result.<span class="hljs-title function_">then</span>(            <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;              <span class="hljs-title function_">resolve</span>(v);            &#125;,            <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;              <span class="hljs-title function_">reject</span>(r);            &#125;          );        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 不是 Promise 实例时</span>          <span class="hljs-title function_">resolve</span>(result);        &#125;      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-title function_">reject</span>(error);      &#125;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;      <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123; onResolved, onRejected &#125;);    &#125;  &#125;);&#125;;</code></pre></div><h2 id="9-异步修改状态时-then-方法返回值"><a href="#9-异步修改状态时-then-方法返回值" class="headerlink" title="9 异步修改状态时 then() 方法返回值"></a>9 异步修改状态时 then() 方法返回值</h2><p>异步修改状态后，onResolved 和 onRejected 需要根据结果来修改状态。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;  <span class="hljs-comment">// 保存 this 指针</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 调用回调函数</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 获取函数执行结果</span>        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;          <span class="hljs-comment">// 执行结果是 Promise 实例时</span>          result.<span class="hljs-title function_">then</span>(            <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;              <span class="hljs-title function_">resolve</span>(v);            &#125;,            <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;              <span class="hljs-title function_">reject</span>(r);            &#125;          );        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 不是 Promise 实例时</span>          <span class="hljs-title function_">resolve</span>(result);        &#125;      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-title function_">reject</span>(error);      &#125;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;       <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>);        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;          <span class="hljs-comment">// 执行结果是 Promise 实例时</span>          result.<span class="hljs-title function_">then</span>(            <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;              <span class="hljs-title function_">resolve</span>(v);            &#125;,            <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;              <span class="hljs-title function_">reject</span>(r);            &#125;          );        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 不是 Promise 实例时</span>          <span class="hljs-title function_">resolve</span>(result);        &#125;      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-title function_">reject</span>(error);      &#125;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123;        <span class="hljs-attr">onResolved</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onResolved</span>(self.<span class="hljs-property">PromiseResult</span>);            <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;              result.<span class="hljs-title function_">then</span>(                <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;                  <span class="hljs-title function_">resolve</span>(v);                &#125;,                <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;                  <span class="hljs-title function_">reject</span>(r);                &#125;              );            &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-title function_">resolve</span>(result);            &#125;          &#125; <span class="hljs-keyword">catch</span> (error) &#123;            <span class="hljs-title function_">reject</span>(error);          &#125;        &#125;,        <span class="hljs-attr">onRejected</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">PromiseResult</span>);            <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;              result.<span class="hljs-title function_">then</span>(                <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;                  <span class="hljs-title function_">resolve</span>(v);                &#125;,                <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;                  <span class="hljs-title function_">reject</span>(r);                &#125;              );            &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-title function_">resolve</span>(result);            &#125;          &#125; <span class="hljs-keyword">catch</span> (error) &#123;            <span class="hljs-title function_">reject</span>(error);          &#125;        &#125;,      &#125;);    &#125;  &#125;);&#125;;</code></pre></div><h2 id="10-封装函数代码"><a href="#10-封装函数代码" class="headerlink" title="10 封装函数代码"></a>10 封装函数代码</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;  <span class="hljs-comment">// 保存 this 指针</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">type</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 获取函数执行结果</span>        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">type</span>(self.<span class="hljs-property">PromiseResult</span>);        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;          <span class="hljs-comment">// 执行结果是 Promise 实例时</span>          result.<span class="hljs-title function_">then</span>(            <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;              <span class="hljs-title function_">resolve</span>(v);            &#125;,            <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;              <span class="hljs-title function_">reject</span>(r);            &#125;          );        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 不是 Promise 实例时</span>          <span class="hljs-title function_">resolve</span>(result);        &#125;      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-title function_">reject</span>(error);      &#125;    &#125;    <span class="hljs-comment">// 调用回调函数</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;      <span class="hljs-title function_">callback</span>(onResolved);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;      <span class="hljs-title function_">callback</span>(onRejected);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123;        <span class="hljs-attr">onResolved</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-title function_">callback</span>(onResolved);        &#125;,        <span class="hljs-attr">onRejected</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-title function_">callback</span>(onRejected);        &#125;,      &#125;);    &#125;  &#125;);&#125;;</code></pre></div><h2 id="11-catch"><a href="#11-catch" class="headerlink" title="11 catch()"></a>11 catch()</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 Promise 添加 catch() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected);&#125;;</code></pre></div><h2 id="12-添加默认函数参数"><a href="#12-添加默认函数参数" class="headerlink" title="12 添加默认函数参数"></a>12 添加默认函数参数</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;  <span class="hljs-comment">// 保存 this 指针</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 判断是否传递了失败回调</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    onRejected = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;      <span class="hljs-keyword">throw</span> reason;    &#125;;  &#125;    <span class="hljs-comment">// 判断是否传递了成功回调</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onResolved !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    onResolved = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> value;    &#125;;  &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">type</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 获取函数执行结果</span>        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">type</span>(self.<span class="hljs-property">PromiseResult</span>);        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;          <span class="hljs-comment">// 执行结果是 Promise 实例时</span>          result.<span class="hljs-title function_">then</span>(            <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;              <span class="hljs-title function_">resolve</span>(v);            &#125;,            <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;              <span class="hljs-title function_">reject</span>(r);            &#125;          );        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 不是 Promise 实例时</span>          <span class="hljs-title function_">resolve</span>(result);        &#125;      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-title function_">reject</span>(error);      &#125;    &#125;    <span class="hljs-comment">// 调用回调函数</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;      <span class="hljs-title function_">callback</span>(onResolved);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;      <span class="hljs-title function_">callback</span>(onRejected);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123;        <span class="hljs-attr">onResolved</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-title function_">callback</span>(onResolved);        &#125;,        <span class="hljs-attr">onRejected</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-title function_">callback</span>(onRejected);        &#125;,      &#125;);    &#125;  &#125;);&#125;;</code></pre></div><h2 id="13-Promise-resolve"><a href="#13-Promise-resolve" class="headerlink" title="13 Promise.resolve()"></a>13 Promise.resolve()</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加 Promise.resolve 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;      value.<span class="hljs-title function_">then</span>(        <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;          <span class="hljs-title function_">resolve</span>(v);        &#125;,        <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;          <span class="hljs-title function_">reject</span>(r);        &#125;      );    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-title function_">resolve</span>(value);    &#125;  &#125;);&#125;;</code></pre></div><h2 id="14-Promise-reject"><a href="#14-Promise-reject" class="headerlink" title="14 Promise.reject()"></a>14 Promise.reject()</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加 Promise.reject 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(value);  &#125;);&#125;;</code></pre></div><h2 id="15-Promise-all"><a href="#15-Promise-all" class="headerlink" title="15 Promise.all()"></a>15 Promise.all()</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加 Promise.all 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> results = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;      promises[i].<span class="hljs-title function_">then</span>(        <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;          count++;          results[i] = v;          <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) &#123;            <span class="hljs-title function_">resolve</span>(results);          &#125;        &#125;,        <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;          <span class="hljs-title function_">reject</span>(r);        &#125;      );    &#125;  &#125;);&#125;;</code></pre></div><h2 id="16-Promise-race"><a href="#16-Promise-race" class="headerlink" title="16 Promise.race()"></a>16 Promise.race()</h2><p>​</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 添加 <span class="hljs-built_in">Promise</span>.race 方法<span class="hljs-built_in">Promise</span>.race = function (promises) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; promises.length; i++) &#123;      promises.<span class="hljs-keyword">then</span>(        <span class="hljs-function"><span class="hljs-params">(v)</span> =&gt;</span> &#123;          resolve(v);        &#125;,        <span class="hljs-function"><span class="hljs-params">(r)</span> =&gt;</span> &#123;          reject(r);        &#125;      );    &#125;  &#125;);&#125;;</code></pre></div><h2 id="17-异步执行-then-回调"><a href="#17-异步执行-then-回调" class="headerlink" title="17 异步执行 then() 回调"></a>17 异步执行 then() 回调</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;  <span class="hljs-comment">// 添加属性</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;pending&quot;</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// 保存回调</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span> = [];  <span class="hljs-comment">// 保存实例对象的 this</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 声明 resolve 和 reject 两个函数参数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;    <span class="hljs-comment">// 调用 onResolved</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      self.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;        item.<span class="hljs-title function_">onResolved</span>(data);      &#125;);    &#125;);  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>    self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;rejected&quot;</span>;    <span class="hljs-comment">// 2. 返回结果值</span>    self.<span class="hljs-property">PromiseResult</span> = data;    <span class="hljs-comment">// 调用 onRejected</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      self.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;        item.<span class="hljs-title function_">onRejected</span>(data);      &#125;);    &#125;);  &#125;  <span class="hljs-comment">// 同步调用执行器函数</span>  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-title function_">executor</span>(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-comment">// 捕获异常，修改状态</span>    <span class="hljs-title function_">reject</span>(e);  &#125;&#125;<span class="hljs-comment">// 给 Promise 添加 then() 方法</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;  <span class="hljs-comment">// 保存 this 指针</span>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 判断是否传递了失败回调</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    onRejected = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;      <span class="hljs-keyword">throw</span> reason;    &#125;;  &#125;  <span class="hljs-comment">// 判断是否传递了成功回调</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onResolved !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    onResolved = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> value;    &#125;;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">type</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 获取函数执行结果</span>        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">type</span>(self.<span class="hljs-property">PromiseResult</span>);        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;          <span class="hljs-comment">// 执行结果是 Promise 实例时</span>          result.<span class="hljs-title function_">then</span>(            <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;              <span class="hljs-title function_">resolve</span>(v);            &#125;,            <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;              <span class="hljs-title function_">reject</span>(r);            &#125;          );        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 不是 Promise 实例时</span>          <span class="hljs-title function_">resolve</span>(result);        &#125;      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-title function_">reject</span>(error);      &#125;    &#125;    <span class="hljs-comment">// 调用回调函数</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">callback</span>(onResolved);      &#125;);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">callback</span>(onRejected);      &#125;);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123;        <span class="hljs-attr">onResolved</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-title function_">callback</span>(onResolved);        &#125;,        <span class="hljs-attr">onRejected</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-title function_">callback</span>(onRejected);        &#125;,      &#125;);    &#125;  &#125;);&#125;;</code></pre></div><h2 id="18-class-形式"><a href="#18-class-形式" class="headerlink" title="18 class 形式"></a>18 class 形式</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;  <span class="hljs-comment">// 构造函数</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 添加属性</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;pending&quot;</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-comment">// 保存回调</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span> = [];    <span class="hljs-comment">// 保存实例对象的 this</span>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;    <span class="hljs-comment">// 声明 resolve 和 reject 两个函数参数</span>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;      <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;      <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>      self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;      <span class="hljs-comment">// 2. 返回结果值</span>      self.<span class="hljs-property">PromiseResult</span> = data;      <span class="hljs-comment">// 调用 onResolved</span>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        self.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;          item.<span class="hljs-title function_">onResolved</span>(data);        &#125;);      &#125;);    &#125;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">data</span>) &#123;      <span class="hljs-comment">// 如果状态不是 pending 则不执行函数</span>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">PromiseState</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;      <span class="hljs-comment">// 1. 修改 Promise 对象的状态</span>      self.<span class="hljs-property">PromiseState</span> = <span class="hljs-string">&quot;rejected&quot;</span>;      <span class="hljs-comment">// 2. 返回结果值</span>      self.<span class="hljs-property">PromiseResult</span> = data;      <span class="hljs-comment">// 调用 onRejected</span>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        self.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;          item.<span class="hljs-title function_">onRejected</span>(data);        &#125;);      &#125;);    &#125;    <span class="hljs-comment">// 同步调用执行器函数</span>    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-comment">// 捕获异常，修改状态</span>      <span class="hljs-title function_">reject</span>(e);    &#125;  &#125;  <span class="hljs-comment">// 给 Promise 添加 then() 方法</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;    <span class="hljs-comment">// 保存 this 指针</span>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;    <span class="hljs-comment">// 判断是否传递了失败回调</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&quot;function&quot;</span>) &#123;      onRejected = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;        <span class="hljs-keyword">throw</span> reason;      &#125;;    &#125;    <span class="hljs-comment">// 判断是否传递了成功回调</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onResolved !== <span class="hljs-string">&quot;function&quot;</span>) &#123;      onResolved = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> value;      &#125;;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">type</span>) &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">// 获取函数执行结果</span>          <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">type</span>(self.<span class="hljs-property">PromiseResult</span>);          <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;            <span class="hljs-comment">// 执行结果是 Promise 实例时</span>            result.<span class="hljs-title function_">then</span>(              <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;                <span class="hljs-title function_">resolve</span>(v);              &#125;,              <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;                <span class="hljs-title function_">reject</span>(r);              &#125;            );          &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 不是 Promise 实例时</span>            <span class="hljs-title function_">resolve</span>(result);          &#125;        &#125; <span class="hljs-keyword">catch</span> (error) &#123;          <span class="hljs-title function_">reject</span>(error);        &#125;      &#125;      <span class="hljs-comment">// 调用回调函数</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-title function_">callback</span>(onResolved);        &#125;);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-title function_">callback</span>(onRejected);        &#125;);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123;          <span class="hljs-attr">onResolved</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;            <span class="hljs-title function_">callback</span>(onResolved);          &#125;,          <span class="hljs-attr">onRejected</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;            <span class="hljs-title function_">callback</span>(onRejected);          &#125;,        &#125;);      &#125;    &#125;);  &#125;  <span class="hljs-comment">// 给 Promise 添加 catch() 方法</span>  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected);  &#125;  <span class="hljs-comment">// 添加 Promise.resolve 方法</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;        value.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;            <span class="hljs-title function_">resolve</span>(v);          &#125;,          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;            <span class="hljs-title function_">reject</span>(r);          &#125;        );      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-title function_">resolve</span>(value);      &#125;    &#125;);  &#125;  <span class="hljs-comment">// 添加 Promise.reject 方法</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-title function_">reject</span>(value);    &#125;);  &#125;  <span class="hljs-comment">// 添加 Promise.all 方法</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;      <span class="hljs-keyword">const</span> results = [];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;        promises[i].<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;            count++;            results[i] = v;            <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(results);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;            <span class="hljs-title function_">reject</span>(r);          &#125;        );      &#125;    &#125;);  &#125;  <span class="hljs-comment">// 添加 Promise.race 方法</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;        promises[i].<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;            <span class="hljs-title function_">resolve</span>(v);          &#125;,          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;            <span class="hljs-title function_">reject</span>(r);          &#125;        );      &#125;    &#125;);  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】19.代理与反射</title>
    <link href="/archives/a7feff9c.html"/>
    <url>/archives/a7feff9c.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-代理基础"><a href="#1-代理基础" class="headerlink" title="1 代理基础"></a>1 代理基础</h1><p>ECMAScript 6 新增的<strong>代理和反射</strong>为开发者提供了<strong>拦截</strong>并向基本操作中嵌入额外行为的能力。可以给目标对象定义一个关联的代理对象，这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响到目标对象之前，可以在代理对象中对这些操作加以控制。</p><h2 id="1-1-创建空代理"><a href="#1-1-创建空代理" class="headerlink" title="1.1 创建空代理"></a>1.1 创建空代理</h2><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。要创建空代理可以传一个简单的对象字面量作为处理程序对象，从而让所有操作都能无阻地抵达目标对象。</p><p>定义目标对象和代理对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<span class="hljs-comment">// 目标对象</span>  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;&#125;);<span class="hljs-comment">// 代理对象</span></code></pre></div><p>访问代理对象等同于访问目标对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);<span class="hljs-comment">// bar</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// bar</span></code></pre></div><p>修改目标对象或者代理对象的属性会同时反映在两个对象上：</p><div class="code-wrapper"><pre><code class="hljs javascript">proxy.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;baz&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);<span class="hljs-comment">// baz</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// baz</span></code></pre></div><p>注意：</p><ol><li><p>Proxy.prototype 是 undefined，因此不能使用 instanceof 操作符。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Proxy</span>);<span class="hljs-comment">// 报错</span></code></pre></div></li><li><p>严格相等可以用来区分代理和目标</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy === target);<span class="hljs-comment">// false</span></code></pre></div></li></ol><h2 id="1-2-定义捕获器"><a href="#1-2-定义捕获器" class="headerlink" title="1.2 定义捕获器"></a>1.2 定义捕获器</h2><p><strong>捕获器</strong>就是处理程序对象中定义的基本操作拦截器。每个处理程序对象可以包含多个捕获器，每个捕获器对应一种基本操作，可以直接或者间接在代理对象上调用。每次在<strong>代理对象</strong>上调用这些基本操作时，代理会调用捕获器函数，从而拦截并修改默认行为。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;;<span class="hljs-keyword">const</span> handler = &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 定义一个 get() 捕获器</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;baz&quot;</span>;<span class="hljs-comment">// 修改 get() 行为</span>  &#125;,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// baz （捕获器起作用了）</span></code></pre></div><h2 id="1-3-捕获器参数和反射-API"><a href="#1-3-捕获器参数和反射-API" class="headerlink" title="1.3 捕获器参数和反射 API"></a>1.3 捕获器参数和反射 API</h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的默认行为。比如，get() 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;;<span class="hljs-keyword">const</span> handler = &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params">trapTarget, property, receiver</span>) &#123;    <span class="hljs-keyword">return</span> trapTarget[property] + <span class="hljs-string">&quot;!&quot;</span>;<span class="hljs-comment">// 在原有属性上加一个叹号</span>  &#125;,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// bar!</span></code></pre></div><p>开发者并不需要手写重建行为，而是可以通过调用全局的 <strong>Reflect 对象</strong>（封装了原始行为）的同名方法来轻松重建。处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）方法。这些方法和捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。</p><p>因此，使用反射 API 也可以像下面这样定义出空代理对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;;<span class="hljs-keyword">const</span> handler = &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);  &#125;,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// bar</span></code></pre></div><p>事实上，如果想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, <span class="hljs-title class_">Reflect</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// bar</span></code></pre></div><p>反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;;<span class="hljs-keyword">const</span> handler = &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>) + <span class="hljs-string">&quot;!&quot;</span>;  &#125;,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// bar!</span></code></pre></div><h2 id="1-4-捕获器不变式"><a href="#1-4-捕获器不变式" class="headerlink" title="1.4 捕获器不变式"></a>1.4 捕获器不变式</h2><p>使用捕获器几乎可以修改所有基本方法的行为，但是也不是没有限制。每个捕获器都知道目标对象的上下文捕获函数签名，而捕获处理程序的行为必须遵循<strong>捕获器不变式</strong>。捕获器不变式因方法不同而异，但是通常都是防止在捕获器中出现过于反常的行为。</p><p>比如，如果目标对象上有一个不可修改的属性，那么 get() 捕获器就不可以返回不同的值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, <span class="hljs-string">&quot;foo&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-comment">// 定义一个不可修改属性 foo</span>&#125;);<span class="hljs-keyword">const</span> handler = &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;baz&quot;</span>;<span class="hljs-comment">// 返回的值和定义时的不同</span>  &#125;,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// 报错</span></code></pre></div><h2 id="1-5-可撤销代理"><a href="#1-5-可撤销代理" class="headerlink" title="1.5 可撤销代理"></a>1.5 可撤销代理</h2><p>Proxy 暴露了revocable() 方法，这个方法可以支持撤销代理对象和目标对象的关联。撤销函数是幂等的，调用多少次都一样。撤销之后再调用代理会报错。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;  <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;;<span class="hljs-keyword">const</span> &#123; proxy, revoke &#125; = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(target, &#123;&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// bar</span><span class="hljs-title function_">revoke</span>();<span class="hljs-comment">// 调用撤销函数</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<span class="hljs-comment">// 再次调用代理会报错</span></code></pre></div><h2 id="1-6-优先使用反射-API"><a href="#1-6-优先使用反射-API" class="headerlink" title="1.6 优先使用反射 API"></a>1.6 优先使用反射 API</h2><p>在某些情况下应该优先使用反射 API。</p><h3 id="1-6-1-反射-API-和对象-API"><a href="#1-6-1-反射-API-和对象-API" class="headerlink" title="1.6.1 反射 API 和对象 API"></a>1.6.1 反射 API 和对象 API</h3><ol><li>反射 API 并不限于捕获处理程序</li><li>大多数反射 API 方法在 Object 类型上有对应的方法</li></ol><p>通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制和操作。</p><h3 id="1-6-2-状态标记（？）"><a href="#1-6-2-状态标记（？）" class="headerlink" title="1.6.2 状态标记（？）"></a>1.6.2 状态标记（？）</h3><p>很多反射方法返回称为状态标记的布尔值，表示执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误的方法更有用。</p><p>初始代码：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-keyword">try</span> &#123;  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (e) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);&#125;</code></pre></div><p>使用反射方法重构：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;success&quot;</span>);<span class="hljs-comment">// 此处仍然报错？</span>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;failure&quot;</span>);&#125;</code></pre></div><h3 id="1-6-3-用反射方法替操作符"><a href="#1-6-3-用反射方法替操作符" class="headerlink" title="1.6.3 用反射方法替操作符"></a>1.6.3 用反射方法替操作符</h3><p>以下反射方法提供只有通过操作符才能完成的操作。</p><ol><li>Reflect.get()：可以代替对象属性访问操作符<code>.</code></li><li>Refilect.set()：可以代替赋值操作符<code>=</code></li><li>Reflect.has()：可以代替 in 或者 with()</li><li>Reflect.deleteProperty()：可以代替 delete</li><li>Reflect.construct()：可以代替 new</li></ol><h3 id="1-6-4-安全地应用函数"><a href="#1-6-4-安全地应用函数" class="headerlink" title="1.6.4 安全地应用函数"></a>1.6.4 安全地应用函数</h3><p>在通过 apply 方法调用函数时，被调用地函数可能也定义了自己的 apply 属性。</p><p>为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span>.<span class="hljs-title function_">call</span>(fn,thisVal,argumentList)</code></pre></div><p>也可以使用 Reflect.apply 来避免：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(fn,thisVal,argumentList)</code></pre></div><h2 id="1-7-代理另一个代理"><a href="#1-7-代理另一个代理" class="headerlink" title="1.7 代理另一个代理"></a>1.7 代理另一个代理</h2><p>可以创建一个代理来代理另一个代理，在一个目标对象上构建多层拦截网。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span> &#125;;<span class="hljs-keyword">const</span> handler1 = &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>) + <span class="hljs-string">&quot;!&quot;</span>;<span class="hljs-comment">// 拦截器1</span>  &#125;,&#125;;<span class="hljs-keyword">const</span> handler2 = &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>) + <span class="hljs-string">&quot;.&quot;</span>;<span class="hljs-comment">// 拦截器2</span>  &#125;,&#125;;<span class="hljs-keyword">const</span> proxy1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler1);<span class="hljs-keyword">const</span> proxy2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(proxy1, handler2);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy2.<span class="hljs-property">foo</span>);<span class="hljs-comment">// bar!.</span></code></pre></div><h2 id="1-8-代理的问题和不足"><a href="#1-8-代理的问题和不足" class="headerlink" title="1.8 代理的问题和不足"></a>1.8 代理的问题和不足</h2><h3 id="1-8-1-代理中的-this-值"><a href="#1-8-1-代理中的-this-值" class="headerlink" title="1.8.1 代理中的 this 值"></a>1.8.1 代理中的 this 值</h3><p>大多数情况下，this 值符合预期。但是，如果目标对象依赖于对象标识，那可能遇到意料之外的问题。</p><h3 id="1-8-2-代理与内部槽位"><a href="#1-8-2-代理与内部槽位" class="headerlink" title="1.8.2 代理与内部槽位"></a>1.8.2 代理与内部槽位</h3><p>有些内置类型可能会依赖代理无法控制的机制，导致出错。</p><p>比如，Date 类型方法的执行依赖 this 值上的内部槽位<code>[[NumberDate]]</code>。代理对象上不存在这个槽位，于是会出现问题。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;&#125;);proxy.<span class="hljs-title function_">getDate</span>();<span class="hljs-comment">// 报错</span></code></pre></div><h1 id="2-代理捕获器和反射方法"><a href="#2-代理捕获器和反射方法" class="headerlink" title="2 代理捕获器和反射方法"></a>2 代理捕获器和反射方法</h1><p>代理可以捕获 <strong>13</strong> 种不同的基本操作。这些操作中各自有不同的反射 API 方法、参数、关联操作和不变式。</p><h2 id="2-1-get"><a href="#2-1-get" class="headerlink" title="2.1 get()"></a>2.1 get()</h2><p>get() 捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 Reflect.get()。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;get()&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);  &#125;,&#125;);proxy.<span class="hljs-property">foo</span>;<span class="hljs-comment">// get()</span></code></pre></div><h3 id="2-1-1-返回值"><a href="#2-1-1-返回值" class="headerlink" title="2.1.1 返回值"></a>2.1.1 返回值</h3><p>返回值无限制</p><h3 id="2-1-2-拦截的操作"><a href="#2-1-2-拦截的操作" class="headerlink" title="2.1.2 拦截的操作"></a>2.1.2 拦截的操作</h3><ul><li>proxy.property</li><li>proxy[property]</li><li>Object.create(proxy)[property]</li><li>Reflect.get(proxy, property, receiver)</li></ul><h3 id="2-1-3-捕获器处理程序参数"><a href="#2-1-3-捕获器处理程序参数" class="headerlink" title="2.1.3 捕获器处理程序参数"></a>2.1.3 捕获器处理程序参数</h3><ol><li><p>target：目标对象。</p></li><li><p>property：引用的目标对象上的字符串（或 Symbol ）键属性。</p></li><li><p>receiver：代理对象或继承代理对象的对象。</p></li></ol><h3 id="2-1-4-捕获器不变式"><a href="#2-1-4-捕获器不变式" class="headerlink" title="2.1.4  捕获器不变式"></a>2.1.4  捕获器不变式</h3><p>如果 target.property 不可写且不可配置，则处理程序返回的值必须与 target.property 匹配。<br>如果 target.property 不可配置且<code>[[Get]]</code>特性为undefined，处理程序的返回值也必须是 undefined。</p><h2 id="2-2-set"><a href="#2-2-set" class="headerlink" title="2.2 set()"></a>2.2 set()</h2><p>set()捕获器会在设置属性值的操作中被调用。对应的反射API 方法为Reflect.set()。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set()&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);  &#125;,&#125;);proxy.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<span class="hljs-comment">// set()</span></code></pre></div><h3 id="2-2-1-返回值"><a href="#2-2-1-返回值" class="headerlink" title="2.2.1 返回值"></a>2.2.1 返回值</h3><p>返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。</p><h3 id="2-2-2-拦截的操作"><a href="#2-2-2-拦截的操作" class="headerlink" title="2.2.2 拦截的操作"></a>2.2.2 拦截的操作</h3><ul><li>proxy.property &#x3D; value</li><li>proxy[property] &#x3D; value</li><li>Object.create(proxy)[property] &#x3D; value</li><li>Reflect.set(proxy, property, value, receiver)</li></ul><h3 id="2-2-3-捕获器处理程序参数"><a href="#2-2-3-捕获器处理程序参数" class="headerlink" title="2.2.3 捕获器处理程序参数"></a>2.2.3 捕获器处理程序参数</h3><ol><li>target：目标对象。</li><li>property：引用的目标对象上的字符串键属性。</li><li>value：要赋给属性的值。</li><li>receiver：接收最初赋值的对象。</li></ol><h3 id="2-2-4-捕获器不变式"><a href="#2-2-4-捕获器不变式" class="headerlink" title="2.2.4  捕获器不变式"></a>2.2.4  捕获器不变式</h3><p>如果 target.property 不可写且不可配置，则不能修改目标属性的值。<br>如果 target.property 不可配置且<code>[[Set]]</code>特性为 undefined，则不能修改目标属性的值。<br>在严格模式下，处理程序中返回 false 会抛出 TypeError。</p><h2 id="2-3-has"><a href="#2-3-has" class="headerlink" title="2.3 has()"></a>2.3 has()</h2><p>has()捕获器会在in 操作符中被调用。对应的反射API 方法为 Reflect.has()。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;has()&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(...<span class="hljs-variable language_">arguments</span>);  &#125;,&#125;);<span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-keyword">in</span> proxy;<span class="hljs-comment">// has()</span></code></pre></div><h3 id="2-3-1-返回值"><a href="#2-3-1-返回值" class="headerlink" title="2.3.1 返回值"></a>2.3.1 返回值</h3><p>has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</p><h3 id="2-3-2-拦截的操作"><a href="#2-3-2-拦截的操作" class="headerlink" title="2.3.2 拦截的操作"></a>2.3.2 拦截的操作</h3><ul><li>property in proxy</li><li>property in Object.create(proxy)</li><li>with(proxy) {(property);}</li><li>Reflect.has(proxy, property)</li></ul><h3 id="2-3-3-捕获器处理程序参数"><a href="#2-3-3-捕获器处理程序参数" class="headerlink" title="2.3.3 捕获器处理程序参数"></a>2.3.3 捕获器处理程序参数</h3><ol><li>target：目标对象。</li><li>property：引用的目标对象上的字符串键属性。</li></ol><h3 id="2-3-4-捕获器不变式"><a href="#2-3-4-捕获器不变式" class="headerlink" title="2.3.4 捕获器不变式"></a>2.3.4 捕获器不变式</h3><p>如果 target.property 存在且不可配置，则处理程序必须返回 true。<br>如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</p><h2 id="2-4-其它捕获器"><a href="#2-4-其它捕获器" class="headerlink" title="2.4 其它捕获器"></a>2.4 其它捕获器</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><h1 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3 代理模式"></a>3 代理模式</h1><h2 id="3-1-跟踪属性访问"><a href="#3-1-跟踪属性访问" class="headerlink" title="3.1 跟踪属性访问"></a>3.1 跟踪属性访问</h2><p>通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、修改和查询。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jake&quot;</span>,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(user, &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">$&#123;property&#125;</span>`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);  &#125;,  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting <span class="hljs-subst">$&#123;property&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);  &#125;,&#125;);proxy.<span class="hljs-property">name</span>; <span class="hljs-comment">// Getting name</span>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">27</span>; <span class="hljs-comment">// Setting age=27</span></code></pre></div><h2 id="3-2-隐藏属性"><a href="#3-2-隐藏属性" class="headerlink" title="3.2 隐藏属性"></a>3.2 隐藏属性</h2><p>通过代理可以隐藏目标对象身上的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hiddenProperties = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>];<span class="hljs-keyword">const</span> targetObject = &#123;  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">baz</span>: <span class="hljs-number">3</span>,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(targetObject, &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property</span>) &#123;    <span class="hljs-keyword">if</span> (hiddenProperties.<span class="hljs-title function_">includes</span>(property)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);    &#125;  &#125;,  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;    <span class="hljs-keyword">if</span> (hiddenProperties.<span class="hljs-title function_">includes</span>(property)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(...<span class="hljs-variable language_">arguments</span>);    &#125;  &#125;,&#125;);<span class="hljs-comment">// get()</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>); <span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">bar</span>); <span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">baz</span>); <span class="hljs-comment">// 3</span><span class="hljs-comment">// has()</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar&quot;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;baz&quot;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// true</span></code></pre></div><h2 id="3-3-属性验证"><a href="#3-3-属性验证" class="headerlink" title="3.3 属性验证"></a>3.3 属性验证</h2><p>因为所有赋值操作都会触发set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;  <span class="hljs-attr">onlyNumbersGoHere</span>: <span class="hljs-number">0</span>,&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&quot;number&quot;</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);    &#125;  &#125;,&#125;);proxy.<span class="hljs-property">onlyNumbersGoHere</span> = <span class="hljs-number">1</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">onlyNumbersGoHere</span>); <span class="hljs-comment">// 1</span>proxy.<span class="hljs-property">onlyNumbersGoHere</span> = <span class="hljs-string">&quot;2&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">onlyNumbersGoHere</span>); <span class="hljs-comment">// 1</span></code></pre></div><h2 id="3-4-函数与构造函数参数验证"><a href="#3-4-函数与构造函数参数验证" class="headerlink" title="3.4 函数与构造函数参数验证"></a>3.4 函数与构造函数参数验证</h2><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">...nums</span>) &#123;  <span class="hljs-keyword">return</span> nums.<span class="hljs-title function_">sort</span>()[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(nums.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)];&#125;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(median, &#123;  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> argumentsList) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg !== <span class="hljs-string">&quot;number&quot;</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Non-number argument provided&quot;</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(...<span class="hljs-variable language_">arguments</span>);  &#125;,&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 4</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">// Error: Non-number argument provided</span></code></pre></div><p>类似地，可以要求实例化时必须给构造函数传参：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id_</span> = id;  &#125;&#125;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123;    <span class="hljs-keyword">if</span> (argumentsList[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;User cannot be instantiated without id&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);    &#125;  &#125;,&#125;);<span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>();<span class="hljs-comment">// Error: User cannot be instantiated without id</span></code></pre></div><h2 id="3-5-数据绑定与可观察对象"><a href="#3-5-数据绑定与可观察对象" class="headerlink" title="3.5 数据绑定与可观察对象"></a>3.5 数据绑定与可观察对象</h2><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。<br>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userList = [];<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = name;  &#125;&#125;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;  <span class="hljs-title function_">construct</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> newUser = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);    userList.<span class="hljs-title function_">push</span>(newUser);    <span class="hljs-keyword">return</span> newUser;  &#125;,&#125;);<span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&quot;John&quot;</span>);<span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&quot;Jacob&quot;</span>);<span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&quot;Jingleheimerschmidt&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userList); <span class="hljs-comment">// [User &#123;&#125;, User &#123;&#125;, User&#123;&#125;]</span></code></pre></div><p>另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userList = [];<span class="hljs-keyword">function</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params">newValue</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue);&#125;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(userList, &#123;  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);    <span class="hljs-keyword">if</span> (result) &#123;      <span class="hljs-title function_">emit</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver));    &#125;    <span class="hljs-keyword">return</span> result;  &#125;,&#125;);proxy.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;John&quot;</span>);<span class="hljs-comment">// John</span>proxy.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Jacob&quot;</span>);<span class="hljs-comment">// Jacob</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】18.迭代器和生成器</title>
    <link href="/archives/88df9c3f.html"/>
    <url>/archives/88df9c3f.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1 迭代器"></a>1 迭代器</h1><p><strong>可迭代对象</strong>实现了 Iterable 接口（可迭代协议），可以通过<strong>迭代器</strong>来操作。这种对象类似数组或者集合，包含的有限的元素，并且有无歧义的遍历顺序。不过，可迭代对象不一定都是集合对象，也可以是仅仅具有类似行为的其它数据结构。</p><p>任何实现 Iterable 接口（可迭代协议）的数据结构都可以被实现 Iterator 接口（迭代器协议）的结构“消费”。<strong>迭代器</strong>是按需创建的一次性对象。每个迭代器都<strong>关联</strong>一个可迭代对象，而迭代器会暴露其关联可迭代对象的 API。迭代器不需要知道与其关联的可迭代对象的结构，只需要知道如何取得连续的值。</p><h2 id="1-1-可迭代协议"><a href="#1-1-可迭代协议" class="headerlink" title="1.1 可迭代协议"></a>1.1 可迭代协议</h2><p>实现 Iterator 接口（可迭代协议）要求同时具备支持迭代的自我识别能力和和创建实现 Iterator 接口的对象的能力。在 ECMAScript 中，这意味着必须暴露一个 Symbol.iterator 属性作为“默认迭代器”。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。</p><p>很多内置类型都实现了 Iterator 接口。包括字符串、数组、Map、Set、arguments 对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 没有实现迭代器工厂函数的类型</span><span class="hljs-keyword">const</span> num = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]);<span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]);<span class="hljs-comment">// undefined</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现了迭代器工厂函数的类型</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]);<span class="hljs-comment">// [Function: values]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]);<span class="hljs-comment">// [Function: values]</span></code></pre></div><p>调用迭代器工厂函数会返回一个迭代器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]());<span class="hljs-comment">// Object [Array Iterator] &#123;&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]());<span class="hljs-comment">// [Set Iterator] &#123; 1, 2, 3 &#125;</span></code></pre></div><p>实际写代码过程中，不需要<strong>显式调用</strong>这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：for-of 循环、数组解构、扩展操作符、Array.from()、创建集合、创建映射等等。</p><p>这些原生的语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-comment">// for-of 循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 1 2 3</span>&#125;<span class="hljs-comment">// 数组解构</span><span class="hljs-keyword">const</span> [a, b, c] = arr;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c);<span class="hljs-comment">// 1 2 3</span><span class="hljs-comment">// 扩展操作符</span><span class="hljs-keyword">let</span> arr2 = [...arr];<span class="hljs-comment">// 使用 Array.from() 赋值数组</span><span class="hljs-keyword">let</span> arr3 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr);<span class="hljs-comment">// 创建集合</span><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<span class="hljs-comment">// 创建映射</span><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x, i</span>) =&gt;</span> [i, x]))<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map);<span class="hljs-comment">// Map(3) &#123; 0 =&gt; 1, 1 =&gt; 2, 2 =&gt; 3 &#125;</span></code></pre></div><h2 id="1-2-迭代器协议"><a href="#1-2-迭代器协议" class="headerlink" title="1.2 迭代器协议"></a>1.2 迭代器协议</h2><p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。</p><p>迭代器 API 使用 next() 方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。</p><p>next() 方法返回的迭代器对象IteratorResult 包含两个属性：done 和 value。done 是一个布尔值，表示是否还可以再次调用 next() 取得下一个值；value 包含可迭代对象的下一个值（done 为 false），或者 undefined（done 为 true）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>];<span class="hljs-keyword">const</span> iter = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: &#x27;foo&#x27;, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: &#x27;bar&#x27;, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span></code></pre></div><p>迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达<code>done: true</code> 状态，后续调用 next() 就一直返回 undefined。</p><p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>];<span class="hljs-keyword">let</span> iter1 = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<span class="hljs-keyword">let</span> iter2 = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter1.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter2.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter2.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter1.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></code></pre></div><p>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>];<span class="hljs-keyword">let</span> iter = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span><span class="hljs-comment">// 在数组中间插入值</span>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: false, value: &#x27;baz&#x27; &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; done: true, value: undefined &#125;</span></code></pre></div><h2 id="1-3-自定义迭代器"><a href="#1-3-自定义迭代器" class="headerlink" title="1.3 自定义迭代器"></a>1.3 自定义迭代器</h2><p>与 Iterator 接口类似，任何实现 Iterator 接口的对象都可以作为迭代器使用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">limit</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span> = limit;  &#125;  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> limit = <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span>;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 返回一个对象，这个实现 next() 方法，按规定返回内容</span>        <span class="hljs-keyword">if</span> (count &lt;= limit) &#123;          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: count++ &#125;;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span> &#125;;        &#125;      &#125;,    &#125;;  &#125;&#125;<span class="hljs-keyword">let</span> counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> counter) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 1 2 3</span>&#125;</code></pre></div><h2 id="1-4-提前终止迭代器"><a href="#1-4-提前终止迭代器" class="headerlink" title="1.4 提前终止迭代器"></a>1.4 提前终止迭代器</h2><p>可选的 return() 方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括：</p><ul><li>for-of 循环通过 break、continue、return 或 throw 提前退出</li><li>解构操作并未消费所有值</li></ul><p>return() 方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回 <code>&#123; done: true &#125;</code>。内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用 return() 方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">limit</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span> = limit;  &#125;  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> limit = <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span>;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">if</span> (count &lt;= limit) &#123;          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: count++ &#125;;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span> &#125;;        &#125;      &#125;,      <span class="hljs-keyword">return</span>() &#123;<span class="hljs-comment">// 提前终止迭代器时访问 return()</span>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;      &#125;,    &#125;;  &#125;&#125;<span class="hljs-keyword">let</span> counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> counter) &#123;  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 终止迭代器</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 1 2 </span>&#125;</code></pre></div><p>如果迭代器没有关闭，则还可以从上次的位置<strong>继续迭代</strong>。比如，数组的迭代器就是不能关闭的。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">const</span> iter = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> iter) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 1 2 3 </span>  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">break</span>;  &#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> iter) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 4 5</span>&#125;</code></pre></div><p>因为 return() 方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法<strong>并不能</strong>让它变成可关闭的。这是因为调用 return() <strong>不会</strong>强制迭代器进入关闭状态。即便如此，return() 方法还是会被调用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">const</span> iter = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();iter.<span class="hljs-property">return</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Exiting early&quot;</span>);  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> iter) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 1 2 3 Exiting early</span>  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">break</span>;  &#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> iter) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 4 5</span>&#125;</code></pre></div><h1 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2 生成器"></a>2 生成器</h1><p><strong>生成器</strong>可以在代码块中暂停和恢复代码。使用生成器可以自定义迭代器。</p><h2 id="2-1-生成器基础"><a href="#2-1-生成器基础" class="headerlink" title="2.1 生成器基础"></a>2.1 生成器基础</h2><p>在函数名称前面或者 function 关键字后面加一个星号<code>*</code>表示它是一个生成器。只要是可以定义函数的地方，都可以定义生成器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">let</span> generatorFn = <span class="hljs-keyword">function</span>* () &#123;&#125;;<span class="hljs-keyword">let</span> obj = &#123;  *<span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;&#125;,&#125;;</code></pre></div><blockquote><p><strong>注意</strong>：箭头函数不能用来定义生成器函数。</p></blockquote><p>调用<strong>生成器函数</strong>会产生一个<strong>生成器对象</strong>。生成器对象一开始位于<strong>暂停执行（suspended）</strong>的状态。生成器对象实现了 Iterator 接口，因此有 next() 方法。调用这个方法可以让生成器开始或者恢复执行。next() 方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span></code></pre></div><p>value 属性的返回值可以通过生成器函数的返回值指定，默认返回值是 undefined。<strong>只有在调用 next() 方法后，生成器函数才会开始执行</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-comment">// 此时不执行函数体，只有调用next() 后才执行函数体</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: &#x27;foo&#x27;, done: true &#125;</span></code></pre></div><p>生成器对象实现了 Iterable 接口，默认迭代器即自身。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() === g);</code></pre></div><h2 id="2-2-通过-yield-中断执行"><a href="#2-2-通过-yield-中断执行" class="headerlink" title="2.2 通过 yield 中断执行"></a>2.2 通过 yield 中断执行</h2><p>yield 关键字可以让生成器停止和开始执行。生成器函数在遇到 yield 关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next() 方法来恢复执行。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;foo&quot;</span>;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bar&quot;</span>;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;foo&#x27;, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;bar&#x27;, done: true &#125;</span></code></pre></div><blockquote><p><strong>注意</strong>：</p><ol><li>生成器函数会针对每个生成器对象区分作用域。在一个生成器对象上调用 next() 不影响其它生成器对象。</li><li>yield 关键字只能在生成器内部使用，用在其它地方会抛出错误。</li><li>yield 关键字必须直接定义在生成器函数内部定义中，出现在嵌套的非生成器函数中会抛出错误。</li></ol></blockquote><h3 id="2-2-1-生成器对象作为可迭代对象"><a href="#2-2-1-生成器对象作为可迭代对象" class="headerlink" title="2.2.1 生成器对象作为可迭代对象"></a>2.2.1 生成器对象作为可迭代对象</h3><p>把生成器对象当成可迭代对象，使用起来会更加方便。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">generatorFn</span>()) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<span class="hljs-comment">// 1 2 3</span>&#125;</code></pre></div><h3 id="2-2-2-使用-yield-实现输入输出"><a href="#2-2-2-使用-yield-实现输入输出" class="headerlink" title="2.2.2 使用 yield 实现输入输出"></a>2.2.2 使用 yield 实现输入输出</h3><p>除了可以作为函数的<strong>中间返回语句</strong>使用，yeild 关键字还可以作为<strong>函数中间参数</strong>使用。<em>上一次让生成器函数暂停的 yeild 关键字会接收到传给 next() 方法的第一个值</em>。第一次调用 next() 传入的值不会被使用，因为这一次调用是为了开始执行生成器函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);&#125;<span class="hljs-keyword">let</span> g = <span class="hljs-title function_">generatorFn</span>();g.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;bar&quot;</span>);<span class="hljs-comment">// 没有任何输出，因为这次是为了开始执行生成器函数</span>g.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;baz&quot;</span>);<span class="hljs-comment">// baz</span>g.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;qux&quot;</span>);<span class="hljs-comment">// qux</span></code></pre></div><p>yield 关键字可以同时用于输入和输出。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;bar&quot;</span>));<span class="hljs-comment">// bar</span></code></pre></div><h3 id="2-2-3-使用-yield-产生可迭代对象"><a href="#2-2-3-使用-yield-产生可迭代对象" class="headerlink" title="2.2.3 使用 yield* 产生可迭代对象"></a>2.2.3 使用 yield* 产生可迭代对象</h3><p>使用星号<code>*</code>可以增强 yield 的行为，让它能够迭代一个<strong>可迭代对象</strong>，从而一次产出一个值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">yield</span>* [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> g) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 1 2 3</span>&#125;</code></pre></div><p>这里的 yield* 实际上只是将一个可迭代对象序列化为一连串可以单独产出的值。和把 yield 放在一个循环中没有区别。</p><h2 id="2-3-生成器作为默认迭代器"><a href="#2-3-生成器作为默认迭代器" class="headerlink" title="2.3 生成器作为默认迭代器"></a>2.3 生成器作为默认迭代器</h2><p>因为生成器对象实现了 Iterable 接口，而且生成器函数和默认迭代器工厂函数被调用之后都产生迭代器。因此，生成器适合作为默认的迭代器工厂函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  &#125;  *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;    <span class="hljs-keyword">yield</span>* <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>;  &#125;&#125;<span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> f) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<span class="hljs-comment">// 1 2 3</span>&#125;</code></pre></div><h2 id="2-4-提前终止生成器"><a href="#2-4-提前终止生成器" class="headerlink" title="2.4 提前终止生成器"></a>2.4 提前终止生成器</h2><p>与迭代器类似，生成器也可以提前终止。生成器对象实现了 Iterator 接口，有 next() 和可选的 return() 方法。除了这两个方法，生成器对象还有第三个方法：throw()。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-property">next</span>);<span class="hljs-comment">// [Function: next]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-property">return</span>);<span class="hljs-comment">// [Function: return]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-property">throw</span>);<span class="hljs-comment">// [Function: throw]</span></code></pre></div><p>return() 和 throw() 都可以强制生成器进入<strong>关闭（closed）</strong>状态。</p><h3 id="2-4-1-return"><a href="#2-4-1-return" class="headerlink" title="2.4.1 return()"></a>2.4.1 return()</h3><p>return() 方法会强制生成器进入<strong>关闭（closed）</strong>状态。提供给 return() 方法的值，就是终止迭代器对象的值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) &#123;    <span class="hljs-keyword">yield</span> x;  &#125;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g);<span class="hljs-comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-keyword">return</span>(<span class="hljs-number">4</span>));<span class="hljs-comment">// &#123; value: 4, done: true &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g);<span class="hljs-comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></code></pre></div><p>与迭代器对象不同，所有生成器对象都有 return() 方法，只要通过它进入关闭状态，就无法恢复。后续调用 next() 会显示 <code>done : true</code>状态，而提供的任何返回值都不会被储存或传播。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) &#123;    <span class="hljs-keyword">yield</span> x;  &#125;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: 1, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-keyword">return</span>(<span class="hljs-number">4</span>));<span class="hljs-comment">// &#123; value: 4, done: true &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span></code></pre></div><p>for-of 循环等内置语言结构会忽略状态为 <code>done : true</code> 的 IteratorObject 内部返回的值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) &#123;    <span class="hljs-keyword">yield</span> x;  &#125;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> g) &#123;  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-number">1</span>) &#123;    g.<span class="hljs-keyword">return</span>(<span class="hljs-number">4</span>);  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 1 2 </span>&#125;</code></pre></div><h3 id="2-4-2-throw"><a href="#2-4-2-throw" class="headerlink" title="2.4.2 throw()"></a>2.4.2 throw()</h3><p>throw() 方法会在<strong>暂停</strong>的时候将一个提供的错误注入到生成器对象中。如果错误没有被处理，生成器就会<strong>关闭</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) &#123;    <span class="hljs-keyword">yield</span> x;  &#125;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g);<span class="hljs-comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span><span class="hljs-keyword">try</span> &#123;  g.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&quot;foo&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (e) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<span class="hljs-comment">// foo</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g);<span class="hljs-comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></code></pre></div><p>不过，假如生成器内部处理了这个错误，那么生成器就<strong>不会</strong>被关闭，而且可以恢复执行。错误处理会跳过对应的 yield。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">yield</span> item;    &#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;  &#125;&#125;<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generatorFn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span>g.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// &#123; value: 3, done: false &#125;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】17.函数</title>
    <link href="/archives/4626a015.html"/>
    <url>/archives/4626a015.html</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>ECMAScript 中，函数实际上是对象。每个函数都是 Function 类型的实例，而 Function 也有属性和方法。</p><h2 id="0-定义函数"><a href="#0-定义函数" class="headerlink" title="0 定义函数"></a>0 定义函数</h2><p><strong>函数声明</strong>的方式来定义：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;</code></pre></div><p><strong>函数表达式</strong>的方式来定义：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;;</code></pre></div><p><strong>箭头函数</strong>的方式来定义：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> a + b;&#125;;</code></pre></div><p><strong>Function 构造函数</strong>的方式来定义。这个构造函数接收任意多个字符串参数，最后一个参数会被当成函数体，而前面所有的参数都会被当成新函数的参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;return a + b&quot;</span>);</code></pre></div><blockquote><p><strong>注意</strong>：这几种实例化对象的方式之间存在<strong>微妙区别</strong>。</p></blockquote><h2 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1 箭头函数"></a>1 箭头函数</h2><p>ECMAScript 6 新增了使用 <code>=&gt;</code>定义函数表达式的能力。任何可以使用函数表达式的地方，都可以使用箭头函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数表达式</span><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;;<span class="hljs-comment">// 箭头函数</span><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum2</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> a + b;&#125;;</code></pre></div><p>简洁的语法非常适合于嵌入函数的场景：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> <span class="hljs-number">2</span> * x));<span class="hljs-comment">// [ 2, 4, 6 ]</span></code></pre></div><p>如果只有一个参数，那也可以<strong>省略括号</strong>。只有在没有参数或者多个参数的时候需要括号。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 这两种方式等价</span><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">x</span>) =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x; &#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = x =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x; &#125;;<span class="hljs-comment">// 省略括号</span></code></pre></div><p>也可以<strong>省略大括号</strong>。使用大括号说明包含函数体，可以在一个函数体中写多条语句。如果不使用大括号，那么箭头后面就只能有<strong>一行</strong>代码，比如一个<strong>赋值操作</strong>或者一个<strong>表达式</strong>。<strong>省略大括号会隐式返回这行代码的值</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 这两种方式等价</span><span class="hljs-keyword">let</span> <span class="hljs-title function_">double</span> = (<span class="hljs-params">x</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;&#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">triple</span> = (<span class="hljs-params">x</span>) =&gt; <span class="hljs-number">3</span> * x;<span class="hljs-comment">// 省略大括号，只有一个表达式</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 这两种方式等价</span><span class="hljs-keyword">let</span> <span class="hljs-title function_">setName</span> = (<span class="hljs-params">obj</span>) =&gt; &#123;  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Foo&quot;</span>;&#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">setName</span> = (<span class="hljs-params">obj</span>) =&gt; obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Foo&#x27;</span><span class="hljs-comment">// 省略大括号，只有一个赋值操作 </span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 无效写法</span><span class="hljs-keyword">let</span> <span class="hljs-title function_">multi</span> = (<span class="hljs-params">a,b</span>) =&gt; <span class="hljs-keyword">return</span> a * b</code></pre></div><blockquote><p><strong>注意</strong>：箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数没有 prototype 属性。</p></blockquote><h2 id="2-函数名"><a href="#2-函数名" class="headerlink" title="2 函数名"></a>2 函数名</h2><h3 id="2-1-函数名是指向函数的指针"><a href="#2-1-函数名是指向函数的指针" class="headerlink" title="2.1 函数名是指向函数的指针"></a>2.1 函数名是指向函数的指针</h3><p>因为函数名就是指向函数的变量，所以和其它对象变量具有相同的行为。这意味着，一个函数可以有多个名称。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-keyword">let</span> sum2 = sum;<span class="hljs-comment">// sum 后没有括号</span></code></pre></div><blockquote><p><strong>注意</strong>：使用不带括号的函数名会访问函数指针，而不会执行函数。</p></blockquote><h3 id="2-2-name-属性"><a href="#2-2-name-属性" class="headerlink" title="2.2 name 属性"></a>2.2 name 属性</h3><p>ES6 中所有的函数对象都会暴露一个 name 属性，值是一个字符串化的变量名。</p><p>如果函数没有名称，会显示空串；如果函数是使用 Function 构造函数创建的，则会显示 <code>&#39;anonymous&#39;</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">baz</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">name</span>);<span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">name</span>);<span class="hljs-comment">// bar</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz.<span class="hljs-property">name</span>);<span class="hljs-comment">// baz</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-function">() =&gt;</span> &#123;&#125;).<span class="hljs-property">name</span>);<span class="hljs-comment">// 空串</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>().<span class="hljs-property">name</span>);<span class="hljs-comment">// anonymous</span></code></pre></div><p>如果函数是一个获取函数、设置函数，或者使用 bind() 实例化，那么标识符会加上一个前缀。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span>;  &#125;,  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newVal</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = newVal;  &#125;,&#125;;<span class="hljs-keyword">const</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(person, <span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor);<span class="hljs-comment">// &#123;</span><span class="hljs-comment">//   get: [Function: get name],</span><span class="hljs-comment">//   set: [Function: set name],</span><span class="hljs-comment">//   enumerable: true,</span><span class="hljs-comment">//   configurable: true</span><span class="hljs-comment">// &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">set</span>.<span class="hljs-property">name</span>);<span class="hljs-comment">// set name</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">get</span>.<span class="hljs-property">name</span>);<span class="hljs-comment">// get name</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>).<span class="hljs-property">name</span>); <span class="hljs-comment">// bound foo</span></code></pre></div><h2 id="3-理解参数"><a href="#3-理解参数" class="headerlink" title="3 理解参数"></a>3 理解参数</h2><p>ESMAScript 函数不关心传入的参数个数和数据类型。即使定义函数的时候要接收两个参数，并不意味着必须传两个参数，可以传一个、三个或者不传参数。</p><p>之所以这样，是因为 ECMAScript 函数的参数在内部表现为一个<strong>类数组对象</strong>。函数被调用的时候总是接收一个类数组对象，而且函数不关心这个这个对象中包含什么。</p><h3 id="3-1-arguments-对象"><a href="#3-1-arguments-对象" class="headerlink" title="3.1 arguments 对象"></a>3.1 arguments 对象</h3><p>在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 <strong>arguments 对象</strong>。</p><h4 id="3-1-1-使用-arguments-对象获取函数参数"><a href="#3-1-1-使用-arguments-对象获取函数参数" class="headerlink" title="3.1.1 使用 arguments 对象获取函数参数"></a>3.1.1 使用 arguments 对象获取函数参数</h4><p>arguments 对象是一个<strong>类数组对象</strong>（但<strong>不是</strong> Array 的实例），因此可以使用中括号语法来访问其中的元素。第一个参数是 arguments[0]，第二个参数是 arguments[1]。</p><p>如果要确定传递进来多少个参数，可以访问 arguments.length 属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<span class="hljs-comment">// [Arguments] &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3 &#125;</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);<span class="hljs-comment">// 3</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 2</span>&#125;<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre></div><h4 id="3-1-2-arguments-对象和命名参数"><a href="#3-1-2-arguments-对象和命名参数" class="headerlink" title="3.1.2 arguments 对象和命名参数"></a>3.1.2 arguments 对象和<strong>命名参数</strong></h4><p>arguments 对象可以和<strong>命名参数</strong>一同使用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1</span>) &#123;<span class="hljs-comment">// num1 命名参数</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1 + <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);&#125;<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 3</span></code></pre></div><h4 id="3-1-3-修改-arguments-对象和命名参数"><a href="#3-1-3-修改-arguments-对象和命名参数" class="headerlink" title="3.1.3 修改 arguments 对象和命名参数"></a>3.1.3 修改 arguments 对象和命名参数</h4><p>修改 arguments 对象的值，命名参数<strong>会</strong>跟着变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, num2);<span class="hljs-comment">// 1 2</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 1 2</span>  <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>], num2);<span class="hljs-comment">// 9 9</span>&#125;<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</code></pre></div><p>修改命名参数，会不会影响到 arguments 对象呢？非严格模式下<strong>会</strong>，严格模式下<strong>不会</strong>。</p><blockquote><p><strong>注意</strong>：如果只传了一个参数，然后把 arguments[1] 设置为一个值，那么这个值不会反映到第二个命名参数上。因为 arguments 对象的长度是根据<strong>传入</strong>的参数个数，而非<strong>定义</strong>函数时给出的命名参数个数确定的。</p></blockquote><h3 id="3-2-箭头函数中的参数"><a href="#3-2-箭头函数中的参数" class="headerlink" title="3.2 箭头函数中的参数"></a>3.2 箭头函数中的参数</h3><p>如果函数是使用箭头函数定义的，那么传给函数的参数就不能使用 arguments 来访问，只能通过命名参数来访问。</p><h2 id="4-没有重载"><a href="#4-没有重载" class="headerlink" title="4 没有重载"></a>4 没有重载</h2><p>ECMAScript 中的函数没有函数签名，因此无法重载。</p><h2 id="5-默认参数值"><a href="#5-默认参数值" class="headerlink" title="5 默认参数值"></a>5 默认参数值</h2><h3 id="5-1-定义默认参数"><a href="#5-1-定义默认参数" class="headerlink" title="5.1 定义默认参数"></a>5.1 定义默认参数</h3><p>ECMAScript6 开始支持显式定义默认参数。只要在函数定义中参数后面使用<code>=</code>就可以为参数赋一个默认值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span></span>) &#123;<span class="hljs-comment">// 命名参数a的默认值是1</span>  <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">8</span>));</code></pre></div><h3 id="5-2-调用函数返回的值作为默认参数"><a href="#5-2-调用函数返回的值作为默认参数" class="headerlink" title="5.2 调用函数返回的值作为默认参数"></a>5.2 调用函数返回的值作为默认参数</h3><p>默认参数值并不限于原始值或者对象类型，可以使用任意表达式，当然也可以使用调用函数返回的值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNum</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a = <span class="hljs-number">1</span>, b = getNum()</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;</code></pre></div><p>注意：</p><ol><li><p>函数的默认参数只有在函数被<strong>调用</strong>时才会求值，不会在函数<strong>定义</strong>时求值。</p></li><li><p>计算默认值的函数只有在调用函数但<strong>未传相应参数</strong>时才会被调用。</p></li><li><p>箭头函数同样也可以使用默认参数，只不过在只有一个参数时，就必须使用括号而不能忽略。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">doubleNum</span> = (<span class="hljs-params">x = <span class="hljs-number">2</span></span>) =&gt; <span class="hljs-number">2</span> * x;</code></pre></div></li></ol><h3 id="5-3-默认参数作用域与暂时性死区"><a href="#5-3-默认参数作用域与暂时性死区" class="headerlink" title="5.3 默认参数作用域与暂时性死区"></a>5.3 默认参数作用域与暂时性死区</h3><p>给多个函数参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。</p><p>因为参数是按顺序初始化的，所以后定义的默认值参数可以引用先定义的参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1 = <span class="hljs-number">1</span>, num2 = num1</span>) &#123;  <span class="hljs-keyword">return</span> num1 + num2;&#125;</code></pre></div><p>参数初始化顺序遵循<strong>暂时性死区</strong>原则，前面定义的参数不能引用后面定义的。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1 = num2, num2 = <span class="hljs-number">2</span></span>) &#123;<span class="hljs-comment">// 报错</span>  <span class="hljs-keyword">return</span> num1 + num2;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>());</code></pre></div><p>默认参数也存在于自己的作用域中，它们不能引用函数体的作用域。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1 = <span class="hljs-number">1</span>, num2 = n</span>) &#123;<span class="hljs-comment">// 报错</span>  <span class="hljs-keyword">let</span> n = <span class="hljs-number">2</span>;  <span class="hljs-keyword">return</span> num1 + num2;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>());</code></pre></div><h2 id="6-参数扩展与收集"><a href="#6-参数扩展与收集" class="headerlink" title="6 参数扩展与收集"></a>6 参数扩展与收集</h2><p>ECMAScript6 中新增了<strong>扩展操作符</strong>，使用它可以非常简洁地操作和组合集合数据。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p><h3 id="6-1-扩展参数"><a href="#6-1-扩展参数" class="headerlink" title="6.1 扩展参数"></a>6.1 扩展参数</h3><p>对可迭代对象应用扩展操作符，并将其作为一个参数传入，就可以将可迭代对象<strong>拆分</strong>，并将迭代返回的每个值单独传入。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;    result += <span class="hljs-variable language_">arguments</span>[i];  &#125;  <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(...arr));<span class="hljs-comment">// 使用扩展操作符来扩展参数</span></code></pre></div><h3 id="6-2-收集参数"><a href="#6-2-收集参数" class="headerlink" title="6.2 收集参数"></a>6.2 收集参数</h3><p>可以使用扩展操作符把不同长度的独立数组组合为一个数组。这个有点类似 arguments 对象的构造机制，只不过收集参数的结果会得到一个 Array 实例。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...values</span>) &#123;<span class="hljs-comment">// 使用扩展操作符来收集参数</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);&#125;<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<span class="hljs-comment">// [ 1, 2, 3, 4 ]</span></code></pre></div><p>收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有收集到则会得到空数组。因为收集参数的结果可变，所以只能将其作为最后一个参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1,...values</span>) &#123;&#125;</code></pre></div><p>箭头函数虽然不支持 arguments 对象，但是支持收集参数的定义方式，因此可以实现与使用 arguments 一样的逻辑。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">...values</span>) =&gt; &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);&#125;;</code></pre></div><blockquote><p><strong>注意</strong>：使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数。</p></blockquote><h2 id="7-函数声明和函数表达式"><a href="#7-函数声明和函数表达式" class="headerlink" title="7 函数声明和函数表达式"></a>7 函数声明和函数表达式</h2><p>函数声明和函数表达式存在一个细微区别。JavaScript 引擎在执行代码之前，会先读取函数声明，并在执行上下文中生成函数定义，这个过程叫做<strong>函数声明提升</strong>。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数声明提升</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>());<span class="hljs-comment">// 可以执行</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用函数表达式来定义函数，只有执行到定义函数的时候才会在执行上下文中生成函数定义</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>());<span class="hljs-comment">// 报错</span><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;</code></pre></div><h2 id="8-函数作为值"><a href="#8-函数作为值" class="headerlink" title="8 函数作为值"></a>8 函数作为值</h2><p>因为函数名在 ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传递给另一个参数，而且可以在一个函数中返回另一个函数。</p><p>函数作为<strong>参数</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">bar, baz</span>) &#123;  <span class="hljs-title function_">bar</span>(baz);&#125;</code></pre></div><p>函数作为<strong>返回值</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;&#125;</code></pre></div><h2 id="9-函数内部"><a href="#9-函数内部" class="headerlink" title="9 函数内部"></a>9 函数内部</h2><p>函数内部存在几个特殊对象：arguments、this、caller，ES6 新增了 new.target 属性。</p><h3 id="9-1-arguments"><a href="#9-1-arguments" class="headerlink" title="9.1 arguments"></a>9.1 arguments</h3><p>arguments 是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以 function 关键字定义函数时才会有，箭头语法定义函数时没有。</p><h4 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h4><p>arguments 还有一个 callee 属性，是一个指向 arguments 对象<strong>所在函数</strong>的指针。</p><p>下面是一个递归的阶乘函数：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) &#123;  <span class="hljs-keyword">return</span> num &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : num * <span class="hljs-title function_">factorial</span>(num - <span class="hljs-number">1</span>);&#125;</code></pre></div><p>这个函数要想正确执行，必须保证函数名是 factorial，这就导致了紧密耦合。可以使用 arguments.callee 来让函数逻辑和函数名解耦。重写之后，无论函数名是什么都可以运行。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) &#123;  <span class="hljs-keyword">return</span> num &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : num * <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(num - <span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="9-2-this"><a href="#9-2-this" class="headerlink" title="9.2 this"></a>9.2 this</h3><p>this 对象在标准函数和箭头函数中有不同的行为。</p><h4 id="9-2-1-标准函数中的-this"><a href="#9-2-1-标准函数中的-this" class="headerlink" title="9.2.1 标准函数中的 this"></a>9.2.1 标准函数中的 this</h4><p>在<strong>标准函数</strong>中，this 引用的是<strong>调用该函数的上下文对象</strong>。也就是说，谁调用了函数，this 就指向谁。在全局上下文中调用函数时，this 指向 global 对象（在浏览器中表现为 window 对象）。</p><div class="code-wrapper"><pre><code class="hljs javascript">color = <span class="hljs-string">&quot;red&quot;</span>;<span class="hljs-comment">// 省略 var 操作符，可以将 color 定义为全局变量</span><span class="hljs-keyword">let</span> obj = &#123;  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;green&quot;</span>,&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayColor</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>);&#125;<span class="hljs-title function_">sayColor</span>();<span class="hljs-comment">// red此时，this 指向 global 对象</span>obj.<span class="hljs-property">sayColor</span> = sayColor;obj.<span class="hljs-title function_">sayColor</span>();<span class="hljs-comment">// green此时，this 指向 obj </span></code></pre></div><h4 id="9-2-2-箭头函数中的-this"><a href="#9-2-2-箭头函数中的-this" class="headerlink" title="9.2.2 箭头函数中的 this"></a>9.2.2 箭头函数中的 this</h4><p>在<strong>箭头函数</strong>中，this 引用的是<strong>定义该函数的上下文</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript">color = <span class="hljs-string">&quot;red&quot;</span>;<span class="hljs-keyword">let</span> obj = &#123;  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;green&quot;</span>,&#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">sayColor</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>);<span class="hljs-title function_">sayColor</span>();<span class="hljs-comment">// red</span>obj.<span class="hljs-property">sayColor</span> = sayColor;obj.<span class="hljs-title function_">sayColor</span>();<span class="hljs-comment">// red</span></code></pre></div><p>在事件回调或者定时回调中调用某个函数中，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中 this 会保留定义该函数时的上下文。</p><h3 id="9-3-caller"><a href="#9-3-caller" class="headerlink" title="9.3 caller"></a>9.3 caller</h3><p>函数对象上也有一个 caller 属性，这个属性引用的是调用当前函数的<strong>函数</strong>。如果实在全局作用域中调用的则是 null。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-title function_">inner</span>();&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(inner.<span class="hljs-property">caller</span>);&#125;<span class="hljs-title function_">outer</span>();<span class="hljs-comment">// [Function: outer]</span></code></pre></div><h3 id="9-4-new-target"><a href="#9-4-new-target" class="headerlink" title="9.4 new.target"></a>9.4 new.target</h3><p>ECMAScript 中的函数始终可以作为构造函数实例化一个对象，也可以作为普通函数被调用。ES6 新增了检测函数是否可以使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的<strong>构造函数</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;不是使用 new 调用的&quot;</span>);    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>,<span class="hljs-string">&quot;使用 new 调用的&quot;</span>);&#125;<span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>();<span class="hljs-comment">// [Function: fn] 使用 new 调用的</span><span class="hljs-title function_">fn</span>();<span class="hljs-comment">// 不是使用 new 调用的</span></code></pre></div><h2 id="10-函数属性和方法"><a href="#10-函数属性和方法" class="headerlink" title="10 函数属性和方法"></a>10 函数属性和方法</h2><p>ECMAScript 中，函数是对象，因此有属性和方法。</p><h3 id="10-1-length-属性"><a href="#10-1-length-属性" class="headerlink" title="10.1 length 属性"></a>10.1 length 属性</h3><p>length 属性中保存的是<strong>函数定义</strong>时<strong>命名参数</strong>的个数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">bar, baz</span>) &#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">length</span>);<span class="hljs-comment">// 2</span></code></pre></div><h3 id="10-2-prototype-属性"><a href="#10-2-prototype-属性" class="headerlink" title="10.2 prototype 属性"></a>10.2 prototype 属性</h3><p>prototype 属性保存着函数的原型。</p><h3 id="10-3-apply-和-call"><a href="#10-3-apply-和-call" class="headerlink" title="10.3 apply() 和 call()"></a>10.3 apply() 和 call()</h3><p>函数身上有两个方法，apply() 和 call()。这两个方法都会以<strong>指定的 this 值</strong>来调用函数，即会设置调用函数时函数体内的 this 值。</p><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>apply() 函数接收两个参数：函数内的 <strong>this</strong> 值和一个<strong>参数数组</strong>。第二个参数可以是 Array 类型的实例，也可以是 <strong>arguments 对象</strong>。</p><p>第二个参数传入<strong>参数数组</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1 + num2);&#125;sum.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<span class="hljs-comment">// 3</span></code></pre></div><p>第二个参数传入 <strong>arguments 对象</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1 + num2);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">callSum</span>(<span class="hljs-params">num1, num2</span>) &#123;  sum.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<span class="hljs-comment">// 3</span>&#125;<span class="hljs-title function_">callSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</code></pre></div><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>call() 方法和 apply() 方法作用一样，只是传参的形式不同。第一个参数和 apply() 一样，也是 this 值。剩下的参数是要给被调用函数传递的<strong>参数</strong>。也就是说，通过 call() 向函数传参时，必须将参数<strong>一个一个</strong>列举出来。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1 + num2);&#125;sum.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 3</span></code></pre></div><p>apply() 和 call() 可以控制函数调用上下文，即函数体内 this 指向。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>);&#125;bar = <span class="hljs-string">&quot;global&quot;</span>;<span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;obj&quot;</span>,&#125;;foo.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">// global</span>foo.<span class="hljs-title function_">call</span>(obj);<span class="hljs-comment">// obj</span></code></pre></div><h3 id="10-4-bind"><a href="#10-4-bind" class="headerlink" title="10.4 bind()"></a>10.4 bind()</h3><p>bind() 方法创建一个<strong>新的函数</strong>，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;obj&quot;</span>,&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>);&#125;<span class="hljs-keyword">const</span> newObj = foo.<span class="hljs-title function_">bind</span>(obj);<span class="hljs-title function_">newObj</span>();<span class="hljs-comment">// obj</span></code></pre></div><h2 id="11-函数声明和函数表达式"><a href="#11-函数声明和函数表达式" class="headerlink" title="11 函数声明和函数表达式"></a>11 函数声明和函数表达式</h2><p>定义函数主要有两种形式：函数声明和函数表达式。</p><h3 id="11-1-函数声明"><a href="#11-1-函数声明" class="headerlink" title="11.1 函数声明"></a>11.1 函数声明</h3><p>函数声明：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;</code></pre></div><p>函数声明的的关键特点是<strong>函数声明提升</strong>，即函数声明会在代码执行之前获得定义。这意味着函数声明可以出现在调用它的代码之后。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>()<span class="hljs-comment">// 正确执行</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;</code></pre></div><h3 id="11-2-函数表达式"><a href="#11-2-函数表达式" class="headerlink" title="11.2 函数表达式"></a>11.2 函数表达式</h3><p>函数表达式的一种形式：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;</code></pre></div><p>函数表达式看起来像一个普通的变量定义和赋值，即创建一个<strong>函数</strong>再把它赋值给一个变量。这样创建的函数叫<strong>匿名函数</strong>（anonymous function），因为 function 关键字后面没有标识符。未赋值给其它变量的匿名函数的 name 属性是空串。</p><p>函数表达式和其它表达式一样，需要先赋值再使用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>()<span class="hljs-comment">// 报错</span><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;</code></pre></div><h2 id="12-递归"><a href="#12-递归" class="headerlink" title="12 递归"></a>12 递归</h2><p>递归函数的通常形式是一个函数通过名称调用自己。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 求阶乘</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) &#123;  <span class="hljs-keyword">return</span> num &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : num * <span class="hljs-title function_">factorial</span>(num - <span class="hljs-number">1</span>);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">4</span>));<span class="hljs-comment">// 24</span></code></pre></div><p>使用 arguments.callee 来代替函数内部的函数名。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) &#123;  <span class="hljs-keyword">return</span> num &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : num * <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(num - <span class="hljs-number">1</span>);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">4</span>));<span class="hljs-comment">// 24</span></code></pre></div><h2 id="13-尾调用优化"><a href="#13-尾调用优化" class="headerlink" title="13 尾调用优化"></a>13 尾调用优化</h2><p>函数调用会在内存形成一个”调用记录”，又称**”调用帧”**（call frame），保存调用位置和内部变量等信息。ES6 规范新增了一项内存管理优化机制，可以让 JavaScript 引擎在满足条件时可以重用调用帧。</p><h3 id="13-1-尾调用"><a href="#13-1-尾调用" class="headerlink" title="13.1 尾调用"></a>13.1 尾调用</h3><p>尾调用，即外部函数的返回值是一个内部函数的返回值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">bar</span>();&#125;</code></pre></div><h3 id="13-2-尾调用优化"><a href="#13-2-尾调用优化" class="headerlink" title="13.2 尾调用优化"></a>13.2 尾调用优化</h3><p>在优化之前，执行上述的例子会在内存中发生如下操作：</p><ol><li><p>执行到 foo() 函数，第一个调用帧被推到栈上。</p></li><li><p>执行 foo() 函数体，到 return 语句。计算返回值必须计算 bar()。</p></li><li><p>执行到 bar() 函数，将第二个调用帧推到栈上。</p></li><li><p>执行 bar() 函数体，计算返回值。</p></li><li><p>将返回值传给 foo()，然后 foo() 再返回值。</p></li></ol><p>在 ES6 优化后，这个例子会在内存中执行下面的操作：</p><ol><li>执行到 foo() 函数体，第一个调用帧被推到栈上。</li><li>执行 foo() 函数体，到 return 语句。计算返回值必须计算 bar()。</li><li>引擎发现把第一个调用帧弹出栈外也没有问题。</li><li>弹出 foo() 调用帧。</li><li>执行到 bar() 函数，将调用帧推到栈上。</li><li>执行 bar() 函数体，计算返回值。</li><li>将 bar() 调用帧弹出。</li></ol><p>优化前，每多调用一次嵌套函数，就会多增加一个调用帧。优化后，无论调用多少次嵌套函数，都只有<strong>一个</strong>栈帧。尾调用优化的<strong>关键</strong>：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</p><h3 id="13-3-尾调用优化的条件"><a href="#13-3-尾调用优化的条件" class="headerlink" title="13.3 尾调用优化的条件"></a>13.3 尾调用优化的条件</h3><p>尾调用优化的条件就是确定外部调用帧真的没有必要存在了。涉及的条件如下：</p><ul><li>代码在<strong>严格模式</strong>下执行</li><li>外部函数的返回值是对尾调用函数的调用</li><li>尾调用函数返回后不需要执行额外的逻辑</li><li>尾调用函数不是引用外部函数作用域中自有变量的闭包</li></ul><p>之所以要求<strong>严格模式</strong>，主要是因为在非严格模式下函数调用中允许使用 f.arguments 和 f.caller，而它们都会引用外部函数的调用帧。这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防引用这些属性。</p><h2 id="14-闭包"><a href="#14-闭包" class="headerlink" title="14 闭包"></a>14 闭包</h2><p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">MDN</a>。</p><h2 id="15-立即调用的函数表达式"><a href="#15-立即调用的函数表达式" class="headerlink" title="15 立即调用的函数表达式"></a>15 立即调用的函数表达式</h2><p>立即调用的匿名函数，又称立即调用的函数表达式（IIFE）。类似于函数声明，但是由于被包含在括号里，所以会被解释为函数表达式。紧跟在扩号后面的第二组括号会立即调用前面的函数表达式。</p><div class="code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 块作用域</span>&#125;)();</code></pre></div><p>使用 IIFE 可以模拟<strong>块级作用域</strong>。即在一个函数表达式内部声明变量，然后立即调用这个函数，这样位于函数体作用域的变量就像是在块级作用域中一样。</p><p>ES5 尚未支持块级作用域，使用 IIFE 模拟块级作用域非常普遍。在 ES6 之后，IIFE 就没那么必要了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】16.对象-类和继承</title>
    <link href="/archives/2b46e60a.html"/>
    <url>/archives/2b46e60a.html</url>
    
    <content type="html"><![CDATA[<h1 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h1><p>ECMAScript 6中引入的 <code>class</code> 关键字具有正式定义类的能力。表面上看起来可以支持正式的面向对象编程，但实际上背后仍是原型和构造函数的概念。</p><h2 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1 定义类"></a>1 定义类</h2><h3 id="1-1-定义类的两种方式"><a href="#1-1-定义类的两种方式" class="headerlink" title="1.1 定义类的两种方式"></a>1.1 定义类的两种方式</h3><p>定义类主要有两种方式：类声明和类表达式。</p><p>类声明：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;</code></pre></div><p>类表达式：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> &#123;&#125;;</code></pre></div><h3 id="1-2-声明提升"><a href="#1-2-声明提升" class="headerlink" title="1.2 声明提升"></a>1.2 声明提升</h3><p>var 定义的类表达式有声明提升。let 和 const 定义的类表达式没有声明提升，类声明也没有声明提升。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassExpression</span>);<span class="hljs-comment">// undefined （声明提升）</span><span class="hljs-keyword">var</span> <span class="hljs-title class_">ClassExpression</span> = <span class="hljs-keyword">class</span> &#123;&#125;;<span class="hljs-comment">// var 定义的类表达式</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassExpression</span>);<span class="hljs-comment">// [class ClassExpression]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassExpression</span>);<span class="hljs-comment">// 报错（没有声明提升）</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">ClassExpression</span> = <span class="hljs-keyword">class</span> &#123;&#125;;<span class="hljs-comment">// let 或者 const 定义的类表达式</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassExpression</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>);<span class="hljs-comment">// 报错 （没有声明提升）</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDeclaration</span> &#123;&#125;<span class="hljs-comment">// 类声明</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>);</code></pre></div><h3 id="1-3-作用域限制"><a href="#1-3-作用域限制" class="headerlink" title="1.3 作用域限制"></a>1.3 作用域限制</h3><p>函数受函数作用域限制，而类受<strong>块作用域</strong>限制。</p><div class="code-wrapper"><pre><code class="hljs javascript">&#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">functionDeclaration</span>(<span class="hljs-params"></span>) &#123;&#125;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDeclaration</span> &#123;&#125;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(functionDeclaration);   <span class="hljs-comment">// [Function: functionDeclaration]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>);      <span class="hljs-comment">// 报错</span></code></pre></div><h3 id="1-4-类的构成"><a href="#1-4-类的构成" class="headerlink" title="1.4 类的构成"></a>1.4 类的构成</h3><p>类可以包含<strong>构造函数方法</strong>、<strong>实例方法</strong>、<strong>获取函数</strong>、<strong>设置函数</strong>和<strong>静态函数</strong>，但是这都不是必须的。空的类定义依然有效。类定义中的代码都在<strong>严格模式</strong>下执行。<em>建议</em>类名的首字母大写。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-comment">// 构造函数</span>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() &#123;&#125;<span class="hljs-comment">// 获取函数</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-comment">// 静态函数</span>&#125;</code></pre></div><h3 id="1-5-可选的类表达式名称"><a href="#1-5-可选的类表达式名称" class="headerlink" title="1.5 可选的类表达式名称"></a>1.5 可选的类表达式名称</h3><p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 name 属性取得类表达式名称。但是不能在类表达式作用域之外的地方直接访问到类表达式名称。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<span class="hljs-comment">// Foo 是类表达式的名称，Person 是类表达式赋值给的变量</span>  <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property">name</span>);<span class="hljs-comment">// 类作用域中可以访问到 Foo 这个类名称</span>  &#125;&#125;;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();p.<span class="hljs-title function_">bar</span>()<span class="hljs-comment">// Foo Foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>);<span class="hljs-comment">// Foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>);<span class="hljs-comment">// 报错</span></code></pre></div><h2 id="2-类构造函数"><a href="#2-类构造函数" class="headerlink" title="2 类构造函数"></a>2 类构造函数</h2><p>方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个构造函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数。</p><h3 id="2-1-实例化"><a href="#2-1-实例化" class="headerlink" title="2.1 实例化"></a>2.1 实例化</h3><p>使用 new 操作符实例化 Person 的操作等于使用 new 调用其构造函数。JavaScript 解释器知道使用 new 和类意味着应该使用 constructor 函数进行实例化。</p><p>使用 new 调用类的构造函数会执行下面的操作：</p><ol><li>在内存中创建一个新的对象。</li><li>这个新对象的内部的<code>[[Prototype]]</code>指针被赋值为构造函数的<code>prototype</code>属性。</li><li>构造函数内部的 this 被赋值为这个新的对象。即 this 指向新对象。</li><li>执行构造函数内部的代码。即给新对象添加属性等操作。</li><li>如果构造函数没有返回值，则返回该对象。</li></ol><p>类实例化时传入的参数会作为构造函数的参数。如果不需要参数，则类名后面的括号可以<em>省略</em>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  &#125;&#125;;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<span class="hljs-comment">// Person &#123; name: &#x27;foo&#x27; &#125;</span><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<span class="hljs-comment">// Person &#123; name: undefined &#125;</span></code></pre></div><p><strong>默认情况下，类构造函数会在执行后返回 this 对象</strong>。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。</p><p>如果返回的不是 this 对象，而是其它对象，那么这个对象不会通过 instanceof 操作符检测出来有关联，因为这个对象的<strong>原型指针</strong>并没有被修改。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-keyword">return</span> &#123;&#125;    &#125;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);   <span class="hljs-comment">// false</span></code></pre></div><p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符。普通构造函数如果不使用 new 调用，那么就会以<strong>全局</strong>的 this 作为内部对象。调用类构造函数时，如果忘了使用 new 则会抛出错误。</p><h3 id="2-2-把类当成特殊函数"><a href="#2-2-把类当成特殊函数" class="headerlink" title="2.2 把类当成特殊函数"></a>2.2 把类当成特殊函数</h3><p>ECMAScript 中的类就是一种特殊的<em>函数</em>。通过 typeof 操作符检查类标识符，表明它是一个函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// function</span></code></pre></div><p><strong>类标签</strong>有 prototype 属性，而它的原型也有一个 constructor 属性指向自身。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">// &#123;&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// true</span></code></pre></div><p>与普通的构造函数一样，可以使用 instanceof 操作符检查构造函数原型是否存在于实例的原型链中。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// true</span></code></pre></div><p>在类的上下文中，<strong>类本身</strong>在使用 new 调用时就会被当做构造函数。重点在于，类定义的 constructor 方法<strong>不会</strong>被当成构造函数，在对它使用 instanceof 返回 false。但是，如果在创建实例时直接将<strong>类构造函数</strong>当成普通构造函数来使用，那么 instanceof 操作符的返回值会反转。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Foo&quot;</span>;  &#125;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>);<span class="hljs-comment">// false</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>);<span class="hljs-comment">// true</span></code></pre></div><p>注意：</p><ol><li>可以将类作为<strong>参数</strong>来传递</li><li>类可以立即实例化</li></ol><h2 id="3-实例、原型和类成员"><a href="#3-实例、原型和类成员" class="headerlink" title="3 实例、原型和类成员"></a>3 实例、原型和类成员</h2><p>类的语法可以非常方便地定义应该存在于<strong>实例</strong>上的成员，应该存在于<strong>原型</strong>上的成员，以及应该存在于<strong>类本身</strong>的成员。</p><h3 id="3-1-实例成员"><a href="#3-1-实例成员" class="headerlink" title="3.1 实例成员"></a>3.1 实例成员</h3><p>在<strong>类构造函数</strong>内部，可以为新创建的实例（this）添加自有属性。在类构造函数执行完毕后仍然可以给实例继续添加新成员。每个实例都对应一个<strong>唯一</strong>的成员对象，这意味着所有成员都<strong>不会</strong>在原型上共享。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">names</span> = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>];  &#125;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">names</span> === p2.<span class="hljs-property">names</span>);<span class="hljs-comment">// false</span>p1.<span class="hljs-property">names</span>.<span class="hljs-title function_">pop</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<span class="hljs-comment">// Person &#123; names: [ &#x27;foo&#x27; ] &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<span class="hljs-comment">// Person &#123; names: [ &#x27;foo&#x27;, &#x27;bar&#x27; ] &#125;</span></code></pre></div><h3 id="3-2-原型方法与访问器"><a href="#3-2-原型方法与访问器" class="headerlink" title="3.2 原型方法与访问器"></a>3.2 原型方法与访问器</h3><p>为了在实例间共享方法，类定义语法把在<strong>类块</strong>中定义的方法作为<strong>原型方法</strong>。在<strong>类块</strong>中定义的所有内容都最终会定义在类的<strong>原型</strong>上。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;instance&quot;</span>);    &#125;;  &#125;  <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;prototype&quot;</span>);  &#125;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();p.<span class="hljs-title function_">sayName</span>();<span class="hljs-comment">// instance</span>p.<span class="hljs-property">__proto__</span>.<span class="hljs-title function_">sayName</span>();<span class="hljs-comment">// prototype</span></code></pre></div><p>可以把<strong>方法</strong>定义在类的构造函数或者类块中，但是不能在类块中给原型添加<strong>原始值</strong>或者<strong>对象</strong>作为成员数据。</p><p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">stringKey</span>(<span class="hljs-params"></span>) &#123;&#125;  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foo&quot;</span>)]() &#123;&#125;  [<span class="hljs-string">&quot;computed&quot;</span> + <span class="hljs-string">&quot;key&quot;</span>]() &#123;&#125;&#125;</code></pre></div><p>类定义也支持获取和设置访问器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newName</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = newName;  &#125;  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span>;  &#125;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();p.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);<span class="hljs-comment">// foo</span></code></pre></div><h3 id="3-3-静态类方法"><a href="#3-3-静态类方法" class="headerlink" title="3.3 静态类方法"></a>3.3 静态类方法</h3><p>可以在类上定义<strong>静态方法</strong>。这些方法通常用于执行<strong>不特定于实例</strong>的操作。静态类成员在类块中使用 static 关键字定义，this 引用类自身。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 添加到 this 的所有的内容都会存在于不同的实例上</span>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;instance&quot;</span>);    &#125;;  &#125;  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 定义到类的原型上</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;prototype&quot;</span>);  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 定义到类本身上</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;class&quot;</span>);  &#125;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();p.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// instance</span>p.<span class="hljs-property">__proto__</span>.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// prototype</span><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// class</span></code></pre></div><h3 id="3-4-非函数原型和类成员"><a href="#3-4-非函数原型和类成员" class="headerlink" title="3.4 非函数原型和类成员"></a>3.4 非函数原型和类成员</h3><p>虽然类定义不支持在原型或类上添加<strong>数据成员</strong>，但是在类定义<strong>外部</strong>，可以手动添加。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Foo&quot;</span>;<span class="hljs-comment">// 在类的原型上定义属性</span><span class="hljs-title class_">Person</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-comment">// 在类上定义属性</span></code></pre></div><blockquote><p>在<strong>共享目标</strong>（原型和类）上添加可修改的数据成员是一种<strong>反模式</strong>。一般来说，对象实例应该独自拥有通过 this 引用的数据。</p></blockquote><h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4 继承"></a>4 继承</h2><p>ES6 原生支持了类继承机制。虽然类继承使用的是新语法，但背后依然使用的是原型链。</p><h3 id="4-1-继承基础"><a href="#4-1-继承基础" class="headerlink" title="4.1 继承基础"></a>4.1 继承基础</h3><p>ES6 中类支持单继承。使用 extends 关键字，就可以继承所有拥有<code>[[Construct]]</code>和原型的对象。这意味着不仅可以继承一个<strong>类</strong>，也可以继承普通的<strong>构造函数</strong>。</p><p>继承类：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span>&#123;&#125;<span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Teacher</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// true</span></code></pre></div><p>继承普通的构造函数：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;&#125;<span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Teacher</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// true</span></code></pre></div><p><strong>原型</strong>和<strong>类</strong>上定义的方法都会带到派生类。this 的值会反映调用相应方法的<strong>实例</strong>或者<strong>类</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-variable language_">this</span>);  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-variable language_">this</span>);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;&#125;<span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();t.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// foo Teacher &#123;&#125;</span>p.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// foo Person &#123;&#125;</span><span class="hljs-title class_">Teacher</span>.<span class="hljs-title function_">bar</span>();<span class="hljs-comment">// bar [class Teacher extends Person]</span><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">bar</span>();<span class="hljs-comment">// bar [class Person]</span></code></pre></div><h3 id="4-2-super"><a href="#4-2-super" class="headerlink" title="4.2 super()"></a>4.2 super()</h3><p>派生类的方法可以通过 super 关键字引用它们的<strong>原型</strong>。这个关键字只能在<strong>派生类</strong>中使用，而且仅限于类构造函数、实例方法和静态方法内部。</p><p>在<strong>类构造函数</strong>中使用 super() 可以调用<strong>父类构造函数</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>();    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">// Teacher &#123; name: &#x27;foo&#x27; &#125;</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// true</span>  &#125;&#125;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>()</code></pre></div><p>在<strong>实例方法</strong>中使用 super 调用<strong>父类实例方法</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;  &#125;  <span class="hljs-title function_">sayHelloPerson</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello person&quot;</span>);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;  <span class="hljs-title function_">sayHelloTeacher</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">sayHelloPerson</span>();  &#125;&#125;<span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();t.<span class="hljs-title function_">sayHelloTeacher</span>()<span class="hljs-comment">// hello person</span></code></pre></div><p>在<strong>静态方法</strong>中可以通过 super 调用<strong>父类静态方法</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Person&quot;</span>);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">foo</span>();  &#125;&#125;<span class="hljs-title class_">Teacher</span>.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// Person</span></code></pre></div><blockquote><p>ES6 给类构造函数和静态方法添加了内部特性<code>[[HomeObject]]</code>，这个特性是一个指针，指向<strong>定义该方法的对象</strong>。这个指针是自动赋值的，而且只能在 JavaScript 引擎内部方法访问。super 始终定义为 <code>HomeObject</code> 的<strong>原型</strong>。</p></blockquote><h4 id="使用-super-时注意几个问题"><a href="#使用-super-时注意几个问题" class="headerlink" title="使用 super 时注意几个问题"></a>使用 super 时注意几个问题</h4><ol><li><p>super 只能在<strong>派生类</strong>构造函数、实例方法和静态方法中使用。</p></li><li><p>不能单独使用 super 关键字，要么用它调用构造函数，要么用它引用实例方法或静态方法。</p></li><li><p>调用 super() 会调用父类构造函数，并将返回的实例赋值给 this。</p></li><li><p>super() 的行为如同构造函数，如果需要可以给父类构造函数传参。</p></li><li><p>如果没有定义派生类的构造函数，在实例化派生类时会调用 super() ，并传入所有传给派生类的参数。</p></li><li><p>在派生类的构造函数中，不能在调用 super() 之前引用 this。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-comment">// 报错 不能在调用 super() 之前引用 this。</span>    <span class="hljs-variable language_">super</span>();  &#125;&#125;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();</code></pre></div></li><li><p>如果在派生类中显式定义了构造函数，要么在其中调用 super()，要么在其中返回一个对象（可能破坏继承关系）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;&#125;;  &#125;&#125;<span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// false</span></code></pre></div></li></ol><h3 id="4-3-抽象基类"><a href="#4-3-抽象基类" class="headerlink" title="4.3 抽象基类"></a>4.3 抽象基类</h3><p>抽象基类是这样一个类，它可供其他类继承，但是本身不会被实例化。虽然 ECMAScript 没有专门支持抽象基类，但是可以通过 new.target 实现。new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-title class_">Person</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;无法实例化 Person &quot;</span>);    &#125;  &#125;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">// 报错 无法实例化 Person</span></code></pre></div><h3 id="4-4-继承内置类型"><a href="#4-4-继承内置类型" class="headerlink" title="4.4 继承内置类型"></a>4.4 继承内置类型</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  &#125;&#125;<span class="hljs-keyword">const</span> sa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sa);<span class="hljs-comment">// SuperArray(4) [ 1, 2, 3, 4 ]</span>sa.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// SuperArray(4) [ 1, 2, 3, 4 ]</span></code></pre></div><h3 id="4-5-类混入-Mixin"><a href="#4-5-类混入-Mixin" class="headerlink" title="4.5 类混入(Mixin)"></a>4.5 类混入(Mixin)</h3><p>经常需要把不同类的行为集中到一个类。ES6没有显式支持多继承，但是可以通过现有的特性来模拟这种行为。</p><blockquote><p>如果只需要混入多个<strong>对象</strong>的属性，那么使用 Object.assign() 即可。</p></blockquote><p>下面例子中，extends 后面是一个 JavaScript 表达式。任何可以解析为一个类或者一个构造函数的<strong>表达式</strong>都是有效的。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSuperClass</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 可求值的类定义表达式</span>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">getSuperClass</span> &#123;&#125;</code></pre></div><p><strong>混入模式</strong>可通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。如果 Person 类需要组合 A、B、C，则需要实现 B 继承 A，C 继承 B，最后 Person 继承 C。</p><p>实现混入模式的一种策略是，定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，并返回一个子类。连缀调用这些函数，便组合成了超类的表达式。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-keyword">let</span> <span class="hljs-title function_">FooMixin</span> = (<span class="hljs-params">SuperClass</span>) =&gt;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);    &#125;  &#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">BarMixin</span> = (<span class="hljs-params">SuperClass</span>) =&gt;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;    <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar&quot;</span>);    &#125;  &#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">BazMixin</span> = (<span class="hljs-params">SuperClass</span>) =&gt;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;    <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ba&quot;</span>);    &#125;  &#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FooMixin</span>(<span class="hljs-title class_">BarMixin</span>(<span class="hljs-title class_">BazMixin</span>(<span class="hljs-title class_">Person</span>))) &#123;&#125;<span class="hljs-comment">// 嵌套调用</span><span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();t.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// foo</span>t.<span class="hljs-title function_">bar</span>();<span class="hljs-comment">// bar</span>t.<span class="hljs-title function_">baz</span>();<span class="hljs-comment">// baz</span></code></pre></div><p>通过写一个辅助函数将嵌套调用展开。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-keyword">let</span> <span class="hljs-title function_">FooMixin</span> = (<span class="hljs-params">SuperClass</span>) =&gt;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);    &#125;  &#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">BarMixin</span> = (<span class="hljs-params">SuperClass</span>) =&gt;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;    <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar&quot;</span>);    &#125;  &#125;;<span class="hljs-keyword">let</span> <span class="hljs-title function_">BazMixin</span> = (<span class="hljs-params">SuperClass</span>) =&gt;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;    <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;baz&quot;</span>);    &#125;  &#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">mix</span>(<span class="hljs-params">BaseClass, ...Mixins</span>) &#123;<span class="hljs-comment">// 辅助函数 解决嵌套调用</span>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Mixins</span>.<span class="hljs-title function_">reduce</span>(    <span class="hljs-function">(<span class="hljs-params">accumulator, current</span>) =&gt;</span> <span class="hljs-title function_">current</span>(accumulator),    <span class="hljs-title class_">BaseClass</span>  );&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">mix</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-title class_">FooMixin</span>, <span class="hljs-title class_">BarMixin</span>, <span class="hljs-title class_">BazMixin</span>) &#123;&#125;<span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();t.<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// foo</span>t.<span class="hljs-title function_">bar</span>();<span class="hljs-comment">// bar</span>t.<span class="hljs-title function_">baz</span>();<span class="hljs-comment">// baz</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】15.对象-原型链</title>
    <link href="/archives/c92c42c1.html"/>
    <url>/archives/c92c42c1.html</url>
    
    <content type="html"><![CDATA[<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>原型链</strong>是 ECMAScript 主要的<strong>继承</strong>方式。其主要思想就是通过<strong>原型</strong>继承多个引用类型的属性和方法。构造函数、原型和实例的关系：<strong>每个构造函数都有一个原型对象，该原型对象有一个属性指回构造函数，而实例有一个内部指针指向原型</strong>。如果<em>原型是另一个类型的实例</em>，实例和原型之间就构造了一条原型链。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<span class="hljs-comment">// 继承</span><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&quot;bar&quot;</span>;<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">foo</span>);<span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">bar</span>);<span class="hljs-comment">// bar</span></code></pre></div><p>上述例子中，SubType 通过创建 SuperType 的实例并将其赋值给自己的原型 SubType.pototype，实现了对 SuperType 的继承。这意味着 SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype 中。</p><p>调用 instance.foo 经历了三步，首先搜索 instance，然后搜索 SubType.prototype，再然后搜索 SuperType.prototype。此时已经找到，故返回。</p><p>重写 SubType.prototype 后，SubType.prototype 已经没有了 constructor 属性。访问 SubType.prototype.constructor 时会进入 SubType.prototype 的原型中查找 SubType.prototype 的原型身上的 constructor 属性。此时， SubType.prototype 的原型，也就是 SuperType.prototype 身上的 constructor 属性指向的是 SuperType 构造函数。所以 instance.constructor 指向 SuperType 而不是 SubType。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">__proto__</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;constructor&#x27;</span>));<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">SuperType</span>);<span class="hljs-comment">// true</span></code></pre></div><h3 id="1-默认原型"><a href="#1-默认原型" class="headerlink" title="1 默认原型"></a>1 默认原型</h3><p>默认情况下，所有引用类型都继承自 Object。任何函数的原型都是一个 Object 实例，这意味着这个实例的原型指向 Object.prototype。Object.prototype 身上定义了 toString()、valueOf() 等方法。这也是自定义类型能继承toString()、valueOf() 等方法的原因。</p><h3 id="2-原型和实例的关系"><a href="#2-原型和实例的关系" class="headerlink" title="2 原型和实例的关系"></a>2 原型和实例的关系</h3><p>原型和实例的关系可以通过两种方式来确定。</p><h4 id="2-1-使用-instanceof-操作符"><a href="#2-1-使用-instanceof-操作符" class="headerlink" title="2.1 使用 instanceof 操作符"></a>2.1 使用 instanceof 操作符</h4><p>如果一个实例的原型链中出现过相应构造函数的原型，那么 instanceof 操作符返回 true。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">// true</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SubType</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperType</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);<span class="hljs-comment">// true</span></code></pre></div><h4 id="2-2-使用-isPrototypeOf-方法"><a href="#2-2-使用-isPrototypeOf-方法" class="headerlink" title="2.2 使用 isPrototypeOf() 方法"></a>2.2 使用 isPrototypeOf() 方法</h4><p>如果一个实例的原型链中出现过相应构造函数的原型，那么 isPrototypeOf() 返回 true。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));<span class="hljs-comment">// true</span></code></pre></div><h3 id="3-原型链的问题"><a href="#3-原型链的问题" class="headerlink" title="3 原型链的问题"></a>3 原型链的问题</h3><h4 id="3-1-共享引用值"><a href="#3-1-共享引用值" class="headerlink" title="3.1 共享引用值"></a>3.1 共享引用值</h4><p>原型中包含引用值时，包含的引用值会在所有的实例之间共享。使用原型链实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性变成了原型属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">names</span> = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>];&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<span class="hljs-keyword">const</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">names</span>, s2.<span class="hljs-property">names</span>);<span class="hljs-comment">// [ &#x27;foo&#x27;, &#x27;bar&#x27; ] [ &#x27;foo&#x27;, &#x27;bar&#x27; ]</span>s2.<span class="hljs-property">names</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;foobar&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">names</span>);<span class="hljs-comment">// [ &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foobar&#x27; ]</span></code></pre></div><p>上述例子中实例 s1 对 names 属性的修改同样会体现在实例 s2 中。</p><h4 id="3-2-子类型实例化时不能给父类型传参"><a href="#3-2-子类型实例化时不能给父类型传参" class="headerlink" title="3.2 子类型实例化时不能给父类型传参"></a>3.2 子类型实例化时不能给父类型传参</h4><p>子类型在实例化时不能给父类型的构造函数传参。再加上之前提到的原型中包含应用值的问题，导致原型链基本上不会被单独使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】14.对象-构造函数和原型</title>
    <link href="/archives/a5403f42.html"/>
    <url>/archives/a5403f42.html</url>
    
    <content type="html"><![CDATA[<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>ES6 开始正式支持<strong>类</strong>和<strong>继承</strong>。ES6 的类仅仅是封装了 ES5.1 <strong>构造函数</strong>加上<strong>原型继承</strong>的语法糖。</p><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1 工厂模式"></a>1 工厂模式</h2><p><strong>工厂模式</strong>是一种设计模式，用于抽象<strong>创建特定对象</strong>的过程。下面是一个工厂模式创建对象的例子：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name, age</span>) &#123;  <span class="hljs-keyword">return</span> &#123; name, age &#125;;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">18</span>);<span class="hljs-comment">// &#123; name: &#x27;foo&#x27;, age: 18 &#125;</span><span class="hljs-keyword">const</span> p2 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">// &#123; name: &#x27;bar&#x27;, age: 20 &#125;</span></code></pre></div><p>工厂模式解决了创建多个类似对象的问题，但是没有解决对象的<strong>标识</strong>问题。也就是说新创建的对象是什么类型还是不知道。</p><h2 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2 构造函数模式"></a>2 构造函数模式</h2><p>构造函数用于创建<strong>特定类型</strong>的对象。像 Object 和 Array 这样的原生构造函数可以直接使用。也可以自定义构造函数，以函数的形式为自己的对象定义函数和方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">18</span>);<span class="hljs-comment">// Person &#123; name: &#x27;foo&#x27;, age: 18 &#125; </span><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">// Person &#123; name: &#x27;bar&#x27;, age: 20 &#125;</span></code></pre></div><p>使用 Person() 构造函数代替 createPerson() 工厂函数。实际上，Person() 内部的代码和 createPerson() 基本一样，区别如下：</p><ol><li>没有显式创建对象。</li><li>属性和方法直接赋值给了 this。</li><li>没有 return。</li></ol><p>按照惯例，作为构造函数的函数名首字母大写 ，非构造函数以小写开头。这有助于区分构造函数和普通函数。</p><h3 id="2-1-创建实例"><a href="#2-1-创建实例" class="headerlink" title="2.1 创建实例"></a>2.1 创建实例</h3><p>要创建一个对象类型的实例，应使用 new 操作符，后面跟上构造函数。以这种形式调用构造函数会执行以下操作：</p><ol><li>在内存中创建一个新的对象。</li><li><strong>这个对象内部的<code>[[Prototype]]</code>属性被赋值为构造函数的 <code>prototype</code> 属性</strong>。</li><li><strong>构造函数内部的 this 被赋值为这个新对象。即 this 指向新对象</strong>。</li><li>执行构造函数内部的代码。即给新对象添加属性。</li><li>如果构造函数没有返回值，则返回该对象。</li></ol><p>上个例子中，p1 和 p2 分别保存着 Person 的一个实例。这两个对象都有一个 constructor 属性指向 Person：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);</code></pre></div><p>constructor 本来是用来标识对象类型的。不过一般认为 instanceof 操作符是确定对象类型更为靠谱的方式。前面的两个对象都是 Object 的实例，同时也是 Person 的实例。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);<span class="hljs-comment">// true</span></code></pre></div><p>构造函数不一定写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">age, name</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;&#125;;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">18</span>, <span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-comment">// Person &#123; age: 18, name: &#x27;foo&#x27; &#125;</span></code></pre></div><p>实例化时，如果不想传递参数，那么构造函数后面的括号可以省略。只要有 new 操作符，就可以调用相应的构造函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;&#125;;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>;<span class="hljs-comment">// 不传参，可以省略构造函数后面的括号</span></code></pre></div><h3 id="2-2-构造函数也是函数"><a href="#2-2-构造函数也是函数" class="headerlink" title="2.2 构造函数也是函数"></a>2.2 构造函数也是函数</h3><p>构造函数和普通函数唯一的区别就是调用的方式不同。任何函数只要使用 new 操作符去调用就是构造函数，不使用 new 操作符调用的函数就是普通函数。</p><h3 id="2-3-构造函数的问题"><a href="#2-3-构造函数的问题" class="headerlink" title="2.3 构造函数的问题"></a>2.3 构造函数的问题</h3><p>构造函数解决了对象标识的问题，但是构造函数也不是没有问题。构造函数的问题在于，其定义的方法会在每一个对象实例上都创建一遍，这些方法<strong>不是</strong>指向<strong>同一个</strong> Function 实例。不同实例上的函数虽然同名但是不相等。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);  &#125;;&#125;;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">sayName</span> === p2.<span class="hljs-property">sayName</span>);<span class="hljs-comment">// false</span></code></pre></div><p>因为都是做同一件事，因此没必要定义两个不同的 Function 实例。可以将函数定义移到构造函数<strong>外</strong>来解决这个问题。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sayName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 在构造函数外定义方法</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);&#125;;<span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = sayName;<span class="hljs-comment">// 构造函数内部引用这个方法</span>&#125;;</code></pre></div><p>这种方式虽然解决了相同逻辑的函数重复定义的问题，但是构造函数内部使用的方法泄露到了构造函数外面。这个问题可以通过<strong>原型模式</strong>来解决。</p><h2 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3 原型模式"></a>3 原型模式</h2><p>每个<strong>函数</strong>都会创建一个 prototype 属性，这个属性值是一个对象，包含应该由特定引用类型的实例<strong>共享</strong>的属性和方法。这个对象就是通过调用构造函数创建的对象的<strong>原型</strong>。</p><p>使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例<strong>共享</strong>。原来在构造函数中直接赋值给对象实例的值，可以直接赋值给它们的原型。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);&#125;;<span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>);  <span class="hljs-comment">// foo</span>person1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">name</span>);  <span class="hljs-comment">// foo</span>person2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span> === person2.<span class="hljs-property">name</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">sayName</span> === person2.<span class="hljs-property">sayName</span>);<span class="hljs-comment">// true</span></code></pre></div><h3 id="3-1-理解原型"><a href="#3-1-理解原型" class="headerlink" title="3.1 理解原型"></a>3.1 理解原型</h3><h4 id="3-1-1-原型对象身上的-constructor-属性"><a href="#3-1-1-原型对象身上的-constructor-属性" class="headerlink" title="3.1.1 原型对象身上的 constructor 属性"></a>3.1.1 原型对象身上的 constructor 属性</h4><p>只要创建一个函数，就会为这个函数创建一个 prototype 属性，这个属性指向该函数的原型对象。所有的原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// Person</span></code></pre></div><h4 id="3-1-2-原型链"><a href="#3-1-2-原型链" class="headerlink" title="3.1.2 原型链"></a>3.1.2 原型链</h4><p>每次调用构造函数创建一个实例，这个实例内部的<code>[[Prototype]]</code> 属性都会被赋值为构造函数的<strong>原型对象</strong>。</p><blockquote><p>ECMAScript 中没有访问这个<code>[[Prototype]]</code>特性的标准方法，但是浏览器会在每个对象上暴露<code>__proto__</code>这个属性。通过这个属性可以访问到对象的原型。</p></blockquote><p>也就是说，**实例的<code>__proto__</code>上存放着构造函数的<code>prototype</code>**：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">// true</span></code></pre></div><p>而构造函数的 <code>prototype</code> 属性值同样也是一个对象实例。<strong>构造函数的 <code>prototype</code> 的 <code>__proto__</code>属性指向Object 构造函数的 <code>prototype</code>属性</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">// true</span></code></pre></div><p>同样的，Object.prototype 也是一个对象实例。Object.prototype 也有<code>__proto__</code>属性，但是它的属性值是 <code>null</code>。这就是原型链的终点。也就是说，**Object 原型的原型是 <code>null</code>**。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span>);</code></pre></div><h4 id="3-1-3-同一构造函数的不同实例共享同一原型对象"><a href="#3-1-3-同一构造函数的不同实例共享同一原型对象" class="headerlink" title="3.1.3 同一构造函数的不同实例共享同一原型对象"></a>3.1.3 同一构造函数的不同实例共享同一原型对象</h4><p>同一个构造函数创建的两个实例，共享同一原型对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span> === p2.<span class="hljs-property">__proto__</span>);<span class="hljs-comment">// true</span></code></pre></div><h4 id="3-1-4-使用-instanceof-检查实例的原型链中是否包含指定构造函数的原型"><a href="#3-1-4-使用-instanceof-检查实例的原型链中是否包含指定构造函数的原型" class="headerlink" title="3.1.4 使用 instanceof 检查实例的原型链中是否包含指定构造函数的原型"></a>3.1.4 使用 instanceof 检查实例的原型链中是否包含指定构造函数的原型</h4><p> 使用 instanceof 可以检查<strong>实例的原型链中是否包含指定构造函数的原型</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// p1 的原型链中包含 Person 构造函数的原型</span><span class="hljs-comment">// 因此 instanceof 操作符返回 true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);<span class="hljs-comment">// true</span><span class="hljs-comment">// p1 的原型链中包含 Object 构造函数的原型</span><span class="hljs-comment">// 因此 instanceof 操作符返回 true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);<span class="hljs-comment">// true</span></code></pre></div><h4 id="3-1-5-注意事项"><a href="#3-1-5-注意事项" class="headerlink" title="3.1.5 注意事项"></a>3.1.5 注意事项</h4><ol><li>原型对象包含 constructor 属性和其它后添加进来的属性。（原型对象的 constructor 属性指回构造函数）</li><li>如果在对象身上没有找某个属性，那么就会去沿着原型链去它的原型中去查找。</li></ol><h4 id="3-1-6-isPrototypeOf-验证实例的原型对象"><a href="#3-1-6-isPrototypeOf-验证实例的原型对象" class="headerlink" title="3.1.6 isPrototypeOf() 验证实例的原型对象"></a>3.1.6 isPrototypeOf() 验证实例的原型对象</h4><p>因为不是所有的实现都对外暴露了<code>[[Prototype]]</code>，因此 ECMAScript 提供了 isPrototypeOf() 方法。</p><p>isPrototypeOf() 方法用来验证一个对象是不是实例的原型对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 因为 p1.__proto__ 指向了 Person.prototype，</span><span class="hljs-comment">// 也就是说 Person.prototype 是 p1 的原型对象，</span><span class="hljs-comment">// 因此返回 true。</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(p1));<span class="hljs-comment">// true</span></code></pre></div><h4 id="3-1-7-Object-getPrototypeOf-返回-Prototype-的值"><a href="#3-1-7-Object-getPrototypeOf-返回-Prototype-的值" class="headerlink" title="3.1.7 Object.getPrototypeOf() 返回 [[Prototype]] 的值"></a>3.1.7 Object.getPrototypeOf() 返回 [[Prototype]] 的值</h4><p>因为不是所有的实现都对外暴露了<code>[[Prototype]]</code>，因此 ECMAScript 提供了 Object.getPrototypeOf() 方法。</p><p>Object.getPrototypeOf() 方法可以返回参数的内部属性<code>[[Prototype]]</code>的值，也就是浏览器实现的<code>__proto__</code>属性值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(p1) === p1.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">//true</span></code></pre></div><p>使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型。</p><h4 id="3-1-8-Object-setPrototypeOf-重写实例的原型对象"><a href="#3-1-8-Object-setPrototypeOf-重写实例的原型对象" class="headerlink" title="3.1.8 Object.setPrototypeOf() 重写实例的原型对象"></a>3.1.8 Object.setPrototypeOf() 重写实例的原型对象</h4><p>Object.setPrototypeOf() 方法可以向实例的私有属性<code>[[Prototype]]</code>写入一个新值。这样就可以重写一个对象的原型继承关系。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(p)); <span class="hljs-comment">// true</span><span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(p, obj);<span class="hljs-comment">// 重写实例的原型对象</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(p)); <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">isPrototypeOf</span>(p));              <span class="hljs-comment">// true</span></code></pre></div><blockquote><p><strong>注意</strong>：Object.setPrototypeOf() 严重影响代码性能。</p></blockquote><h4 id="3-1-9-Object-create-创建新对象并指定原型"><a href="#3-1-9-Object-create-创建新对象并指定原型" class="headerlink" title="3.1.9 Object.create() 创建新对象并指定原型"></a>3.1.9 Object.create() 创建新对象并指定原型</h4><p>为了避免 Object.setPrototypeOf() 造成的性能下降，可以通过 Object.create() 来创建一个新对象，同时指定原型。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,&#125;;<span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(obj);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span> === obj);<span class="hljs-comment">// true</span></code></pre></div><h3 id="3-2-原型层级"><a href="#3-2-原型层级" class="headerlink" title="3.2 原型层级"></a>3.2 原型层级</h3><p>在通过对象访问属性时，会从对象实例本身开始搜索。如果在这个实例上发现了给定的属性名，则返回该属性值。如果没有找到这个属性，则搜索会沿着指针进入<strong>原型对象</strong>，然后在原型对象上找到属性后再返回对应的值。找到属性后，搜索<strong>停止</strong>，不会再沿着原型链继续搜索。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<span class="hljs-comment">// 这个属性位于对象实例身上</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>);<span class="hljs-comment">// 这个属性位于对象原型上</span></code></pre></div><h4 id="3-2-1-hasOwnProperty-返回是否为自有属性"><a href="#3-2-1-hasOwnProperty-返回是否为自有属性" class="headerlink" title="3.2.1 hasOwnProperty() 返回是否为自有属性"></a>3.2.1 hasOwnProperty() 返回是否为自有属性</h4><p>hasOwnProperty() 方法用于确定某个属性是在实例上还是在原型对象上。在属性存在于调用它的对象实例上返回 true。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));<span class="hljs-comment">// true</span></code></pre></div><h4 id="3-2-2-Object-getOwnPropertyDescriptor-获取属性描述符"><a href="#3-2-2-Object-getOwnPropertyDescriptor-获取属性描述符" class="headerlink" title="3.2.2 Object.getOwnPropertyDescriptor() 获取属性描述符"></a>3.2.2 Object.getOwnPropertyDescriptor() 获取属性描述符</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(person, <span class="hljs-string">&quot;name&quot;</span>));<span class="hljs-comment">// &#123; value: &#x27;foo&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></code></pre></div><p>Object.getOwnPropertyDescriptor() 方法只对<strong>实例身上</strong>的属性（自有属性）有效。要取得原型属性的描述符，就必须在原型对象上调用Object.getOwnPropertyDescriptor()。</p><h3 id="3-3-原型和-in-操作符"><a href="#3-3-原型和-in-操作符" class="headerlink" title="3.3 原型和 in 操作符"></a>3.3 原型和 in 操作符</h3><p>有两种方法使用 in 操作符：单独使用和在 for-in 循环中使用。</p><h4 id="3-3-1-单独使用-in-操作符"><a href="#3-3-1-单独使用-in-操作符" class="headerlink" title="3.3.1 单独使用 in 操作符"></a>3.3.1 单独使用 in 操作符</h4><p>单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在<strong>实例</strong>上还是在<strong>原型</strong>上。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> person);<span class="hljs-comment">// 属性在实例上</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> person);<span class="hljs-comment">// 属性在原型上</span></code></pre></div><p>可以使用 in 操作符和 hasOwnProperty() 可以确定一个属性是否在原型上。如果一个属性可以通过 in 操作符返回 true，并且 hasOwnProperty() 返回 false，那么这个属性就在原型上。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">// 属性在原型上</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> person &amp;&amp; !person.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;age&quot;</span>));<span class="hljs-comment">// true</span></code></pre></div><h4 id="3-3-2-在-for-in-循环中使用-in-操作"><a href="#3-3-2-在-for-in-循环中使用-in-操作" class="headerlink" title="3.3.2 在 for-in 循环中使用 in 操作"></a>3.3.2 在 for-in 循环中使用 in 操作</h4><h5 id="in-返回实例身上和原型身上的可枚举属性"><a href="#in-返回实例身上和原型身上的可枚举属性" class="headerlink" title="in 返回实例身上和原型身上的可枚举属性"></a>in 返回实例身上和原型身上的可枚举属性</h5><p>在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会被返回，包括<strong>实例属性</strong>和<strong>原型属性</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> p) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, p[key]);<span class="hljs-comment">// [ &#x27;name&#x27; ]</span>&#125;</code></pre></div><h5 id="Object-keys-只返回实例身上的可枚举属性"><a href="#Object-keys-只返回实例身上的可枚举属性" class="headerlink" title="Object.keys() 只返回实例身上的可枚举属性"></a>Object.keys() 只返回实例身上的可枚举属性</h5><p>要想获得实例身上所有的有可枚举属性，而不带上原型身上的可枚举属性，可以使用 Object.keys() 方法。这个方法接收一个对象作为参数，返回对象身上所有的可枚举属性名组成的数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();p.<span class="hljs-property">addr</span> = <span class="hljs-string">&quot;bar&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(p));<span class="hljs-comment">// [ &#x27;name&#x27;, &#x27;addr&#x27; ]</span></code></pre></div><h5 id="Object-getOwnPropertyNames-返回实例身上所有属性（不包括符号），无论是否可枚举"><a href="#Object-getOwnPropertyNames-返回实例身上所有属性（不包括符号），无论是否可枚举" class="headerlink" title="Object.getOwnPropertyNames() 返回实例身上所有属性（不包括符号），无论是否可枚举"></a>Object.getOwnPropertyNames() 返回实例身上所有属性（不包括符号），无论是否可枚举</h5><p>如果想列出实例身上所有的属性（不包括符号），无论是否可枚举，可以使用 Object.getOwnPropertyNames()。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(p.<span class="hljs-property">__proto__</span>));<span class="hljs-comment">// [ &#x27;constructor&#x27;, &#x27;age&#x27; ]</span><span class="hljs-comment">// p.__proto__ 身上的不可枚举属性 constructor 也被列举出来了</span></code></pre></div><h5 id="Object-getOwnPropertySymbols-返回实例身上的符号属性"><a href="#Object-getOwnPropertySymbols-返回实例身上的符号属性" class="headerlink" title="Object.getOwnPropertySymbols() 返回实例身上的符号属性"></a>Object.getOwnPropertySymbols() 返回实例身上的符号属性</h5><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foo&quot;</span>)]: <span class="hljs-string">&quot;foo&quot;</span>,  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;bar&quot;</span>)]: <span class="hljs-string">&quot;bar&quot;</span>,&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj));<span class="hljs-comment">// [ Symbol(foo), Symbol(bar) ]</span></code></pre></div><h3 id="3-4-枚举属性顺序"><a href="#3-4-枚举属性顺序" class="headerlink" title="3.4 枚举属性顺序"></a>3.4 枚举属性顺序</h3><h4 id="枚举顺序不确定的方法："><a href="#枚举顺序不确定的方法：" class="headerlink" title="枚举顺序不确定的方法："></a>枚举顺序不确定的方法：</h4><p>for-in 循环、Object.keys() 枚举的顺序不确定。</p><h4 id="枚举顺序确定的方法："><a href="#枚举顺序确定的方法：" class="headerlink" title="枚举顺序确定的方法："></a>枚举顺序确定的方法：</h4><p>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.assign() 的顺序是确定的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。<strong>对象字面量</strong>定义的键以它们逗号分隔的顺序插入。</p><h3 id="3-4-对象迭代"><a href="#3-4-对象迭代" class="headerlink" title="3.4 对象迭代"></a>3.4 对象迭代</h3><p>ECMAScript 2017 中新增了两个静态方法，用于将对象内容转化为序列化的、可迭代的格式。Object.values() 和 Object.entires() 接收一个对象，返回一个数组。Object.values() 返回对象值的数组，Object.entires() 返回键值对的数组。这两个方法都只会返回对象<strong>实例身上</strong>的属性，不会返回原型对象身上的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;foo&quot;</span>;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();p.<span class="hljs-property">addr</span> = <span class="hljs-string">&quot;bar&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(p));<span class="hljs-comment">// [ &#x27;foo&#x27;, &#x27;bar&#x27; ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(p));<span class="hljs-comment">// [ [ &#x27;name&#x27;, &#x27;foo&#x27; ], [ &#x27;addr&#x27;, &#x27;bar&#x27; ] ]</span></code></pre></div><h3 id="3-5-对象字面量重写原型"><a href="#3-5-对象字面量重写原型" class="headerlink" title="3.5 对象字面量重写原型"></a>3.5 对象字面量重写原型</h3><h4 id="3-5-1-使用对象字面量重写原型"><a href="#3-5-1-使用对象字面量重写原型" class="headerlink" title="3.5.1 使用对象字面量重写原型"></a>3.5.1 使用对象字面量重写原型</h4><p>为了减少冗余和从视觉上更好地封装原型功能，可以使用对象字面量来重写原型。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-attr">addr</span>: <span class="hljs-string">&quot;bar&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;</code></pre></div><h4 id="3-5-2-重写原型带来的-constructor-问题"><a href="#3-5-2-重写原型带来的-constructor-问题" class="headerlink" title="3.5.2 重写原型带来的 constructor 问题"></a>3.5.2 重写原型带来的 constructor 问题</h4><p>这样重写之后 Person.prototype 之后，Person.prototype 的 constructor 属性不再指向 Person 构造函数。而是沿着原型链找到 <code>Person.prototype.__proto__.constructor</code> 也就是 Object 构造函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>);</code></pre></div><p>虽然此时 instanceof 操作符还能可靠地返回值，但是已经不能依靠 constructor 属性来识别类型了。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-attr">addr</span>: <span class="hljs-string">&quot;bar&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>);<span class="hljs-comment">// [Function: Object]</span></code></pre></div><h4 id="3-5-3-重写-constructor"><a href="#3-5-3-重写-constructor" class="headerlink" title="3.5.3 重写 constructor"></a>3.5.3 重写 constructor</h4><p>如果 constructor 的值非常重要，可以在重写原型时同时指定 constructor。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<span class="hljs-comment">// 重写原型时指定 constructor</span>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-attr">addr</span>: <span class="hljs-string">&quot;bar&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;</code></pre></div><p>此时的 constructor 属性是可枚举的，如果想让 constructor 恢复成原生的<strong>不可枚举</strong>的属性，可以使用Object.defineProperty()。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-attr">addr</span>: <span class="hljs-string">&quot;bar&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">// 默认也是不可枚举</span>  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span>,&#125;);</code></pre></div><h3 id="3-6-原型的动态性"><a href="#3-6-原型的动态性" class="headerlink" title="3.6 原型的动态性"></a>3.6 原型的动态性</h3><p>虽然，随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这和重写这个原型对象是两码事。实例的<code>[[Prototype]]</code>指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。</p><p><strong>重写整个原型会切断最初原型和构造函数之间的关系，但实例引用的还是最初的原型</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);<span class="hljs-comment">// undefined </span></code></pre></div><p>重写构造函数上的原型之后创建的实才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。</p><h3 id="3-7-原生对象原型"><a href="#3-7-原生对象原型" class="headerlink" title="3.7 原生对象原型"></a>3.7 原生对象原型</h3><p>原型模式之索引重要，不仅体现在自定义类型上，而且因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（比如：Object、Array、String 等）都在原型上定义了实例方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sort</span>);<span class="hljs-comment">// [Function: sort]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">substring</span>);<span class="hljs-comment">// [Function: substring]</span></code></pre></div><p>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生实例定义新的方法（但不建议这样做）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】13.对象-属性</title>
    <link href="/archives/2d79b123.html"/>
    <url>/archives/2d79b123.html</url>
    
    <content type="html"><![CDATA[<h1 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h1><p>ECMAScript 中对象是一组属性的无序集合。可以将对象看作一张散列表，其中的内容是一组<strong>名&#x2F;值对</strong>，值可以是数据或者函数。</p><p>创建自定义对象的通常方法是创建 Object 的一个新实例，然后给它添加属性和方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();obj.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;obj.<span class="hljs-property">fn</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;;</code></pre></div><p>或者使用<strong>对象字面量</strong>的方式来创建新对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);  &#125;,&#125;;</code></pre></div><h2 id="1-Object-defineProperty-定义属性"><a href="#1-Object-defineProperty-定义属性" class="headerlink" title="1 Object.defineProperty() 定义属性"></a>1 Object.defineProperty() 定义属性</h2><p>ECMAScript 中使用一些<strong>内部特性</strong>来描述属性的特征，开发者不能直接访问这些特性。为了表述某个属性是内部属性，应该用<strong>两个中括号</strong>括起来。</p><h3 id="1-1-数据属性"><a href="#1-1-数据属性" class="headerlink" title="1.1 数据属性"></a>1.1 数据属性</h3><p><strong>数据属性</strong>包含一个保存数据值的位置。数据属性有4个特性来描述它们的行为。</p><ol><li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义、是否可以修改它的特性以及是否可以把它修改为访问器属性。默认情况下是 true。（一个属性如果被定为不可配置，就不可能变回可配置的了）</li><li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。默认情况下是 true。</li><li><code>[[Writable]]</code>：表示属性的值是否可以被修改。默认情况下是 true。</li><li><code>[[Value]]</code>：包含属性的实际值。这是读取和写入属性值的位置。默认值是 undefined。</li></ol><blockquote><p><strong>注意</strong>：将属性像前面那样<strong>显式添加到对象</strong>后，<code>[[Configurable]]</code>、<code>[[Enumerable]]</code>、<code>[[Writable]]</code>都会被设置为 <strong>true</strong>，<code>[[Value]]</code>会被设置为指定的值。</p></blockquote><p>要修改属性的默认属性，就必须使用 Object.defineProperty() 方法。这个方法接收三个参数：要给其添加属性的对象、属性的名称和一个<strong>描述符对象</strong>。描述符对象上的属性可以包含 configurable、enumerable、writable 和 value，和相关特性的名称一一对应。</p><blockquote><p><strong>注意</strong>：使用 Object.defineProperty() 定义或者修改属性时，如果描述符对象没有指定 configurable、enumerable 和 writable 属性值，那么默认是<strong>false</strong>。 </p></blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;a&quot;</span>, &#123;  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">// 添加a属性，并设置为不可修改</span>  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>); <span class="hljs-comment">// 1</span>obj.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<span class="hljs-comment">// 尝试修改a属性，不报错但是静默失败</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>); <span class="hljs-comment">// 1</span></code></pre></div><h3 id="1-2-访问器属性"><a href="#1-2-访问器属性" class="headerlink" title="1.2 访问器属性"></a>1.2 访问器属性</h3><p>访问器属性不包含属性值，相反包含一个获取函数（Getter）和设置函数（Setter），不过这个两个函数都不是必须的。在<strong>读取</strong>访问器属性时，会调用<strong>获取函数</strong>，这个函数的责任是返回一个有效值。在<strong>写入</strong>访问器属性时，会调用<strong>设置函数</strong>并传入新值，这个函数的责任是对数据进行修改。访问器属性有4个特性描述它们的行为。</p><ol><li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义、是否可以修改它的特性以及是否可以把它修改为数据属性。默认情况下是 true。</li><li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。默认情况下是 true。</li><li><code>[[Get]]</code>：获取函数。默认值为 undefined。</li><li><code>[[Set]]</code>：设置函数。默认值为 undefined。</li></ol><p>在<strong>已有对象</strong>的情况下，访问器属性<strong>不能直接定义</strong>，必须使用 Object.defineProperty()。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> book = &#123;  <span class="hljs-attr">year_</span>: <span class="hljs-number">2022</span>,<span class="hljs-comment">// 伪内部属性</span>  <span class="hljs-attr">edition</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(book, <span class="hljs-string">&quot;year&quot;</span>, &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span>;  &#125;,  <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span> = newVal;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> += newVal - <span class="hljs-number">2022</span>;  &#125;,&#125;);book.<span class="hljs-property">year</span> = <span class="hljs-number">2030</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(book.<span class="hljs-property">edition</span>);</code></pre></div><p>year_ 中的<strong>下划线</strong>常用来表示该属性不希望在对象方法外部被访问。year 被定义为一个访问器属性，其获取函数会返回 year_ 的值，设置函数会修改 year_ 并计算 edition 的值。这是访问器属性的典型使用场景，即<strong>设置一个属性值会导致一些其它的变化</strong>。</p><p>获取函数和设置函数不用都定义。只定义获取函数意味着属性是只读的，只定义设置函数意味着属性不能读取。</p><h2 id="2-Object-defineProperties-定义多个属性"><a href="#2-Object-defineProperties-定义多个属性" class="headerlink" title="2 Object.defineProperties() 定义多个属性"></a>2 Object.defineProperties() 定义多个属性</h2><p>Object.defineProperties() 方法可以通过多个描述符在一个对象上一次定义多个属性。这个方法接收两个参数：要为之添加或者修改的对象和描述符对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> book = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(book, &#123;  <span class="hljs-attr">year_</span>: &#123;    <span class="hljs-attr">value</span>: <span class="hljs-number">2022</span>,  &#125;,  <span class="hljs-attr">edition</span>: &#123;    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,  &#125;,  <span class="hljs-attr">year</span>: &#123;    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span>;    &#125;,    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span> = newVal;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> += newVal - <span class="hljs-number">2022</span>;    &#125;,  &#125;,&#125;);</code></pre></div><p>这个例子定义的对象和前面的相同，只是这个对象的属性是一次同时定义的。</p><h2 id="3-读取属性的特性"><a href="#3-读取属性的特性" class="headerlink" title="3 读取属性的特性"></a>3 读取属性的特性</h2><h3 id="3-1-Object-getOwnPropertyDescriptor"><a href="#3-1-Object-getOwnPropertyDescriptor" class="headerlink" title="3.1 Object.getOwnPropertyDescriptor()"></a>3.1 Object.getOwnPropertyDescriptor()</h3><p>Object.getOwnPropertyDescriptor() 方法可以取得指定属性的<strong>属性描述符</strong>。这个方法接收两个参数：属性所在的对象和属性名。返回值是一个对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> descriptor1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(book, <span class="hljs-string">&quot;year&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor1);<span class="hljs-comment">// &#123;</span><span class="hljs-comment">//  get: [Function: get],</span><span class="hljs-comment">//  set: [Function: set],</span><span class="hljs-comment">//  enumerable: false,</span><span class="hljs-comment">//  configurable: false</span><span class="hljs-comment">// &#125;</span><span class="hljs-keyword">const</span> descriptor2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(book, <span class="hljs-string">&quot;year_&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor2);<span class="hljs-comment">// &#123;</span><span class="hljs-comment">//  value: 2022,</span><span class="hljs-comment">//  writable: false,</span><span class="hljs-comment">//  enumerable: false,</span><span class="hljs-comment">//  configurable: false</span><span class="hljs-comment">// &#125;</span></code></pre></div><h3 id="3-2-Object-getOwnPropertyDescriptors"><a href="#3-2-Object-getOwnPropertyDescriptors" class="headerlink" title="3.2 Object.getOwnPropertyDescriptors()"></a>3.2 Object.getOwnPropertyDescriptors()</h3><p>Object.getOwnPropertyDescriptors() 会在每个属性上调用 Object.getOwnPropertyDescriptor()，并在一个新对象中返回它们。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> descriptors = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(book);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptors);<span class="hljs-comment">//&#123;</span><span class="hljs-comment">//  year_: &#123;</span><span class="hljs-comment">//    value: 2022,</span><span class="hljs-comment">//    writable: false,</span><span class="hljs-comment">//    enumerable: false,</span><span class="hljs-comment">//    configurable: false</span><span class="hljs-comment">//  &#125;,</span><span class="hljs-comment">//  edition: &#123; value: 1, writable: false, enumerable: false, configurable: false &#125;,</span><span class="hljs-comment">//  year: &#123;</span><span class="hljs-comment">//    get: [Function: get],</span><span class="hljs-comment">//    set: [Function: set],</span><span class="hljs-comment">//    enumerable: false,</span><span class="hljs-comment">//    configurable: false</span><span class="hljs-comment">//  &#125;</span><span class="hljs-comment">//&#125;</span></code></pre></div><h2 id="4-Object-assign-合并对象"><a href="#4-Object-assign-合并对象" class="headerlink" title="4 Object.assign() 合并对象"></a>4 Object.assign() 合并对象</h2><p>合并（merge）或者混入（mixin），指的是把源对象的属性一起复制到目标对象上。目标对象通过混入源对象的属性得到了增强。</p><p>ES6 中专门为合并对象提供了 Object.assign() 方法。这个方法接收一个目标对象和一个或者多个源对象作为参数，然后将每个源对象中<strong>可枚举</strong>的<strong>自有</strong>属性复制到目标对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>类型和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a> 类型的属性都会被拷贝。</p><p>Object.assign() 修改目标对象，并且返回修改后的<strong>新</strong>目标对象。</p><p>简单复制：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dest = &#123;&#125;;<span class="hljs-keyword">const</span> src = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, src);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest);      <span class="hljs-comment">// &#123; a: 1 &#125;</span></code></pre></div><p>多个源对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dest = &#123;&#125;;<span class="hljs-keyword">const</span> src1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> src2 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, src1, src2);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest);<span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span></code></pre></div><p>对于每个符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标对象上的<code>[[Set]]</code>设置属性的值。Getter 和 Setter：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dest = &#123;  <span class="hljs-keyword">set</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">val</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`setter <span class="hljs-subst">$&#123;val&#125;</span>`</span>);  &#125;,&#125;;<span class="hljs-keyword">const</span> src = &#123;  <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`getter`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;foo&quot;</span>;  &#125;,&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, src);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest);<span class="hljs-comment">// getter</span><span class="hljs-comment">// setter foo</span><span class="hljs-comment">// &#123; a: [Setter] &#125;</span></code></pre></div><p>如果多个源对象有相同的属性，则使用<strong>最后一个</strong>复制的值。覆盖属性：</p><div class="code-wrapper"><pre><code class="hljs javascript">dest = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;, &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> &#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest);<span class="hljs-comment">// &#123; a: 3 &#125;</span></code></pre></div><p>Object.assign() 实际上对每个源对象执行的是<strong>浅复制</strong>，意味着只会复制对象的引用。浅复制：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dest = &#123;&#125;;<span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: &#123;&#125; &#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, obj);<span class="hljs-comment">// 浅复制意味着只会复制对象的引用</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest.<span class="hljs-property">a</span> === obj.<span class="hljs-property">a</span>);<span class="hljs-comment">// true</span></code></pre></div><p>如果复制期间出错，操作会<strong>停止并退出</strong>，同时抛出错误。此时，Object.assign() 不会回滚，只会完成部分复制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dest = &#123;&#125;;<span class="hljs-keyword">const</span> src = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,  <span class="hljs-keyword">get</span> <span class="hljs-title function_">b</span>() &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();  &#125;,&#125;;<span class="hljs-keyword">try</span> &#123;  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, src);&#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest);  <span class="hljs-comment">// &#123; a: 1 &#125;</span></code></pre></div><h2 id="5-Object-is-判定对象相等"><a href="#5-Object-is-判定对象相等" class="headerlink" title="5 Object.is() 判定对象相等"></a>5 Object.is() 判定对象相等</h2><h3 id="5-1-使用-x3D-x3D-x3D-操作符"><a href="#5-1-使用-x3D-x3D-x3D-操作符" class="headerlink" title="5.1 使用 &#x3D;&#x3D;&#x3D; 操作符"></a>5.1 使用 &#x3D;&#x3D;&#x3D; 操作符</h3><p>符合预期的情况：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> === <span class="hljs-number">1</span>);<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; === &#123;&#125;);<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span> === <span class="hljs-number">2</span>);<span class="hljs-comment">// false</span></code></pre></div><p>被认为是相等的情况：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> === <span class="hljs-number">0</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">0</span> === <span class="hljs-number">0</span>);<span class="hljs-comment">// true</span></code></pre></div><p>确定 NaN 的相等性需要使用 isNaN()：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>);<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>));<span class="hljs-comment">// true</span></code></pre></div><h3 id="5-2-使用-Object-is-判定相等"><a href="#5-2-使用-Object-is-判定相等" class="headerlink" title="5.2 使用 Object.is() 判定相等"></a>5.2 使用 Object.is() 判定相等</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-literal">true</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">// false </span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(&#123;&#125;, &#123;&#125;));<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">2</span>));<span class="hljs-comment">// false</span></code></pre></div><p>正确的0、-0、+0 相等&#x2F;不相等判定：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(+<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>));<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(+<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(-<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">// false</span></code></pre></div><p>正确的 NaN 判定：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>));<span class="hljs-comment">// true</span></code></pre></div><p>要检查超过两个值，递归利用相等性传递即可。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursivelyCheckEqual</span>(<span class="hljs-params">x, ...rest</span>) &#123;  <span class="hljs-keyword">return</span> (    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(x, rest[<span class="hljs-number">0</span>]) &amp;&amp; (rest.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span> || <span class="hljs-title function_">recursivelyCheckEqual</span>(...rest))  );&#125;</code></pre></div><h2 id="6-增强对象语法"><a href="#6-增强对象语法" class="headerlink" title="6 增强对象语法"></a>6 增强对象语法</h2><p>ES6 新增的语法糖。</p><h3 id="6-1-属性名简写"><a href="#6-1-属性名简写" class="headerlink" title="6.1 属性名简写"></a>6.1 属性名简写</h3><p>给对象添加属性时，属性名和变量名经常是一致的：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: name,<span class="hljs-comment">// 属性名和变量名一致</span>&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; name: &#x27;foo&#x27; &#125;</span></code></pre></div><p>属性名简写<strong>只需要使用变量名</strong>，就可以被解释为同名的属性键：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-keyword">const</span> obj = &#123;  name,<span class="hljs-comment">// 属性名简写</span>&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);</code></pre></div><h3 id="6-2-可计算属性"><a href="#6-2-可计算属性" class="headerlink" title="6.2 可计算属性"></a>6.2 可计算属性</h3><p>引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明变量，然后再使用中括号语法来添加属性。也就是不能在对象字面量中直接动态命名属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-string">&quot;c&quot;</span>;<span class="hljs-keyword">const</span> obj = &#123;&#125;;obj[a] = <span class="hljs-number">1</span>;obj[b] = <span class="hljs-number">2</span>;obj[c] = <span class="hljs-number">3</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></code></pre></div><p>有了可计算属性后，可以直接在对象字面量中完成<strong>动态属性赋值</strong>。中括号包围的对象属性键告诉 JavaScript 将其作为 <strong>JavaScript 表达式</strong>而不是字符串求值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-string">&quot;c&quot;</span>;<span class="hljs-keyword">const</span> obj = &#123;  [a]: <span class="hljs-number">1</span>,  [b]: <span class="hljs-number">2</span>,  [c]: <span class="hljs-number">3</span>,&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></code></pre></div><p>注意：可计算属性表达式中抛出任何错误都会终止对象的创建。且不能回滚。</p><h3 id="6-3-方法名简写"><a href="#6-3-方法名简写" class="headerlink" title="6.3 方法名简写"></a>6.3 方法名简写</h3><p>给对象定义方法时，通常需要一个方法名、冒号然后引用一个匿名函数表达式。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);  &#125;,&#125;;person.<span class="hljs-title function_">sayName</span>()<span class="hljs-comment">// foo</span></code></pre></div><p>简写形式：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 简写形式</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);  &#125;,&#125;;person.<span class="hljs-title function_">sayName</span>();<span class="hljs-comment">// foo</span></code></pre></div><p>方法名的简写同样适用于获取函数和设置函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;  <span class="hljs-attr">name_</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<span class="hljs-comment">// 获取函数的简写形式</span>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span>;  &#125;,  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newVal</span>) &#123;<span class="hljs-comment">// 设置函数的简写形式</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = newVal;  &#125;,  <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span>);  &#125;,&#125;;person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;bar&quot;</span>;person.<span class="hljs-title function_">sayName</span>();<span class="hljs-comment">// bar</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<span class="hljs-comment">// &#123; name_: &#x27;bar&#x27;, name: [Getter/Setter], sayName: [Function: sayName] &#125;</span></code></pre></div><h2 id="7-对象解构"><a href="#7-对象解构" class="headerlink" title="7 对象解构"></a>7 对象解构</h2><p>ES6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或者多个赋值操作。简单的说，对象解构就是使用与对象匹配的结构来实现对象属性的赋值。</p><h3 id="7-1-解构赋值"><a href="#7-1-解构赋值" class="headerlink" title="7.1 解构赋值"></a>7.1 解构赋值</h3><p>不使用解构操作：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-keyword">let</span> personName = person.<span class="hljs-property">name</span>;<span class="hljs-keyword">let</span> personAge = person.<span class="hljs-property">age</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName);<span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personAge);<span class="hljs-comment">// 18</span></code></pre></div><p>使用对象解构：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: personName, <span class="hljs-attr">age</span>: personAge &#125; = person;<span class="hljs-comment">// 变量的解构赋值</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName);<span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personAge);<span class="hljs-comment">// 18 </span></code></pre></div><p>如果想让变量直接使用属性的名称，还可以使用<strong>简写语法</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-keyword">let</span> &#123; name, age &#125; = person;<span class="hljs-comment">// 变量解构赋值+简写语法</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<span class="hljs-comment">// foo</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<span class="hljs-comment">// 18 </span></code></pre></div><p>解构赋值不一定与原对象的属性匹配。赋值的时候可以<strong>忽略某些属性</strong>，如果引用的属性不存在，则该变量的值是undefined。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<span class="hljs-comment">// 对象中没有name这个属性</span>&#125;;<span class="hljs-keyword">let</span> &#123; name, age &#125; = person;<span class="hljs-comment">// 变量解构赋值</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<span class="hljs-comment">// 此时的name是undefined</span></code></pre></div><p>也可以在解构赋值的同时定义默认值，适用于上述引用的属性中不存在于原对象中的情况。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-keyword">let</span> &#123; name = <span class="hljs-string">&quot;foo&quot;</span>, age &#125; = person;<span class="hljs-comment">// 变量解构赋值</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);</code></pre></div><p>null 和 undefined 不能被解构，否则抛出错误。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; foo &#125; = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 报错</span><span class="hljs-keyword">const</span> &#123; bar &#125; = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// 报错</span></code></pre></div><p>解构不要求必须在解构表达式中声明。不过，如果是事先声明的变量赋值，则赋值表达式必须包含在一对括号中。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age, name;<span class="hljs-keyword">const</span> person = &#123;  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,&#125;;(&#123; age, name &#125; = person);<span class="hljs-comment">// 18</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age, name);<span class="hljs-comment">// foo</span></code></pre></div><h3 id="7-2-嵌套解构"><a href="#7-2-嵌套解构" class="headerlink" title="7.2 嵌套解构"></a>7.2 嵌套解构</h3><p>解构赋值可以使用嵌套解构，以匹配嵌套的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,  <span class="hljs-attr">job</span>: &#123;    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;bar&quot;</span>,  &#125;,&#125;;<span class="hljs-keyword">let</span> &#123;  <span class="hljs-attr">job</span>: &#123; title &#125;,&#125; = person;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title); <span class="hljs-comment">// bar</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(job);   <span class="hljs-comment">// 报错</span></code></pre></div><h3 id="7-3-部分解构"><a href="#7-3-部分解构" class="headerlink" title="7.3 部分解构"></a>7.3 部分解构</h3><p>如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，那么整个解构赋值只会完成一部分。</p><h3 id="7-4-参数列表中使用解构赋值"><a href="#7-4-参数列表中使用解构赋值" class="headerlink" title="7.4 参数列表中使用解构赋值"></a>7.4 参数列表中使用解构赋值</h3><p>在函数的参数列表中使用解构赋值。对参数的解构赋值不会影响 arguments 对象，但是可以在函数签名中声明在函数体内使用的局部变量。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tourry&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">foo, &#123; name, age &#125;, bar</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">foo, &#123; name: personName, age: personAge &#125;, bar</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName, personAge);&#125;<span class="hljs-title function_">fn</span>(<span class="hljs-string">&quot;a&quot;</span>, person, <span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">// [Arguments] &#123; &#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#123; name: &#x27;Tourry&#x27;, age: 18 &#125;, &#x27;2&#x27;: &#x27;b&#x27; &#125;</span><span class="hljs-comment">// Tourry 18</span><span class="hljs-title function_">fn2</span>(<span class="hljs-string">&quot;a&quot;</span>, person, <span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">// [Arguments] &#123; &#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#123; name: &#x27;Tourry&#x27;, age: 18 &#125;, &#x27;2&#x27;: &#x27;b&#x27; &#125;</span><span class="hljs-comment">// Tourry 18</span></code></pre></div><h2 id="8-Object-fromEntries-键值对列表转为对象"><a href="#8-Object-fromEntries-键值对列表转为对象" class="headerlink" title="8 Object.fromEntries() 键值对列表转为对象"></a>8 Object.fromEntries() 键值对列表转为对象</h2><p>Object.fromEntries() 可以将键值对列表转为对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>]])<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】12.集合引用类型-Map、Set</title>
    <link href="/archives/2d755eba.html"/>
    <url>/archives/2d755eba.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Map"><a href="#1-Map" class="headerlink" title="1 Map"></a>1 Map</h1><p>Map 是 ES6 新增的一种新的集合类型。Map 的大多属性都可以通过 Object 实现，但有一些细微差异。</p><h2 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h2><p>使用 new 关键字和 Map 构造函数可以创建一个空<strong>映射</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);<span class="hljs-comment">// Map(0) &#123;&#125;</span></code></pre></div><p>如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个<strong>可迭代对象</strong>。</p><p>使用<strong>嵌套数组</strong>初始化实例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([  [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>],  [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>],]);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);<span class="hljs-comment">// Map(2) &#123; &#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2 &#125;</span></code></pre></div><p>使用自定义<strong>可迭代对象</strong>初始化实例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(&#123;  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span>* () &#123;    <span class="hljs-keyword">yield</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>];    <span class="hljs-keyword">yield</span> [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>];  &#125;,&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);<span class="hljs-comment">// Map(2) &#123; &#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2 &#125;</span></code></pre></div><h2 id="1-2-set-添加"><a href="#1-2-set-添加" class="headerlink" title="1.2 set() 添加"></a>1.2 set() 添加</h2><p>使用 set() 方法可以向 Map 中添加键值对。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);<span class="hljs-comment">// Map(1) &#123; &#x27;a&#x27; =&gt; 1 &#125;</span></code></pre></div><p>set() 方法返回 Map 实例，因此可以将多个操作连起来，包括初始化声明。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);<span class="hljs-comment">// Map(2) &#123; &#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2 &#125;</span></code></pre></div><h2 id="1-3-查询"><a href="#1-3-查询" class="headerlink" title="1.3 查询"></a>1.3 查询</h2><h3 id="1-3-1-get-根据键查询值"><a href="#1-3-1-get-根据键查询值" class="headerlink" title="1.3.1 get() 根据键查询值"></a>1.3.1 get() 根据键查询值</h3><p>使用 get() 方法可以根据键查询值，若查不到返回 undefined。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;a&quot;</span>));    <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;d&quot;</span>));    <span class="hljs-comment">// undefined</span></code></pre></div><h3 id="1-3-2-has-查询是否存在某个键"><a href="#1-3-2-has-查询是否存在某个键" class="headerlink" title="1.3.2 has() 查询是否存在某个键"></a>1.3.2 has() 查询是否存在某个键</h3><p>使用 has() 方法可以查询是否存在某个键，存在返回 true，不存在返回 false。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;a&#x27;</span>));    <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;d&#x27;</span>));    <span class="hljs-comment">// false</span></code></pre></div><h3 id="1-3-3-size-属性"><a href="#1-3-3-size-属性" class="headerlink" title="1.3.3 size 属性"></a>1.3.3 size 属性</h3><p>size 属性中存放键值对的数量。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-property">size</span>);<span class="hljs-comment">// 3</span></code></pre></div><h2 id="1-4-删除"><a href="#1-4-删除" class="headerlink" title="1.4 删除"></a>1.4 删除</h2><h3 id="1-4-1-delete-根据单个键删除键值对"><a href="#1-4-1-delete-根据单个键删除键值对" class="headerlink" title="1.4.1 delete() 根据单个键删除键值对"></a>1.4.1 delete() 根据单个键删除键值对</h3><p>使用 delete() 可以删除单个键值对。删除成功返回 true，删除失败返回 false。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);     <span class="hljs-comment">// Map(3) &#123; &#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2, &#x27;c&#x27; =&gt; 3 &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;a&quot;</span>));     <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);     <span class="hljs-comment">// Map(2) &#123; &#x27;b&#x27; =&gt; 2, &#x27;c&#x27; =&gt; 3 &#125;</span></code></pre></div><h3 id="1-4-2-clear-清空所有键值对"><a href="#1-4-2-clear-清空所有键值对" class="headerlink" title="1.4.2 clear() 清空所有键值对"></a>1.4.2 clear() 清空所有键值对</h3><p>使用 clear() 可以清空映射中所有的键值对。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m); <span class="hljs-comment">// Map(3) &#123; &#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2, &#x27;c&#x27; =&gt; 3 &#125;</span>m.<span class="hljs-title function_">clear</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m); <span class="hljs-comment">// Map(0) &#123;&#125;</span></code></pre></div><h2 id="1-5-使用任意类型作为键和值"><a href="#1-5-使用任意类型作为键和值" class="headerlink" title="1.5 使用任意类型作为键和值"></a>1.5 使用任意类型作为键和值</h2><p>和 Object 只能使用数字、字符串和符号作为对象不同，Map 可以使用<strong>任何数据类型</strong>作为键。Map 内部使用类似严格相等的标准（SameValueZero）检查键的匹配性。和 Object 一样，映射的值没有类型限制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> func = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-keyword">const</span> arr = [];<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(func, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(obj, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(arr, <span class="hljs-number">3</span>);</code></pre></div><p>当引用值作为键和值改变时：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<span class="hljs-keyword">const</span> objKey = &#123;&#125;;<span class="hljs-keyword">const</span> objVal = &#123;&#125;;<span class="hljs-keyword">const</span> arrKey = [];<span class="hljs-keyword">const</span> arrVal = [];m.<span class="hljs-title function_">set</span>(objKey, objVal);m.<span class="hljs-title function_">set</span>(arrKey, arrVal);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objVal === m.<span class="hljs-title function_">get</span>(objKey)); <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m); <span class="hljs-comment">// Map(2) &#123; &#123;&#125; =&gt; &#123;&#125;, [] =&gt; [] &#125;</span>objKey.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;objVal.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;arrKey.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;c&quot;</span>);arrVal.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;d&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m); <span class="hljs-comment">// Map(2) &#123; &#123; a: 1 &#125; =&gt; &#123; b: 2 &#125;, [ &#x27;c&#x27; ] =&gt; [ &#x27;d&#x27; ] &#125;</span></code></pre></div><h2 id="1-6-顺序和迭代"><a href="#1-6-顺序和迭代" class="headerlink" title="1.6 顺序和迭代"></a>1.6 顺序和迭代</h2><p>与 Object 的一个主要区别是，Map 实例会维护键值对插入时的顺序，因此可以根据插入顺序进行迭代。</p><h3 id="1-6-0-for-of-使用默认迭代器"><a href="#1-6-0-for-of-使用默认迭代器" class="headerlink" title="1.6.0 for-of 使用默认迭代器"></a>1.6.0 for-of 使用默认迭代器</h3><p>Map 定义了默认迭代器 entires()，支持顺序迭代。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([  [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>],  [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>],]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> map) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val, val[<span class="hljs-number">0</span>], val[<span class="hljs-number">1</span>]);&#125;<span class="hljs-comment">// [ &#x27;a&#x27;, 1 ] a 1</span><span class="hljs-comment">// [ &#x27;b&#x27;, 2 ] b 2</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([  [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>],  [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>],]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> map) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k, v);&#125;<span class="hljs-comment">// a 1</span><span class="hljs-comment">// b 2</span></code></pre></div><h3 id="1-6-1-使用-entries"><a href="#1-6-1-使用-entries" class="headerlink" title="1.6.1 使用 entries()"></a>1.6.1 使用 entries()</h3><p>映射实例可以提供一个迭代器，能以插入顺序生成 [key,val] 数组。可以通过 entries() 方法或者 Symbol.iterator 属性（这个属性指向 entries() 方法）来取得这个迭代器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-property">entries</span> === m[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]);<span class="hljs-comment">// true</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> pair <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">entries</span>()) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair);&#125;<span class="hljs-comment">// [ &#x27;a&#x27;, 1 ]</span><span class="hljs-comment">// [ &#x27;b&#x27;, 2 ]</span><span class="hljs-comment">// [ &#x27;c&#x27;, 3 ]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> pair <span class="hljs-keyword">of</span> m[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair);&#125;<span class="hljs-comment">// [ &#x27;a&#x27;, 1 ]</span><span class="hljs-comment">// [ &#x27;b&#x27;, 2 ]</span><span class="hljs-comment">// [ &#x27;c&#x27;, 3 ]</span></code></pre></div><p>因为 entries() 是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转为数组：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...m]);<span class="hljs-comment">// [ [ &#x27;a&#x27;, 1 ], [ &#x27;b&#x27;, 2 ], [ &#x27;c&#x27;, 3 ] ]</span></code></pre></div><h3 id="1-6-2-使用-forEach"><a href="#1-6-2-使用-forEach" class="headerlink" title="1.6.2 使用 forEach()"></a>1.6.2 使用 forEach()</h3><p>调用映射的 forEach() 方法并传入回调，依次迭代每个键值对。传入的回调接收可选的第二个参数，这个参数用来重写回调内部的 this 值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);m.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key, val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, val));<span class="hljs-comment">// 1 a</span><span class="hljs-comment">// 2 b</span><span class="hljs-comment">// 3 c</span></code></pre></div><h3 id="1-6-3-使用-keys-和-values"><a href="#1-6-3-使用-keys-和-values" class="headerlink" title="1.6.3 使用 keys() 和 values()"></a>1.6.3 使用 keys() 和 values()</h3><p>keys() 和 values() 分别返回以插入顺序生成键和值的迭代器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">keys</span>()) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, m.<span class="hljs-title function_">get</span>(key));&#125;<span class="hljs-comment">// 1 a</span><span class="hljs-comment">// 2 b</span><span class="hljs-comment">// 3 c</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">values</span>()) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<span class="hljs-comment">// 1 2 3</span>&#125;</code></pre></div><h3 id="1-6-4-迭代时修改键和值"><a href="#1-6-4-迭代时修改键和值" class="headerlink" title="1.6.4 迭代时修改键和值"></a>1.6.4 迭代时修改键和值</h3><p>键和值在迭代器遍历时是可以修改的，但是Map对象内部的引用则<strong>无法修改</strong>。也就是说，迭代时将键修改成另一个值，那么映射内部不会改变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">keys</span>()) &#123;  key = <span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-comment">// b undefined</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;b&quot;</span>)); &#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m); <span class="hljs-comment">// Map(1) &#123; &#x27;a&#x27; =&gt; 1 &#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> objKey = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[objKey, <span class="hljs-string">&quot;val&quot;</span>]]);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);<span class="hljs-comment">// Map(1) &#123; &#123; id: 1 &#125; =&gt; &#x27;val&#x27; &#125;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">keys</span>()) &#123;  key = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-comment">// 这里修改了键的值，但是映射不会发生改变</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, m.<span class="hljs-title function_">get</span>(key));<span class="hljs-comment">// &#123; id: 2 &#125; undefined</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);<span class="hljs-comment">// Map(1) &#123; &#123; id: 1 &#125; =&gt; &#x27;val&#x27; &#125;</span></code></pre></div><p>如果键是对象，迭代时修改了这个对象的属性，对象在映射内部仍然引用相同的<strong>值</strong>（只修改了对象的属性，映射的键没有发生改变）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> objKey = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[objKey, <span class="hljs-string">&quot;val&quot;</span>]]);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);<span class="hljs-comment">// Map(1) &#123; &#123; id: 1 &#125; =&gt; &#x27;val&#x27; &#125;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">keys</span>()) &#123;  key.<span class="hljs-property">id</span> = <span class="hljs-number">2</span>;<span class="hljs-comment">// 修改对象的值，键（该对象）的值没有变化</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, m.<span class="hljs-title function_">get</span>(key));<span class="hljs-comment">// &#123; id: 2 &#125; val</span>&#125;</code></pre></div><h2 id="1-7-选择-Objcet-还是-Map"><a href="#1-7-选择-Objcet-还是-Map" class="headerlink" title="1.7 选择 Objcet 还是 Map"></a>1.7 选择 Objcet 还是 Map</h2><h3 id="1-7-1-内存占用：Map-更少"><a href="#1-7-1-内存占用：Map-更少" class="headerlink" title="1.7.1 内存占用：Map 更少"></a>1.7.1 内存占用：Map 更少</h3><p>给定固定大小的内存，Map 大约可以比 Object 多存储 50 % 的键值对。</p><h3 id="1-7-2-插入性能：Map-更好"><a href="#1-7-2-插入性能：Map-更好" class="headerlink" title="1.7.2 插入性能：Map 更好"></a>1.7.2 插入性能：Map 更好</h3><p>插入 Map 在浏览器中更快</p><h3 id="1-7-3-查找速度：Object-更好"><a href="#1-7-3-查找速度：Object-更好" class="headerlink" title="1.7.3 查找速度：Object 更好"></a>1.7.3 查找速度：Object 更好</h3><p>大型的 Map 和 Object 之间查找速度差异不大。小型的 Object 比小型的 Map 查找速度快。</p><h3 id="1-7-4-删除性能：Map-更好"><a href="#1-7-4-删除性能：Map-更好" class="headerlink" title="1.7.4 删除性能：Map 更好"></a>1.7.4 删除性能：Map 更好</h3><p>涉及大量的删除操作时，应该使用 Map。</p><h1 id="2-Set"><a href="#2-Set" class="headerlink" title="2 Set"></a>2 Set</h1><h2 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h2><p>使用 new 关键字和 Set 构造函数可以创建一个空<strong>集合</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(0) &#123;&#125;</span></code></pre></div><p>创建的时候同时初始化对象，可以传给 Set 构造函数一个<strong>可迭代对象</strong>。</p><p>使用<strong>数组</strong>初始化对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(3) &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125;</span></code></pre></div><p>使用自定义<strong>可迭代对象</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(&#123;  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span>* () &#123;    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;  &#125;,&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(3) &#123; 1, 2, 3 &#125;</span></code></pre></div><h2 id="2-2-add-添加"><a href="#2-2-add-添加" class="headerlink" title="2.2 add() 添加"></a>2.2 add() 添加</h2><p>初始化之后使用 add() 方法添加值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();s.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(1) &#123; &#x27;a&#x27; &#125;</span></code></pre></div><p>add() 返回集合的实例，所以可以将多个操作连在一起，包括初始化。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(3) &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125;</span></code></pre></div><h2 id="2-3-has-方法、size-属性"><a href="#2-3-has-方法、size-属性" class="headerlink" title="2.3 has() 方法、size 属性"></a>2.3 has() 方法、size 属性</h2><p>使用 has() 查询集合中是否有某个值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;a&quot;</span>));<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;d&quot;</span>));<span class="hljs-comment">// false</span></code></pre></div><p>size 属性中存放集合中值的数量。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-property">size</span>);<span class="hljs-comment">// 3</span></code></pre></div><h2 id="2-4-删除"><a href="#2-4-删除" class="headerlink" title="2.4 删除"></a>2.4 删除</h2><h3 id="2-4-1-delete-删除单个值"><a href="#2-4-1-delete-删除单个值" class="headerlink" title="2.4.1 delete() 删除单个值"></a>2.4.1 delete() 删除单个值</h3><p>使用 delete() 可以删除单个元素。delete() 返回一个布尔值，表示是否删除成功。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;a&quot;</span>)); <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);             <span class="hljs-comment">// Set(2) &#123; &#x27;b&#x27;, &#x27;c&#x27; &#125;</span></code></pre></div><h3 id="2-4-2-clear-清空集合"><a href="#2-4-2-clear-清空集合" class="headerlink" title="2.4.2 clear() 清空集合"></a>2.4.2 clear() 清空集合</h3><p>使用 clear() 可以清空集合。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);s.<span class="hljs-title function_">clear</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(0) &#123;&#125;</span></code></pre></div><h2 id="2-5-使用任意类型作为值"><a href="#2-5-使用任意类型作为值" class="headerlink" title="2.5 使用任意类型作为值"></a>2.5 使用任意类型作为值</h2><p>Set 可以使用<strong>任何数据类型</strong>作为值。集合内部使用类似严格相等的标准（SameValueZero）检查值的匹配性。</p><h2 id="2-6-顺序和迭代"><a href="#2-6-顺序和迭代" class="headerlink" title="2.6 顺序和迭代"></a>2.6 顺序和迭代</h2><p>Set 会维护插入时的顺序，因此支持顺序迭代。</p><h3 id="2-6-0-for-of-使用默认迭代器"><a href="#2-6-0-for-of-使用默认迭代器" class="headerlink" title="2.6.0 for-of 使用默认迭代器"></a>2.6.0 for-of 使用默认迭代器</h3><p>Set 定义了默认迭代器，支持顺序迭代。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> set) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<span class="hljs-comment">// a b c</span>&#125;</code></pre></div><h3 id="2-6-1-使用-values-或-keys"><a href="#2-6-1-使用-values-或-keys" class="headerlink" title="2.6.1 使用 values() 或 keys()"></a>2.6.1 使用 values() 或 keys()</h3><p>集合实例提供一个迭代器，能以插入顺序生成集合内容。可以通过 values() 方法及其别名 keys() 取得这个迭代器。也可以通过 Symbol.iterator 属性取得。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-property">values</span> === s.<span class="hljs-property">keys</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-property">values</span> === s[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]);<span class="hljs-comment">// true</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s.<span class="hljs-title function_">values</span>()) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// a b c</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// a b c</span>&#125;</code></pre></div><p>因为 values() 是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转为数组：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...s]);    <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></code></pre></div><h3 id="2-6-2-使用-forEach"><a href="#2-6-2-使用-forEach" class="headerlink" title="2.6.2 使用 forEach()"></a>2.6.2 使用 forEach()</h3><p>可以调用集合的 forEach() 方法并传入回调，依次迭代每一个键值对。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);s.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, dupVal</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val, dupVal));<span class="hljs-comment">// a a</span><span class="hljs-comment">// b b</span><span class="hljs-comment">// c c</span></code></pre></div><p>传入的回调可选的接收第二个值，用于重写回调内部的 this 值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;c&quot;</span>);s.<span class="hljs-title function_">forEach</span>(  <span class="hljs-keyword">function</span> (<span class="hljs-params">val, dupVal</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val, dupVal, <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);  &#125;,  &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;);<span class="hljs-comment">// a a 1</span><span class="hljs-comment">// b b 1</span><span class="hljs-comment">// c c 1</span></code></pre></div><h3 id="2-6-3-迭代时修改集合中的值"><a href="#2-6-3-迭代时修改集合中的值" class="headerlink" title="2.6.3 迭代时修改集合中的值"></a>2.6.3 迭代时修改集合中的值</h3><p>修改集合中的值的属性不会影响到作为集合值的身份。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;a&quot;</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> s.<span class="hljs-title function_">values</span>()) &#123;  value = <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value, s.<span class="hljs-title function_">has</span>(value));<span class="hljs-comment">// b false</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(1) &#123; &#x27;a&#x27; &#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([obj]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> s.<span class="hljs-title function_">values</span>()) &#123;  val.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(1) &#123; &#123; a: 2 &#125; &#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([obj]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> s.<span class="hljs-title function_">values</span>()) &#123;  val = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Set(1) &#123; &#123; a: 1 &#125; &#125;</span></code></pre></div><h1 id="3-迭代和扩展"><a href="#3-迭代和扩展" class="headerlink" title="3 迭代和扩展"></a>3 迭代和扩展</h1><p>ECMAScript 6 中新增的迭代器和<strong>扩展操作符</strong>对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得简单。</p><p>Array、Map、Set 定义了默认迭代器。这意味着所有类型都支持顺序迭代，都可以使用 for-of 循环。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<span class="hljs-comment">// 1 2 3</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([  [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>],  [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>],]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> map) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val, val[<span class="hljs-number">0</span>], val[<span class="hljs-number">1</span>]);&#125;<span class="hljs-comment">// [ &#x27;a&#x27;, 1 ] a 1</span><span class="hljs-comment">// [ &#x27;b&#x27;, 2 ] b 2</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> map) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k, v);&#125;<span class="hljs-comment">// a 1</span><span class="hljs-comment">// b 2</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> set) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<span class="hljs-comment">// a b c</span>&#125;</code></pre></div><p>这也意味着这些类型都兼容<strong>扩展操作符</strong>。扩展操作符在对可迭代对象执行<strong>浅复制</strong>时特别有用。只需要简单的语法就可以复制整个对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">const</span> arr2 = [...arr1];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1);<span class="hljs-comment">// [ 1, 2, 3 ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<span class="hljs-comment">// [ 1, 2, 3 ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1 === arr2);<span class="hljs-comment">// false</span></code></pre></div><p>对于期待<strong>可迭代对象</strong>的构造函数，只需要传入一个可迭代对象就可以实现复制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(map1);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map1);<span class="hljs-comment">// Map(2) &#123; &#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2 &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map2);<span class="hljs-comment">// Map(2) &#123; &#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2 &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map1 === map2);<span class="hljs-comment">// false</span></code></pre></div><p>注意：浅复制意味着只复制对象<strong>引用</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [&#123;&#125;];<span class="hljs-keyword">const</span> arr2 = [...arr1];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1);<span class="hljs-comment">// [ &#123;&#125; ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<span class="hljs-comment">// [ &#123;&#125; ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1 === arr2); <span class="hljs-comment">// false</span>arr1[<span class="hljs-number">0</span>].<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1);<span class="hljs-comment">// [ &#123; a: 1 &#125; ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<span class="hljs-comment">// [ &#123; a: 1 &#125; ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1 === arr2);<span class="hljs-comment">// false</span></code></pre></div><p>Array.of() 和 Array.from() 静态方法，与扩展操作符一起使用，可以方法实现互操作。</p><p>把数组复制到映射：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> [x, x * <span class="hljs-number">2</span>]));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map);   <span class="hljs-comment">// Map(3) &#123; 1 =&gt; 2, 2 =&gt; 4, 3 =&gt; 6 &#125;</span></code></pre></div><p>把数组复制到集合：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set);<span class="hljs-comment">// Set(3) &#123; 1, 2, 3 &#125;</span></code></pre></div><p>把数组复制回数组：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">const</span> arr2 = [...arr1];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<span class="hljs-comment">// [ 1, 2, 3 ]</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】11.集合引用类型-Object、Array</title>
    <link href="/archives/fdf032f9.html"/>
    <url>/archives/fdf032f9.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Object"><a href="#1-Object" class="headerlink" title="1 Object"></a>1 Object</h1><h2 id="1-1-创建-Object-类型实例"><a href="#1-1-创建-Object-类型实例" class="headerlink" title="1.1 创建 Object 类型实例"></a>1.1 创建 Object 类型实例</h2><p>第一种方式，使用 new 操作符和 Object 构造函数：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();obj.<span class="hljs-property">a</span> = <span class="hljs-string">&quot;123&quot;</span>;obj.<span class="hljs-property">b</span> = <span class="hljs-string">&quot;456&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// &#123; a: &#x27;123&#x27;, b: &#x27;456&#x27; &#125;</span></code></pre></div><p>另一种方式是使用<strong>对象字面量</strong>。对象字面量是对象定义的简写形式，简化了包含大量属性的对象的创建。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;123&quot;</span>,  <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;456&quot;</span>,&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// &#123; a: &#x27;123&#x27;, b: &#x27;456&#x27; &#125;</span></code></pre></div><p>在对象字面量表示法中，属性名可以是字符串或者数值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;123&quot;</span>,  <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;456&quot;</span>,  <span class="hljs-number">3</span>: <span class="hljs-string">&quot;789&quot;</span>,&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// &#123; &#x27;3&#x27;: &#x27;789&#x27;, a: &#x27;123&#x27;, b: &#x27;456&#x27; &#125;</span></code></pre></div><p>注意：</p><ol><li>属性名是数值的会自动转换成字符串。</li><li>使用对象字面量表示法定义变量时，实际上并<strong>不会</strong>调用 Object() 构造函数。</li></ol><h2 id="1-2-存取属性"><a href="#1-2-存取属性" class="headerlink" title="1.2 存取属性"></a>1.2 存取属性</h2><p>属性可以通过<strong>点语法</strong>来进行存取，也可以使用<strong>中括号</strong>来存取。使用中括号时，要在括号内使用属性名的字符串形式。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>);<span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-string">&quot;b&quot;</span>]);<span class="hljs-comment">// 2</span></code></pre></div><p>以下情况只能通过中括号来存取属性：</p><ol><li><p>通过<strong>变量</strong>访问属性</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">let</span> prop = <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[prop]);<span class="hljs-comment">// 1</span></code></pre></div></li><li><p>属性名中包含可能导致错误的字符，或者包含关键字&#x2F;保留字</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-string">&quot;prop name&quot;</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-string">&quot;prop name&quot;</span>]);<span class="hljs-comment">// 1</span></code></pre></div></li></ol><p>通常情况下，<strong>点语法</strong>是首选的属性存取方式。</p><h1 id="2-Array"><a href="#2-Array" class="headerlink" title="2 Array"></a>2 Array</h1><p>ECMAScript 中的数组，每个槽位中可以存储任意类型的数据。而且，数组是动态大小的，会随着数据的添加自动增长。</p><h2 id="2-1-创建数组"><a href="#2-1-创建数组" class="headerlink" title="2.1 创建数组"></a>2.1 创建数组</h2><h3 id="2-1-1-使用-Array-构造函数"><a href="#2-1-1-使用-Array-构造函数" class="headerlink" title="2.1.1 使用 Array() 构造函数"></a>2.1.1 使用 Array() 构造函数</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);   <span class="hljs-comment">// []</span></code></pre></div><p>如果知道数组中元素的数量，可以传入一个数值。此时，length 属性就会自动设置为这个值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ &lt;10 empty items&gt; ]</span></code></pre></div><p>也可以传给 Array 构造函数要保存的元素。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);   <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></code></pre></div><p>注意：如果传给 Array 构造函数的是<strong>一个</strong>值时，若这个值是<strong>数值</strong>，则会创建一个长度为指定数值的数组；若这个值是<strong>其它类型</strong>的，则会创建一个只包含这个值的数组。</p><p>使用 Array 构造函数时，也可以省略 new 操作符。结果是一样的。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></code></pre></div><h3 id="2-1-2-使用数组字面量"><a href="#2-1-2-使用数组字面量" class="headerlink" title="2.1.2 使用数组字面量"></a>2.1.2 使用数组字面量</h3><p><strong>数组字面量</strong>是在中括号中包含以逗号分割的元素列表。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];</code></pre></div><p>注意：使用数组字面量创建数组时，不会调用 Array 构造函数。</p><h3 id="2-1-3-Array-from-将类数组数据结构转为数组实例"><a href="#2-1-3-Array-from-将类数组数据结构转为数组实例" class="headerlink" title="2.1.3 Array.from() 将类数组数据结构转为数组实例"></a>2.1.3 Array.from() 将类数组数据结构转为数组实例</h3><p>Array.from() 是 ES6 新增的用于创建数组的静态方法，用于将<strong>类数组</strong>对象转为数组实例。</p><p>Array.from() 的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的数据结构。</p><ol><li><p>将字符串拆分为单字符数组</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></code></pre></div></li><li><p>将映map和set转换为数组</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);     <span class="hljs-comment">// Map(2) &#123; 1 =&gt; 2, 3 =&gt; 4 &#125;</span><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(m);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);   <span class="hljs-comment">//[ [ 1, 2 ], [ 3, 4 ] ]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);     <span class="hljs-comment">// Set(3) &#123; 1, 2, 3 &#125;</span><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(s);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);   <span class="hljs-comment">// [ 1, 2, 3 ]</span></code></pre></div></li><li><p>对现有数组进行<strong>浅复制</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-keyword">const</span> a2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(a1);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2);    <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1 === a2);     <span class="hljs-comment">// false</span></code></pre></div></li><li><p>将 arguments 对象转为数组</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<span class="hljs-comment">// [ 1, 2, 3, 4 ]</span></code></pre></div></li><li><p>可以将任何可迭代对象转为数组</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iter = &#123;  *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;  &#125;,&#125;;<span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(iter);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 1, 2, 3 ]</span></code></pre></div></li><li><p>可以将带有<em>必要属性</em>的自定义对象转为数组</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arrLikeObj = &#123;  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;a&quot;</span>,  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;b&quot;</span>,  <span class="hljs-number">2</span>: <span class="hljs-string">&quot;c&quot;</span>,  <span class="hljs-number">3</span>: <span class="hljs-string">&quot;d&quot;</span>,  <span class="hljs-attr">length</span>: <span class="hljs-number">4</span>,&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrLikeObj));    <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></code></pre></div></li></ol><p>Array.form() 还可以接收第二个可选的映射函数参数，这个函数可以增强新数组的值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">const</span> a2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(a1, <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * <span class="hljs-number">2</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2);    <span class="hljs-comment">// [ 2, 4, 6, 8 ]</span></code></pre></div><p>Array.from() 还可以接收第三个可选的参数，用于指定映射函数中 this 的值。但是这个重写的 this 值不适用于箭头函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">const</span> a2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(  a1,  <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;    <span class="hljs-keyword">return</span> x * <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>;  &#125;,  &#123; <span class="hljs-attr">num</span>: <span class="hljs-number">2</span> &#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2); <span class="hljs-comment">// [ 2, 4, 6, 8 ]</span></code></pre></div><h3 id="2-1-4-Array-of-将一组参数转为数组"><a href="#2-1-4-Array-of-将一组参数转为数组" class="headerlink" title="2.1.4 Array.of() 将一组参数转为数组"></a>2.1.4 Array.of() 将一组参数转为数组</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 1, 2, 3 ]</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(...<span class="hljs-variable language_">arguments</span>);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<span class="hljs-comment">// [ 1, 2, 3, 4 ]</span></code></pre></div><h2 id="2-2-数组空位"><a href="#2-2-数组空位" class="headerlink" title="2.2 数组空位"></a>2.2 数组空位</h2><p>使用数组字面量初始化数组时，可以使用一串逗号来创建空位。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, , , , <span class="hljs-number">5</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 1, &lt;3 empty items&gt;, 5 ]</span></code></pre></div><p>ES6 新增的方法普遍将这些空位当成存在的元素，只不过值为 undefined。</p><p>ES6 之前的方法会忽略这个空位，具体的行为因方法而异。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, , , , <span class="hljs-number">5</span>];<span class="hljs-comment">// map() 会跳过空位置</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-number">0</span>));  <span class="hljs-comment">// [ 0, &lt;3 empty items&gt;, 0 ]</span><span class="hljs-comment">// map() 将空位置视为空串</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;-&quot;</span>));     <span class="hljs-comment">// 1----5</span></code></pre></div><p>注意：因为行为的不一致存在隐患，因此实践中应避免使用数组空位。或者使用 undefined 去代替数组空位。</p><h2 id="2-3-数组索引"><a href="#2-3-数组索引" class="headerlink" title="2.3 数组索引"></a>2.3 数组索引</h2><p>使用中括号并提供值的索引来存取数组值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">1</span>]);    <span class="hljs-comment">// b</span></code></pre></div><p>如果设置值时，中括号中给出的索引值超出了数组目前的最大索引值，那么数组会自动扩展到该索引值+1的长度。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>);    <span class="hljs-comment">// 3</span>arr[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;e&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);           <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &lt;1 empty item&gt;, &#x27;e&#x27; ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>);    <span class="hljs-comment">// 5</span></code></pre></div><p>数组中元素的数量保存在 length 属性中，这个属性始终返回大于等于0的值。length 属性不是只读的，可以通过修改 length 的值达到增删数组元素的目的。</p><h2 id="2-4-检测数组"><a href="#2-4-检测数组" class="headerlink" title="2.4 检测数组"></a>2.4 检测数组</h2><h3 id="2-4-1-instanceof-操作符"><a href="#2-4-1-instanceof-操作符" class="headerlink" title="2.4.1 instanceof 操作符"></a>2.4.1 instanceof 操作符</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">if</span> (arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span>);    <span class="hljs-comment">// true</span>&#125;</code></pre></div><p>在只有一个网页（因而只有一个全局作用域）的情况下足以。</p><h3 id="2-4-2-Array-isArray-检测对象是不是数组"><a href="#2-4-2-Array-isArray-检测对象是不是数组" class="headerlink" title="2.4.2 Array.isArray() 检测对象是不是数组"></a>2.4.2 Array.isArray() 检测对象是不是数组</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span>&#125;</code></pre></div><p>如果网页中有多个框架（因而有多个不同的全局上下文），需要使用 Array.isArray()。</p><h2 id="2-5-迭代器方法"><a href="#2-5-迭代器方法" class="headerlink" title="2.5 迭代器方法"></a>2.5 迭代器方法</h2><h3 id="2-5-1-keys-返回数组索引的迭代器"><a href="#2-5-1-keys-返回数组索引的迭代器" class="headerlink" title="2.5.1 keys() 返回数组索引的迭代器"></a>2.5.1 keys() 返回数组索引的迭代器</h3><p>keys() 返回<strong>数组索引</strong>的迭代器。因为返回的是迭代器，所以可以使用 Array.from() 方法将其转换成数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-keyword">const</span> iter = arr.<span class="hljs-title function_">keys</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter);  <span class="hljs-comment">// Object [Array Iterator] &#123;&#125;</span><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr.<span class="hljs-title function_">keys</span>());<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);<span class="hljs-comment">// [ 0, 1, 2 ]</span></code></pre></div><h3 id="2-5-2-values-返回数组元素的迭代器"><a href="#2-5-2-values-返回数组元素的迭代器" class="headerlink" title="2.5.2 values() 返回数组元素的迭代器"></a>2.5.2 values() 返回数组元素的迭代器</h3><p>values() 返回<strong>数组元素</strong>的迭代器。因为返回的是迭代器，所以可以使用 Array.from() 方法将其转换成数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-keyword">const</span> iter = arr.<span class="hljs-title function_">values</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter);<span class="hljs-comment">// Object [Array Iterator] &#123;&#125;</span><span class="hljs-keyword">const</span> values = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr.<span class="hljs-title function_">values</span>());<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></code></pre></div><h3 id="2-5-3-entries-返回数组键值对的迭代器"><a href="#2-5-3-entries-返回数组键值对的迭代器" class="headerlink" title="2.5.3 entries() 返回数组键值对的迭代器"></a>2.5.3 entries() 返回数组键值对的迭代器</h3><p>entries() 返回<strong>键值对</strong>的迭代器。因为返回的是迭代器，所以可以使用 Array.from() 方法将其转换成数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-keyword">const</span> iter = arr.<span class="hljs-title function_">entries</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter);<span class="hljs-comment">// Object [Array Iterator] &#123;&#125;</span><span class="hljs-keyword">const</span> entries = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr.<span class="hljs-title function_">entries</span>());<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entries);<span class="hljs-comment">// [ [ 0, &#x27;a&#x27; ], [ 1, &#x27;b&#x27; ], [ 2, &#x27;c&#x27; ] ]</span></code></pre></div><p>使用 ES6 的<strong>解构</strong>，可以非常容易地在循环中拆分键值对。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> arr.<span class="hljs-title function_">entries</span>()) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k, v);&#125;<span class="hljs-comment">// 0 a</span><span class="hljs-comment">// 1 b</span><span class="hljs-comment">// 2 c</span></code></pre></div><h2 id="2-6-复制和填充方法"><a href="#2-6-复制和填充方法" class="headerlink" title="2.6 复制和填充方法"></a>2.6 复制和填充方法</h2><h3 id="2-6-1-fill-批量复制元素"><a href="#2-6-1-fill-批量复制元素" class="headerlink" title="2.6.1 fill() 批量复制元素"></a>2.6.1 fill() 批量复制元素</h3><p>使用 fill() 方法向一个已有数组中插入全部或者部分相同的值。这个方法会<strong>改变原数组</strong>。</p><p>如果只提供一个参数，那个这个参数会被视为填充的元素。fill() 数组全部元素将这个参数进行填充。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 6, 6, 6, 6, 6 ]</span></code></pre></div><p>如果提供两个参数，那么第二个参数会被视为开始索引。fill() 数组会从开始索引开始填充。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>,<span class="hljs-number">1</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 0, 6, 6, 6, 6 ]</span></code></pre></div><p>如果提供三个参数，那么第三个参数会被视为结束索引。fill() 数组会从开始索引填充到结束索引（含头不含尾）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 0, 6, 6, 0, 0 ]</span></code></pre></div><p>注意：</p><ol><li><p>负索引从数组末尾开始计算。</p></li><li><p>fill() 会<strong>静默忽略</strong>超出数组边界，零长度和方向相反的索引范围。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<span class="hljs-comment">// 索引过低，忽略</span>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>, -<span class="hljs-number">10</span>, -<span class="hljs-number">6</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);   <span class="hljs-comment">// [ 0, 0, 0, 0, 0 ]</span><span class="hljs-comment">// 索引过高，忽略</span>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 0, 0, 0, 0, 0 ]</span><span class="hljs-comment">// 索引反向，忽略</span>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 0, 0, 0, 0, 0 ]</span><span class="hljs-comment">// 索引部分可用，填充可用部分</span>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 0, 0, 6, 6, 6 ]</span></code></pre></div></li></ol><h3 id="2-6-2-copyWithin-填充数组"><a href="#2-6-2-copyWithin-填充数组" class="headerlink" title="2.6.2 copyWithin() 填充数组"></a>2.6.2 copyWithin() 填充数组</h3><p>copyWithin() 会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。这个方法会<strong>改变原数组</strong>。</p><p>如果只提供一个参数，那么这个参数被视为插入的开始索引。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// copyWithin() 会复制索引0开始的内容，并将它们依次插入到索引4开始的位置。</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];arr.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">4</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [0, 1, 2, 3, 0, 1, 2, 3, 4, 5]</span></code></pre></div><p>如果提供两个参数，那么第二个参数被视为开始复制的索引。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// copyWithin() 会复制索引2开始的内容，并将它们依次插入到索引2开始的位置。</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];arr.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [0, 1, 2, 3, 2, 3, 4, 5, 6, 7]</span></code></pre></div><p>如果提供三个参数，那么第三个参数被视为结束复制的索引。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// copyWithin() 会复制索引2开始的内容，并将它们依次插入到索引2开始到索引5结束的位置。</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];arr.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [0, 1, 2, 3, 4, 5, 2, 3, 4, 9]</span></code></pre></div><p>注意：</p><ol><li>支持负索引，负索引相当于从末尾开始计算。</li><li>copyWithin() 会<strong>静默忽略</strong>超出数组边界，零长度和方向相反的索引范围。</li></ol><h2 id="2-7-转换方法"><a href="#2-7-转换方法" class="headerlink" title="2.7 转换方法"></a>2.7 转换方法</h2><h3 id="2-7-1-valueOf-、toString-、toLocaleString"><a href="#2-7-1-valueOf-、toString-、toLocaleString" class="headerlink" title="2.7.1 valueOf() 、toString() 、toLocaleString()"></a>2.7.1 valueOf() 、toString() 、toLocaleString()</h3><p>valueOf() 返回的还是数组本身。toString() 返回的是由数组中每个值的等效字符串用逗号拼接而成的字符串，也就是说对每个元素调用 toString() 得到的字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ] object</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">valueOf</span>(), <span class="hljs-keyword">typeof</span> arr.<span class="hljs-title function_">valueOf</span>());<span class="hljs-comment">// a,b,c string</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">toString</span>(), <span class="hljs-keyword">typeof</span> arr.<span class="hljs-title function_">toString</span>());</code></pre></div><p>数组的 toLocaleString() 方法，对每个元素调用 toLocaleString()。</p><p>注意：如果数组中的元素是undefined、null，则在 valueOf() 、toString() 、toLocaleString() 的返回结果中以<strong>空串</strong>表示。</p><h3 id="2-7-2-join-拼接成字符串"><a href="#2-7-2-join-拼接成字符串" class="headerlink" title="2.7.2 join() 拼接成字符串"></a>2.7.2 join() 拼接成字符串</h3><p>toString() 和 toLocaleString() 都返回数组值逗号分割的字符串，想用其它字符串分割可以使用 join() 方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;-&quot;</span>));<span class="hljs-comment">// a-b-c</span></code></pre></div><p>注意：如果不给 join() 传参数或者传 undefined，那么还是以逗号作为分隔符。</p><h2 id="2-8-栈方法"><a href="#2-8-栈方法" class="headerlink" title="2.8 栈方法"></a>2.8 栈方法</h2><p>使用 push() 和 pop() 可以在数组末尾增删元素，从而模拟栈。</p><h3 id="2-8-1-push-数组尾部添加元素"><a href="#2-8-1-push-数组尾部添加元素" class="headerlink" title="2.8.1 push() 数组尾部添加元素"></a>2.8.1 push() 数组尾部添加元素</h3><p>接收任意数量的参数，并将它们添加到末尾，返回数组最新的长度。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>));<span class="hljs-comment">// 4</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></code></pre></div><h3 id="2-8-2-pop-数组尾部删除元素"><a href="#2-8-2-pop-数组尾部删除元素" class="headerlink" title="2.8.2 pop() 数组尾部删除元素"></a>2.8.2 pop() 数组尾部删除元素</h3><p>删除数组的最后一项，同时 length -1 ，返回被删除的项。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">pop</span>());<span class="hljs-comment">// c </span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></code></pre></div><h2 id="2-9-队列方法"><a href="#2-9-队列方法" class="headerlink" title="2.9 队列方法"></a>2.9 队列方法</h2><p>shift() 可以在删除数组的开头的元素。使用 push() 模拟入队，使用 shift() 模拟出队。 </p><p>unshift() 可以在数组的开头添加值。使用 unshift() 和 pop() 可以在数组的反向上模拟队列。</p><h3 id="2-9-1-shift-数组头部删除元素"><a href="#2-9-1-shift-数组头部删除元素" class="headerlink" title="2.9.1 shift() 数组头部删除元素"></a>2.9.1 shift() 数组头部删除元素</h3><p>shift() 会删除数组的第一项，同时  length -1，返回被删除的项。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">shift</span>());<span class="hljs-comment">// a</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ &#x27;b&#x27;, &#x27;c&#x27; ]</span></code></pre></div><h3 id="2-9-2-unshift-数组头部添加元素"><a href="#2-9-2-unshift-数组头部添加元素" class="headerlink" title="2.9.2 unshift() 数组头部添加元素"></a>2.9.2 unshift() 数组头部添加元素</h3><p>unshift() 可以在数组的开头添加任意数量的值（并非依次插入，而是一次性按顺序全部插入），返回数组最新的长度。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>));<span class="hljs-comment">// 6</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></code></pre></div><h2 id="2-10-反向和排序方法"><a href="#2-10-反向和排序方法" class="headerlink" title="2.10 反向和排序方法"></a>2.10 反向和排序方法</h2><h3 id="2-10-1-reverse-数组反向"><a href="#2-10-1-reverse-数组反向" class="headerlink" title="2.10.1 reverse() 数组反向"></a>2.10.1 reverse() 数组反向</h3><p>reverse() 可以将数组进行反向排列。该方法会<strong>改变原数组</strong>，并返回<strong>新</strong>数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">reverse</span>());<span class="hljs-comment">// [ 4, 3, 2, 1 ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">// [ 4, 3, 2, 1 ]</span></code></pre></div><h3 id="2-10-2-sort-数组排序"><a href="#2-10-2-sort-数组排序" class="headerlink" title="2.10.2 sort() 数组排序"></a>2.10.2 sort() 数组排序</h3><p>默认情况下，sort() 会按照升序重新排序数组。为此，sort() 会在每一项上调用 String() 转型函数，然后比较字符串来决定顺序。即使数组中的每一项都是数字，还是会将每一项转成字符串来进行比较、排序。该方法会<strong>改变原数组</strong>，并返回<strong>新</strong>数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">sort</span>());<span class="hljs-comment">// [ 1, 20, 3, 4 ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 1, 20, 3, 4 ]</span></code></pre></div><p>字符串”20”排在字符串”3”前面，所以结果看起来是不合适的。为此，sort() 方法可以接收一个<strong>比较函数</strong>，用于判断哪个值应在排在前面。</p><p><strong>比较函数</strong>接收两个参数，如果第一个参数应该排在第二个参数的<strong>前面</strong>，就返回<strong>负值</strong>；如果第一个参数应该排在第二个参数的后面，就返回正值；如果两个参数相等，就返回0。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 升序时，传入的比较函数  a-b 返回-1</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a &lt; b) &#123;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &gt; b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>];arr.<span class="hljs-title function_">sort</span>(compare);<span class="hljs-comment">// 升序排序</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);   <span class="hljs-comment">// [ 1, 2, 3, 4 ]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 降序时，传入的比较函数a-b 返回1</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a &lt; b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &gt; b) &#123;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];arr.<span class="hljs-title function_">sort</span>(compare);<span class="hljs-comment">// 降序排序</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 4, 3, 3, 2, 1 ]</span></code></pre></div><p>此外，比较函数还可以简写成一个<strong>箭头函数</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (a &lt; b ? -<span class="hljs-number">1</span> : a &gt; b ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);</code></pre></div><p>如果数组的元素是<strong>数值</strong>，或者其 valueOf() 方法返回数值的对象（如 Date 对象）。这个比较函数可以直接用两个参数相减。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-comment">// 升序</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);  <span class="hljs-comment">// [ 1, 2, 3, 3, 4 ]</span>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);<span class="hljs-comment">// 降序</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);   <span class="hljs-comment">// [ 4, 3, 3, 2, 1 ]</span></code></pre></div><h2 id="2-11-拼接和截取"><a href="#2-11-拼接和截取" class="headerlink" title="2.11 拼接和截取"></a>2.11 拼接和截取</h2><h3 id="2-11-1-concat-数组拼接"><a href="#2-11-1-concat-数组拼接" class="headerlink" title="2.11.1 concat() 数组拼接"></a>2.11.1 concat() 数组拼接</h3><p>concat() 会创建当前数组的一个副本，然后把它的参数添加到副本末尾，最后返回一个<strong>新数组</strong>。如果传入的是一个或多个<strong>数组</strong>，则 concat() 会把数组的每一项都添加到数组中（如果参数是数组，默认打平数组）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">let</span> a = a1.<span class="hljs-title function_">concat</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">let</span> a2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-keyword">let</span> a = a1.<span class="hljs-title function_">concat</span>(a2);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// [ 1, 2, 3, 4, 5, 6 ]</span></code></pre></div><p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：<code>Symbol.isConcatSpreadable</code>。这个符号能<strong>阻止</strong> concat() 打平参数数组。相反，这个值设置为 true 可以强制打平<strong>类数组对象</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">let</span> a2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];a2[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 强制不打平数组</span><span class="hljs-keyword">let</span> a3 = &#123;<span class="hljs-comment">// 类数组对象</span>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>]: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 强制打平数组</span>  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>,  <span class="hljs-number">0</span>: <span class="hljs-number">7</span>,  <span class="hljs-number">1</span>: <span class="hljs-number">8</span>,&#125;;<span class="hljs-keyword">let</span> arr1 = a1.<span class="hljs-title function_">concat</span>(a2);<span class="hljs-keyword">let</span> arr2 = a1.<span class="hljs-title function_">concat</span>(a3);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1);<span class="hljs-comment">// [ 1, 2, 3, [ 4, 5, 6 ] ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<span class="hljs-comment">// [1, 2, 3, 7, 8]</span></code></pre></div><h3 id="2-11-2-slice-数组截取"><a href="#2-11-2-slice-数组截取" class="headerlink" title="2.11.2 slice() 数组截取"></a>2.11.2 slice() 数组截取</h3><p>slice() 用于创建一个含有原有数组中一个或多个元素的<strong>新数组</strong>。</p><p>slice() 方法可以接收一个或者两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 slice() 会返回该索引到数组末尾的所有元素。如果有两个参数，则 slice() 返回从开始索引到结束索引对应的元素（含头不含尾）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// [ 3, 4 ]</span></code></pre></div><p>注意：如果 slice() 的参数有负值，那就数组长度加上这个负值来确定位置。</p><h3 id="2-11-3-splice-数组删除、插入、替换"><a href="#2-11-3-splice-数组删除、插入、替换" class="headerlink" title="2.11.3 splice() 数组删除、插入、替换"></a>2.11.3 splice() 数组删除、插入、替换</h3><p>splice() 主要目的是在数组中插入元素，但有三种不用的方法使用。splice() 始终<strong>返回</strong>这样的数组：它包含数组中被删除的元素（如果没有删除元素，则返回空数组）。splice() 会<strong>改变原数组</strong>。</p><p><strong>删除</strong></p><p>给 splice() 传 2 个参数：要删除的第一个元素位置、要删除的元素数量。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// [ 2, 3 ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);               <span class="hljs-comment">// [ 1, 4 ]</span></code></pre></div><p> <strong>插入</strong></p><p>给 splice() 传 3 个参数：开始位置、0（即要删除的元素数量）、要插入的元素。也可传递第4、5、6 ··· 个参数，表示要插入多个元素。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>));    <span class="hljs-comment">// []</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);           <span class="hljs-comment">// [ 1, &#x27;a&#x27;, &#x27;b&#x27;, 2, 3, 4 ]</span></code></pre></div><p><strong>替换</strong></p><p>splice() 在删除元素的同时在指定位置插入新的元素。给 splice() 传 3 个参数：开始位置、要删除的元素数量、要插入的元素。也可传递第4、5、6 ··· 个参数，表示要插入多个元素。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>)); <span class="hljs-comment">// [ 2 ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);       <span class="hljs-comment">// [ 1, &#x27;a&#x27;, &#x27;b&#x27;, 3, 4 ]</span></code></pre></div><h2 id="2-12-搜索和位置方法"><a href="#2-12-搜索和位置方法" class="headerlink" title="2.12 搜索和位置方法"></a>2.12 搜索和位置方法</h2><h3 id="2-12-1-indexOf-、lastIndexOf-严格搜索"><a href="#2-12-1-indexOf-、lastIndexOf-严格搜索" class="headerlink" title="2.12.1 indexOf()、lastIndexOf() 严格搜索"></a>2.12.1 indexOf()、lastIndexOf() 严格搜索</h3><p>indexOf()、lastIndexOf() 接收两个参数，要查找的元素和一个可选的起始搜索位置。返回第一个找到元素的下标。</p><p>indexOf() 从数组开头开始向后搜索，lastIndexOf() 从数组的末尾向前搜索。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// -1</span></code></pre></div><p>找不到则返回-1。</p><h3 id="2-12-2-includes-严格搜索"><a href="#2-12-2-includes-严格搜索" class="headerlink" title="2.12.2 includes() 严格搜索"></a>2.12.2 includes() 严格搜索</h3><p>includes() 返回布尔值，表示是否至少找到一个和指定元素匹配的项。返回布尔值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>));   <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">4</span>));   <span class="hljs-comment">// false</span></code></pre></div><h3 id="2-12-3-find-、findLast-和-findIndex-、findLastIndex-断言搜索"><a href="#2-12-3-find-、findLast-和-findIndex-、findLastIndex-断言搜索" class="headerlink" title="2.12.3 find() 、findLast()和 findIndex() 、findLastIndex() 断言搜索"></a>2.12.3 find() 、findLast()和 findIndex() 、findLastIndex() 断言搜索</h3><p>ECMAScript 也允许按照定义的<strong>断言函数</strong>搜索数组。每个索引都会调用这个函数，断言函数的返回值决定了相应索引的元素是否被认为匹配。</p><blockquote><p><strong>断言函数</strong>接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，数组即正在搜索的数组。断言函数返回真值，表示是否匹配。</p></blockquote><p>find() 和 findIndex() 使用了断言函数，都从数组的最小索引开始。find() 返回第一个匹配的<strong>元素</strong>，findIndex() 返回第一个匹配元素的<strong>索引</strong>。这两个方法也都接收第二个可选的参数，用于指定断言函数内部的 this 值。</p><p>findLast() 和 findLastIndex() 和前面两个方法相似，但是返回最后一个匹配的元素和索引。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [  &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;,  &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">12</span> &#125;,  &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">23</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">22</span> &#125;,];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">element, index, array</span>) =&gt;</span> element.<span class="hljs-property">a</span> % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>));<span class="hljs-comment">// &#123; a: 3, b: 2 &#125;</span></code></pre></div><p>注意：</p><ol><li>找不到时，find() 返回 undefined，findIndex() 返回-1。</li><li>找到匹配项后，这两个方法都不再继续搜索。</li></ol><h2 id="2-13-迭代方法"><a href="#2-13-迭代方法" class="headerlink" title="2.13 迭代方法"></a>2.13 迭代方法</h2><p>ECMAScript 有5个数组迭代方法，每个方法接收两个参数：以每一项为参数运行的函数、以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收3个参数：数组元素、数组索引和数组本身。</p><h3 id="2-13-1-forEach"><a href="#2-13-1-forEach" class="headerlink" title="2.13.1 forEach()"></a>2.13.1 forEach()</h3><p>对数组每一项都运行传入的函数，没有返回值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element, index, array</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element));<span class="hljs-comment">// 1 3 2 4 5</span></code></pre></div><h3 id="2-13-2-filter"><a href="#2-13-2-filter" class="headerlink" title="2.13.2 filter()"></a>2.13.2 filter()</h3><p>对数组每一项都运行传入的函数，函数返回 true 的<strong>元素</strong>会组成数组之后返回。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">const</span> res = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">element, index, array</span>) =&gt;</span> element &lt; <span class="hljs-number">4</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// [ 1, 3, 2 ]</span></code></pre></div><h3 id="2-13-3-map"><a href="#2-13-3-map" class="headerlink" title="2.13.3 map()"></a>2.13.3 map()</h3><p>对数组每一项都运行传入的函数，返回由每次函数调用的<strong>结果</strong>构成的数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">const</span> res = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">element, index, array</span>) =&gt;</span> element &lt; <span class="hljs-number">4</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">// [ true, true, true, false, false ]</span></code></pre></div><p>注：还有一个 flatMap() 方法，类似于 flat(1) + map()，效率更高。 </p><h3 id="2-13-4-every"><a href="#2-13-4-every" class="headerlink" title="2.13.4 every()"></a>2.13.4 every()</h3><p>对数组每一项都运行传入的函数，如果<strong>每一项</strong>都返回 true，则这个方法返回 true。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">const</span> res = arr.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">element, index, array</span>) =&gt;</span> element &lt; <span class="hljs-number">4</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);   <span class="hljs-comment">// false</span></code></pre></div><h3 id="2-13-5-some"><a href="#2-13-5-some" class="headerlink" title="2.13.5 some()"></a>2.13.5 some()</h3><p>对数组的每一项都运行传入的函数，如果<strong>有一项</strong>函数返回 true，则这个方法返回 true。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">const</span> res = arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">element, index, array</span>) =&gt;</span> element &lt; <span class="hljs-number">4</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// true</span></code></pre></div><h2 id="2-14-归并方法"><a href="#2-14-归并方法" class="headerlink" title="2.14 归并方法"></a>2.14 归并方法</h2><h3 id="2-14-1-reduce"><a href="#2-14-1-reduce" class="headerlink" title="2.14.1 reduce()"></a>2.14.1 reduce()</h3><p>reduce() 方法从数组第一项开始遍历到最后一项。reduce() 函数接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。</p><p>传给 reduce() 的函数接收 4 个参数：上一个归并值、当前项、当前项的索引值和数组本身。这个函数返回的任何值都会作为下次调用同一个函数的第一个参数。如果没有给方法传入第二个参数（作为归并的起点值），则第一次迭代从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">let</span> sum = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur, index, array</span>) =&gt;</span> prev + cur);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);   <span class="hljs-comment">// 10</span></code></pre></div><p>可以提供一个初始值作为 reduce() 函数的初始值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">let</span> sum = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur, index, array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> prev + cur;&#125;, <span class="hljs-number">20</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<span class="hljs-comment">// 30</span></code></pre></div><h3 id="2-14-2-reduceRight"><a href="#2-14-2-reduceRight" class="headerlink" title="2.14.2 reduceRight()"></a>2.14.2 reduceRight()</h3><p>与 reduce() 之间的唯一区别是，reduceRight() 从最后一项开始遍历到第一项。</p><h2 id="2-15-扁平化方法"><a href="#2-15-扁平化方法" class="headerlink" title="2.15 扁平化方法"></a>2.15 扁平化方法</h2><h3 id="2-15-1-flat-扁平化"><a href="#2-15-1-flat-扁平化" class="headerlink" title="2.15.1 flat() 扁平化"></a>2.15.1 flat() 扁平化</h3><p>深度递归遍历嵌套数组，并且把元素合并为<strong>新</strong>数组返回。接受一个参数，表示提取嵌套数组的深度，默认是1：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-number">7</span>], <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flat</span>()) <span class="hljs-comment">// [ 1, 2, 3, [ 4, 5, 6 ], 7, 8, 9 ]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>))<span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></code></pre></div><p>也可以用来移除数组中的空项：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, , , <span class="hljs-number">4</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flat</span>())<span class="hljs-comment">// [ 1, 2, 3, 4 ]</span></code></pre></div><h3 id="2-15-2-flatMap-扁平化迭代"><a href="#2-15-2-flatMap-扁平化迭代" class="headerlink" title="2.15.2 flatMap() 扁平化迭代"></a>2.15.2 flatMap() 扁平化迭代</h3><p>类似于 map() 和 flat(1) 相结合，但是效率更高：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-number">7</span>], <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<span class="hljs-keyword">const</span> res = arr.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function">(<span class="hljs-params">element, index, array</span>)=&gt;</span>&#123;<span class="hljs-keyword">return</span> element&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// [ 1, 2, 3, [ 4, 5, 6 ], 7, 8, 9 ]</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】10.基本引用类型-Global、Math</title>
    <link href="/archives/fd41bc08.html"/>
    <url>/archives/fd41bc08.html</url>
    
    <content type="html"><![CDATA[<h2 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h2><p><strong>内置对象</strong>是任何由 ECMAScript 实现，与宿主环境无关，并在 ECMAScript 程序开始时就存在的对象。开发者不用显式地实例化内置对象，因为它们已经实例化好了。内置对象包括：Object、Array、String 等等。</p><h2 id="1-Global"><a href="#1-Global" class="headerlink" title="1 Global"></a>1 Global</h2><ol><li>Global 对象是一种兜底对象，针对的是不属于任何对象的属性和方法。</li><li>事实上，<strong>不存在</strong>全局变量或者全局函数这种东西。在全局作用域中定义的变量和函数都会成为 Global 对象的属性。</li><li>isNaN()、isFinite()、parseInt()、parseFloat()等等都是 Global 对象身上的方法。除这些方法外还有其它方法：</li></ol><h3 id="1-1-URL-编解码方法"><a href="#1-1-URL-编解码方法" class="headerlink" title="1.1 URL 编解码方法"></a>1.1 URL 编解码方法</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI">encodeURI()</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent">encodeURIComponent()</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI">decodeURI()</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent">decodeURIComponent()</a></li></ol><h3 id="1-2-eval-方法"><a href="#1-2-eval-方法" class="headerlink" title="1.2 eval() 方法"></a>1.2 eval() 方法</h3><p>eval() 方法是一个完整的 ECMAScript 解释器，接收一个参数，即一个要执行的 ECMAScript 字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;console.log(&#x27;hello&#x27;)&quot;</span>);<span class="hljs-comment">// 相当与下面的语句</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">// hello</span></code></pre></div><p><strong>解释器发现 eval() 调用时，将参数转换成实际的 ECMAScript 语句，然后将其插入到当前位置</strong>。通过 eval() 执行的代码属于<strong>该调用所在的上下文</strong>。被执行的代码与该上下文拥有<strong>相同的作用域链</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;console.log(message);&quot;</span>);<span class="hljs-comment">// hello</span></code></pre></div><h3 id="1-3-Global-对象属性"><a href="#1-3-Global-对象属性" class="headerlink" title="1.3 Global 对象属性"></a>1.3 Global 对象属性</h3><p>像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object、Function，也都是 Global 对象的属性。</p><h3 id="1-4-window-对象"><a href="#1-4-window-对象" class="headerlink" title="1.4 window 对象"></a>1.4 window 对象</h3><p>虽然 ECMAScript 没有规定直接访问 Global 对象的方法，但是浏览器将 window 对象实现为 Global 对象的<strong>代理</strong>。因此，所有全局作用域中声明的变量和函数都成了 window 的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">s</span>);<span class="hljs-comment">// hello</span></code></pre></div><p>另一种获取 Global 对象的方式是：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-variable language_">global</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;&#125;)();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">global</span>);<span class="hljs-comment">// Window</span></code></pre></div><p>这段代码创建一个<strong>立即调用的函数表达式</strong>，返回 this 值。一个函数在没有明确指定 this 的值的情况下执行时，this 的值等于 Global 对象。</p><h2 id="2-Math"><a href="#2-Math" class="headerlink" title="2 Math"></a>2 Math</h2><p> ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。Math 对象上提供的计算要比 JavaScript 实现的快得多。因为 Math 对象上的计算使用了JavaScript 引擎中更高效的实现和处理器指令。</p><h3 id="2-1-Math-对象属性"><a href="#2-1-Math-对象属性" class="headerlink" title="2.1 Math 对象属性"></a>2.1 Math 对象属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Math.E</td><td>欧拉常数，也是自然对数的底数，约等于 <code>2.718</code>。</td></tr><tr><td>Math.LN10</td><td><code>10</code> 的自然对数，约等于 <code>2.303</code>。</td></tr><tr><td>Math.LN2</td><td><code>10</code> 的自然对数，约等于 <code>2.303</code>。</td></tr><tr><td>Math.LOG2E</td><td>以 <code>2</code> 为底的 <code>E</code> 的对数，约等于 <code>1.443</code>。</td></tr><tr><td>Math.LOG10E</td><td>以 <code>10</code> 为底的 <code>E</code> 的对数，约等于 <code>0.434</code>。</td></tr><tr><td>Math.PI</td><td>圆周率，一个圆的周长和直径之比，约等于 <code>3.14159</code>。</td></tr><tr><td>Math.SQRT1_2</td><td>1&#x2F;2 的平方根</td></tr><tr><td>Math.SQRT2</td><td><code>2</code> 的平方根，约等于 <code>1.414</code>。</td></tr></tbody></table><h3 id="2-2-min-和-max-方法"><a href="#2-2-min-和-max-方法" class="headerlink" title="2.2 min() 和 max() 方法"></a>2.2 min() 和 max() 方法</h3><p>min() 和 max() 用来确定一组数值中的最大值和最小值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">12</span>, <span class="hljs-number">32</span>, <span class="hljs-number">4</span>, <span class="hljs-number">13</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(max);       <span class="hljs-comment">// 32</span></code></pre></div><p>要知道数组中的最大值和最小值，可以使用扩展操作符：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">13</span>, <span class="hljs-number">432</span>, <span class="hljs-number">12</span>, <span class="hljs-number">43</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr));  <span class="hljs-comment">// 432</span></code></pre></div><h3 id="2-3-舍入方法"><a href="#2-3-舍入方法" class="headerlink" title="2.3 舍入方法"></a>2.3 舍入方法</h3><h4 id="2-3-1-Math-ceil"><a href="#2-3-1-Math-ceil" class="headerlink" title="2.3.1 Math.ceil()"></a>2.3.1 Math.ceil()</h4><blockquote><p>ceil：天花板，向上取整</p></blockquote><p>始终<strong>向上</strong>舍入最接近的整数（总是取比它大的整数）：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">12.3</span>));<span class="hljs-comment">// 13</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">12.6</span>));<span class="hljs-comment">// 13</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(-<span class="hljs-number">12.3</span>));<span class="hljs-comment">// -12</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(-<span class="hljs-number">12.6</span>));<span class="hljs-comment">// -12</span></code></pre></div><h4 id="2-3-2-Math-floor"><a href="#2-3-2-Math-floor" class="headerlink" title="2.3.2 Math.floor()"></a>2.3.2 Math.floor()</h4><blockquote><p>floor：地板，向下取整</p></blockquote><p>始终<strong>向下</strong>舍入最接近的整数（总是取比它小的整数）：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">12.3</span>));<span class="hljs-comment">// 12</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">12.6</span>));<span class="hljs-comment">// 12</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(-<span class="hljs-number">12.3</span>));<span class="hljs-comment">// -13</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(-<span class="hljs-number">12.6</span>));<span class="hljs-comment">// -13</span></code></pre></div><h4 id="2-3-3-Math-round"><a href="#2-3-3-Math-round" class="headerlink" title="2.3.3 Math.round()"></a>2.3.3 Math.round()</h4><p>四舍五入到最接近的整数：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">12.3</span>));      <span class="hljs-comment">// 12     </span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">12.6</span>));<span class="hljs-comment">// 13</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(-<span class="hljs-number">12.3</span>));<span class="hljs-comment">// -12</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(-<span class="hljs-number">12.6</span>));<span class="hljs-comment">// -13</span></code></pre></div><h4 id="2-3-4-Math-fround"><a href="#2-3-4-Math-fround" class="headerlink" title="2.3.4 Math.fround()"></a>2.3.4 Math.fround()</h4><p>转换为离它最近的<a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">单精度浮点数</a>形式的数字：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">fround</span>(<span class="hljs-number">1.333</span>));<span class="hljs-comment">// 1.3329999446868896</span></code></pre></div><p>扩展：</p><p>JavaScript 内部使用64位的双浮点数字，支持很高的精度。但是，有时你需要用32位浮点数字，比如你从一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code>Float32Array</code></a> 读取值时。这时会产生混乱：检查一个64位浮点数和一个32位浮点数是否相等会失败，即使二个数字几乎一模一样。</p><p>要解决这个问题，可以使用 <code>Math.fround()</code> 来将64位的浮点数转换为32位浮点数。在内部，JavaScript 继续把这个数字作为64位浮点数看待，仅仅是在尾数部分的第23位执行了“舍入到偶数”的操作，并将后续的尾数位设置为0。如果数字超出32位浮点数的范围，则返回 <code>Infinity</code>或 <code>-Infinity</code>。</p><p>因为<code>fround()</code> 是<code>Math</code> 的静态方法，你必须通过 <code>Math.fround()</code> 来使用，而不是调用你创建的<code>Math</code> 对象的一个实例方法（<code>Math</code>不是一个构造函数）。</p><p>数字 1.5 可以在二进制数字系统中精确表示，32 位和 64 位相同：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">fround</span>(<span class="hljs-number">1.5</span>); <span class="hljs-comment">// 1.5</span><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">fround</span>(<span class="hljs-number">1.5</span>) === <span class="hljs-number">1.5</span>; <span class="hljs-comment">// true</span></code></pre></div><p>但是，数字1.337却无法在二进制数字系统中精确表示，所以32位和64位的值是不同的：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">fround</span>(<span class="hljs-number">1.337</span>); <span class="hljs-comment">// 1.3370000123977661</span><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">fround</span>(<span class="hljs-number">1.337</span>) === <span class="hljs-number">1.337</span>; <span class="hljs-comment">// false</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】9.基本引用类型-Boolean、Number、String</title>
    <link href="/archives/9d23972e.html"/>
    <url>/archives/9d23972e.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h1><p>为了方便操作原始值，ECMAScript 提供了3种特殊的引用类型：Boolean、Number 和 String。这些类型具有和各自原始类型对应的特殊行为。每当用到某个原始值的方法或者属性时，后台都会创建一个相应的<strong>原始包装类型</strong>对象，从而暴露出操作原始值的方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&quot;string&quot;</span>;<span class="hljs-keyword">let</span> s2 = s1.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>);</code></pre></div><p>s1 是一个包含字符串的变量，是一个原始值。第二行在 s1 上调用了<code>subString()</code>方法。原始值不是对象，按理说不该有方法，而实际上这个例子又能运行。</p><p>这是因为后台做了很多的处理：当第二行访问 s1 时，是以<strong>读模式</strong>访问的，也就是要从内存中读取保存变量的值。以读模式访问字符串的时候，后台都会执行三步：</p><ol><li>创建一个 String 类型的实例。</li><li>调用实例上的特定方法。</li><li>销毁实例。</li></ol><p>可以想象成下面的代码：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;string&#x27;</span>)<span class="hljs-keyword">let</span> s2 = s1.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>);s1 = <span class="hljs-literal">null</span></code></pre></div><p>这种行为可以让原始值拥有对象的行为，对于布尔值和数值，以上3步也会在后台发生，只不过使用的是 Boolean和 Number 包装类型。</p><p>引用类型和原始值包装类型的主要区别在于<strong>生命周期</strong>。通过 new 实例化引用类型后，得到的实例会在离开作用域时销毁。而自动创建的原始值包装对象只存在于访问它的那行代码之间。这意味着不能再运行时给原始值添加属性和方法：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;string&#x27;</span>s1.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span><span class="hljs-comment">// 不报错</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">foo</span>);<span class="hljs-comment">// undefined</span></code></pre></div><p>可以显式地使用 Boolean、Number、String 构造函数创建原始值包装对象，但是会让开发者疑惑到底这是原始值还是包装对象。在原始值包装类型的实例上用 typeof 会返回”object”。不推荐显式使用原始值包装对象。</p><p>Object() 构造函数作为一个工厂方法，可以根据传入值的类型返回相应的原始值包装类型的实例。如果传给 Object 构造方法的是字符串，则会创建一个 String 实例对象；如果是数值，则会创建 Number 实例对象；布尔值会创建Boolean 实例对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(<span class="hljs-string">&#x27;string&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);<span class="hljs-comment">// true</span></code></pre></div><p>使用 new 调用原始值包装类型的构造函数和调用同名的转型函数<strong>不一样</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> val = <span class="hljs-string">&quot;25&quot;</span>;<span class="hljs-keyword">let</span> num = <span class="hljs-title class_">Number</span>(val);<span class="hljs-comment">// 转型函数</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> num);<span class="hljs-comment">// number</span><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(val);<span class="hljs-comment">// 构造函数</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> obj);<span class="hljs-comment">// object</span></code></pre></div><h2 id="1-Boolean"><a href="#1-Boolean" class="headerlink" title="1 Boolean"></a>1 Boolean</h2><p>Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean() 构造函数并传入 true 或者 false。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// Boolean &#123;true&#125;</span></code></pre></div><p>Boolean 重写了 valueOf() 方法。Boolean实例返回一个原始值 true 或者 false。</p><p>toLocaleString() 和 toString() 方法也被重写，返回字符串 “true” 或者 “false”。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">valueOf</span>());<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">toString</span>());<span class="hljs-comment">// &quot;true&quot;</span></code></pre></div><p>Boolean <strong>对象</strong>在布尔表达式中会自动转化成 true，无论创建这个对象时传入的是 true 还是 false。</p><p>原始值（true、false）和引用值（Boolean 实例）的几个区别：</p><ol><li>typeof 操作符对原始值返回”boolean”，对引用值返回”object”。</li><li>instanceof 操作符对 Boolean 对象返回 true，对原始值返回 false。</li></ol><h2 id="2-Number"><a href="#2-Number" class="headerlink" title="2 Number"></a>2 Number</h2><p>Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">10</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// Number&#123;10&#125;</span></code></pre></div><p>Number 类型重写了 valueOf()、toString() 方法。valueOf() 方法返回 Number 对象表示的原始数值，toLocaleString()、toString() 方法返回数值字符串。</p><p>toString() 方法可选地接收一个表示基数的参数，并返回相应基数的数值字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">10</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>));   <span class="hljs-comment">// 1010</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>));   <span class="hljs-comment">// 12</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>));  <span class="hljs-comment">// a</span></code></pre></div><p>除了继承的方法，Number 类型还提供了几个用于将数值格式化为字符串的方法。</p><h3 id="2-1-toFixed-返回指定小数位数的字符串"><a href="#2-1-toFixed-返回指定小数位数的字符串" class="headerlink" title="2.1 toFixed() 返回指定小数位数的字符串"></a>2.1 toFixed() 返回指定小数位数的字符串</h3><p>toFixed() 方法返回包含<strong>指定小数位数</strong>的字符串。位数不够的填0，位数超出则四舍五入。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">12.345</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">5</span>));<span class="hljs-comment">// 12.34500</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">// 12.35</span></code></pre></div><h3 id="2-2-toExponential-返回科学计数法表示的字符串"><a href="#2-2-toExponential-返回科学计数法表示的字符串" class="headerlink" title="2.2 toExponential() 返回科学计数法表示的字符串"></a>2.2 toExponential() 返回科学计数法表示的字符串</h3><p> toExponential() 方法返回<strong>科学计数法</strong>表示的字符串。也接收一个参数，表示结果中<strong>小数的位数</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">12.0000000000345</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toExponential</span>());<span class="hljs-comment">// 1.20000000000345e+1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toExponential</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">// 1.20e+1</span></code></pre></div><h3 id="2-3-toPrecision-返回最适合的形式表示的字符串"><a href="#2-3-toPrecision-返回最适合的形式表示的字符串" class="headerlink" title="2.3 toPrecision() 返回最适合的形式表示的字符串"></a>2.3 toPrecision() 返回最适合的形式表示的字符串</h3><p>toPrecision() 根据情况返回<strong>最合理</strong>的输出结果。接收一个参数，表示结果中<strong>数字的总位数</strong>（不包含指数）。</p><p>本质上，toPrecision() 会根据数值和精度来决定调用 toFixed() 还是 toExponential()。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">12.000000000345</span>;<span class="hljs-keyword">let</span> num2 = <span class="hljs-number">12.345</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 1e+1（舍入为10）</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 12（舍入为12）</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 12.0（舍入为12.0）</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num2.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 12.3</span></code></pre></div><p>解释：因为 num1 不能用1位数精确表示，所以这个方法会将 num1 舍入为 10。</p><h3 id="2-4-Number-isInteger-辨别是否保存为整数"><a href="#2-4-Number-isInteger-辨别是否保存为整数" class="headerlink" title="2.4 Number.isInteger() 辨别是否保存为整数"></a>2.4 Number.isInteger() 辨别是否保存为整数</h3><p>Number.isInteger() 方法可以用来辨别一个数是否<strong>保存为整数</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">10</span>));      <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">10.0</span>));    <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">10.1</span>));    <span class="hljs-comment">// false</span></code></pre></div><h3 id="2-5-Number-isSafeInteger-辨别是否安全整数"><a href="#2-5-Number-isSafeInteger-辨别是否安全整数" class="headerlink" title="2.5 Number.isSafeInteger() 辨别是否安全整数"></a>2.5 Number.isSafeInteger() 辨别是否安全整数</h3><p>IEEE 754 格式有一个特殊的数值范围，这个范围中的二进制值可以表示为一个整数。这个数值范围是：<code>Number.MIN_SAFE_INTEGER</code> 到<code>Number.MAX_SAFE_INTEGER</code>。超过了这个范围，即使保存为整数，IEEE 754 格式也意味着表示为完全不同的数值。</p><p>为了鉴别一个数是否在这个数值内，可以使用 Number.isSafeInteger() 方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">53</span> -<span class="hljs-number">1</span>));<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">54</span>));<span class="hljs-comment">// false</span></code></pre></div><h2 id="3-String"><a href="#3-String" class="headerlink" title="3 String"></a>3 String</h2><p>String 是对应布尔值的引用类型。要创建一个 String 对象，就使用 String() 构造函数并传入字符串原始值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;string&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> obj);        <span class="hljs-comment">// object</span></code></pre></div><p>String 对象继承的三个方法 valueOf()、toLocaleString()、toString() 都返回对象的原始字符串表示。</p><h3 id="3-1-字符串拼接和截取"><a href="#3-1-字符串拼接和截取" class="headerlink" title="3.1 字符串拼接和截取"></a>3.1 字符串拼接和截取</h3><h4 id="3-1-1-concat-字符串拼接"><a href="#3-1-1-concat-字符串拼接" class="headerlink" title="3.1.1 concat() 字符串拼接"></a>3.1.1 concat() 字符串拼接</h4><p>concat() 方法，用于将一个或多个字符串拼接成一个<strong>新</strong>的字符串。concat() 会返回一个新值，而不会改变原始值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello &quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;world&quot;</span>));    <span class="hljs-comment">// hello world</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);                    <span class="hljs-comment">// hello </span></code></pre></div><p>concat() 方法可以接受任意个数的参数，因此可以一次拼接多个字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>));<span class="hljs-comment">// hello world!</span></code></pre></div><p>虽然 concat() 方法可以拼接字符串，但是更多时候使用加号操作符（+）。多数情况下，使用加号更加方便。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-string">&quot;world&quot;</span> + <span class="hljs-string">&quot;!&quot;</span>);<span class="hljs-comment">// hello world! </span></code></pre></div><h4 id="3-1-2-slice-提取子字符串"><a href="#3-1-2-slice-提取子字符串" class="headerlink" title="3.1.2 slice() 提取子字符串"></a>3.1.2 slice() 提取子字符串</h4><p><code>slice()</code> 方法提取某个字符串的一部分，并返回一个<strong>新</strong>的字符串，且不会改动原字符串。slice() 方法接收两个参数，第一个参数表示子字符串的开始位置，第二个参数表示子字符串的结束位置。<strong>含头不含尾</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);   <span class="hljs-comment">// &#x27;23&#x27;</span></code></pre></div><ol><li><p>如果第二个参数<strong>缺失</strong>（不是0），则提取到字符串<strong>末尾</strong>。</p></li><li><p>当参数是<strong>负数</strong>时，slice() 方法将所有的负值参数都当成<strong>字符串长度加上负参数值</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">5</span>, -<span class="hljs-number">2</span>); <span class="hljs-comment">// 相当于s.slice(3,6)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub); <span class="hljs-comment">// &quot;456&quot;</span></code></pre></div><p>如果加上字符串长度后，第一个参数仍是负数，则从第一位开始截取。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">// -10加上8后仍是负数</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<span class="hljs-comment">// 12345</span></code></pre></div><p>如果加上字符串长度后，第二个参数仍是负数，则返回空串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">10</span>);<span class="hljs-comment">// -10加上8后仍是负数</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<span class="hljs-comment">// 空串</span></code></pre></div></li></ol><h4 id="3-1-3-substring-提取子字符串"><a href="#3-1-3-substring-提取子字符串" class="headerlink" title="3.1.3 substring() 提取子字符串"></a>3.1.3 substring() 提取子字符串</h4><p> <code>substring() </code>方法提取某个字符串的一部分，并返回一个<strong>新</strong>的字符串，且不会改动原字符串。substring() 方法接收两个参数，第一个参数表示子字符串的开始位置，第二个参数表示子字符串的结束位置。<strong>含头不含尾</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);   <span class="hljs-comment">// &#x27;23&#x27;</span></code></pre></div><ol><li><p>如果第二个参数<strong>缺失</strong>（不是0），则提取到字符串<strong>末尾</strong>。</p></li><li><p>当参数是<strong>负数</strong>时，substring() 方法把所有负参数值都转为0。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">substring</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<span class="hljs-comment">// 123456</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">6</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<span class="hljs-comment">// 1</span></code></pre></div></li><li><p>如果第二个参数小于第一个参数，则两参数就像调换一样。总是返回较小参数位置到较大参数位置的子串。</p></li></ol><h4 id="3-1-4-substr-提取子字符串-（废弃）"><a href="#3-1-4-substr-提取子字符串-（废弃）" class="headerlink" title="3.1.4 substr() 提取子字符串 （废弃）"></a>3.1.4 substr() 提取子字符串 （废弃）</h4><p> <code>substr() </code>方法提取某个字符串的一部分，并返回一个<strong>新</strong>的字符串，且不会改动原字符串。substr() 方法接收两个参数，第一个参数表示子字符串的开始位置，第二个参数表示返回的字符串中字符的数量。<strong>含头含尾</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<span class="hljs-comment">// 2345</span></code></pre></div><ol><li><p>如果第二个参数<strong>缺失</strong>（不是0），则提取到字符串<strong>末尾</strong>。</p></li><li><p>当参数是<strong>负数</strong>时，substr() 方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换成0。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">substr</span>(-<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);   <span class="hljs-comment">// 56</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;12345678&quot;</span>;<span class="hljs-keyword">let</span> sub = s.<span class="hljs-title function_">substr</span>(<span class="hljs-number">4</span>, -<span class="hljs-number">6</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub); <span class="hljs-comment">// 第二个参数如果为0，相当于空串</span></code></pre></div></li></ol><h3 id="3-2-字符串位置方法"><a href="#3-2-字符串位置方法" class="headerlink" title="3.2 字符串位置方法"></a>3.2 字符串位置方法</h3><h4 id="3-2-1-indexOf-查找子串位置"><a href="#3-2-1-indexOf-查找子串位置" class="headerlink" title="3.2.1 indexOf() 查找子串位置"></a>3.2.1 indexOf() 查找子串位置</h4><p>indexOf() 方法从字符串<strong>头</strong>开始查找子字符串，并返回子串的开始位置（如果没有找到，则返回-1）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;aabcabcd&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;bc&quot;</span>));   <span class="hljs-comment">// 2</span></code></pre></div><p>接收可选的第二个参数，表示搜索的开始位置。indexOf() 方法会从这个位置开始向尾搜索。</p><h4 id="3-2-2-lastIndexOf-查找子串位置"><a href="#3-2-2-lastIndexOf-查找子串位置" class="headerlink" title="3.2.2 lastIndexOf() 查找子串位置"></a>3.2.2 lastIndexOf() 查找子串位置</h4><p>lastIndexOf() 方法从字符串<strong>尾</strong>开始查找子字符串，并返回子串的开始位置（如果没有找到，则返回-1）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;aabcabcd&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;bc&quot;</span>));   <span class="hljs-comment">// 5</span></code></pre></div><p>接收可选的第二个参数，表示搜索的开始位置。lastIndexOf() 方法会从这个位置开始向头搜索。</p><h4 id="3-2-3-找所有子串的位置"><a href="#3-2-3-找所有子串的位置" class="headerlink" title="3.2.3 找所有子串的位置"></a>3.2.3 找所有子串的位置</h4><p>使用第二个参数并循环调用 indexOf() 或 lastIndexOf()，可以在字符串中找到所有目标子字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;aabcabcdbc&quot;</span>;<span class="hljs-keyword">let</span> sub = <span class="hljs-string">&quot;bc&quot;</span>;<span class="hljs-keyword">let</span> posArr = [];<span class="hljs-keyword">let</span> pos = s.<span class="hljs-title function_">indexOf</span>(sub);<span class="hljs-keyword">while</span> (pos !== -<span class="hljs-number">1</span>) &#123;  posArr.<span class="hljs-title function_">push</span>(pos);  pos = s.<span class="hljs-title function_">indexOf</span>(sub, pos + <span class="hljs-number">1</span>);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(posArr);<span class="hljs-comment">// [ 2, 5, 8 ]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;aabcabcdbc&quot;</span>;<span class="hljs-keyword">let</span> sub = <span class="hljs-string">&quot;bc&quot;</span>;<span class="hljs-keyword">let</span> posArr = [];<span class="hljs-keyword">let</span> pos = s.<span class="hljs-title function_">lastIndexOf</span>(sub);<span class="hljs-keyword">while</span> (pos !== -<span class="hljs-number">1</span>) &#123;  posArr.<span class="hljs-title function_">push</span>(pos);  pos = s.<span class="hljs-title function_">lastIndexOf</span>(sub, pos - <span class="hljs-number">1</span>);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(posArr);<span class="hljs-comment">// [ 8, 5, 2 ]</span></code></pre></div><h3 id="3-3-字符串包含方法"><a href="#3-3-字符串包含方法" class="headerlink" title="3.3 字符串包含方法"></a>3.3 字符串包含方法</h3><h4 id="3-3-1-startsWith"><a href="#3-3-1-startsWith" class="headerlink" title="3.3.1 startsWith()"></a>3.3.1 startsWith()</h4><p><code>startsWith()</code> 方法用来判断当前字符串是否以 另外一个给定的子字符串<strong>开头</strong>，并根据判断结果返回 <code>true</code> 或 <code>false</code>。<code>startsWith()</code>方法接收可选的第二个参数，表示开始搜索的位置。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;afoobar&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-number">1</span>));<span class="hljs-comment">// true</span></code></pre></div><h4 id="3-3-2-endsWith"><a href="#3-3-2-endsWith" class="headerlink" title="3.3.2 endsWith()"></a>3.3.2 endsWith()</h4><p><code>endsWith()</code>方法用来判断当前字符串是否是以另外一个给定的子字符串<strong>结尾</strong>的，根据判断结果返回 <code>true</code> 或 <code>false</code>。<code>endsWith()</code>方法接收可选的第二个参数，表示应该当作字符串结束的位置，如果不提供这个参数，默认是字符串的长度。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;foobara&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;bar&#x27;</span>));<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;bar&#x27;</span>,<span class="hljs-number">6</span>));<span class="hljs-comment">// true</span></code></pre></div><h4 id="3-3-3-includes"><a href="#3-3-3-includes" class="headerlink" title="3.3.3 includes()"></a>3.3.3 includes()</h4><p><code>includes()</code> 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 <code>true </code>或<code> false</code>。<code>includes()</code>方法接收可选的第二个参数，表示开始搜索的位置。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;foobarfoo&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;bar&#x27;</span>));<span class="hljs-comment">// true</span></code></pre></div><h3 id="3-4-trim-删除前后空格"><a href="#3-4-trim-删除前后空格" class="headerlink" title="3.4 trim() 删除前后空格"></a>3.4 trim() 删除前后空格</h3><p><code>trim()</code> 方法返回一个从两头去掉空白字符的<strong>新</strong>字符串，并不影响原字符串本身。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&quot;    foobar &quot;</span>;<span class="hljs-keyword">let</span> s2 = s1.<span class="hljs-title function_">trim</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1);    <span class="hljs-comment">// 不改变原字符串</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s2);    <span class="hljs-comment">// foobar</span></code></pre></div><ol><li>trimEnd() ，别名 trimRight() 移除字符串末尾空格。</li><li>trimStart() ，别名 trimLeft() 移除字符串开头空格。</li></ol><h3 id="3-5-repeat-字符串复制"><a href="#3-5-repeat-字符串复制" class="headerlink" title="3.5 repeat() 字符串复制"></a>3.5 repeat() 字符串复制</h3><p>repeat() 构造并返回一个<strong>新字符串</strong>，接收一个参数表示将字符串重复多少次，然后返回拼接后的结果。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;foo&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">5</span>));   <span class="hljs-comment">// foofoofoofoofoo</span></code></pre></div><h3 id="3-6-padStart-和-padEnd-字符串填充"><a href="#3-6-padStart-和-padEnd-字符串填充" class="headerlink" title="3.6 padStart() 和 padEnd() 字符串填充"></a>3.6 padStart() 和 padEnd() 字符串填充</h3><p>padStart() 和 padEnd() 方法用另一个字符串<strong>填充</strong>当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。padStart() 从左侧开始填充，padEnd() 从右侧开始填充。这两个方法第一个参数是长度，第二个参数是可选的填充字符串，默认空格。返回<strong>新字符串</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-keyword">let</span> s1 = s.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;bar&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1);                <span class="hljs-comment">// barbarbfoo</span><span class="hljs-keyword">let</span> s2 = s.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;bar&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s2);                <span class="hljs-comment">// foobarbarb</span></code></pre></div><h3 id="3-7-字符串迭代和解构"><a href="#3-7-字符串迭代和解构" class="headerlink" title="3.7 字符串迭代和解构"></a>3.7 字符串迭代和解构</h3><p>字符串原型上暴露了一个<code>@@iterator</code>方法，返回一个新的 Iterator 对象，它遍历字符串的代码点，返回每一个代码点的字符串值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> string = <span class="hljs-string">&quot;abcde&quot;</span>;<span class="hljs-keyword">let</span> strIter = string[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strIter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strIter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strIter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strIter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;d&#x27;, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strIter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &#x27;e&#x27;, done: false &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strIter.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span></code></pre></div><p>使用 for-of 循环，通过迭代器按序访问每个字符。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> string = <span class="hljs-string">&quot;abcde&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> s <span class="hljs-keyword">of</span> string) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// a b c d e</span>&#125;</code></pre></div><p>有了这个迭代器，可以通过<strong>解构操作符</strong>来解构。比如：把字符串分割为字符数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> string = <span class="hljs-string">&quot;abcde&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...string]);   <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></code></pre></div><h3 id="3-8-toLowerCase-、toUpperCase-字符串大小写转换"><a href="#3-8-toLowerCase-、toUpperCase-字符串大小写转换" class="headerlink" title="3.8 toLowerCase()、toUpperCase 字符串大小写转换"></a>3.8 toLowerCase()、toUpperCase 字符串大小写转换</h3><p> <code>toLowerCase()</code> 会将调用该方法的字符串值转为<strong>小写形式</strong>，并返回<strong>新</strong>字符串。</p><p><code>toUpperCase()</code>方法将调用该方法的字符串转为<strong>大写形式</strong>，并返回<strong>新</strong>字符串。 </p><p><code>toLocaleLowerCase()</code>方法根据任何指定区域语言环境设置的大小写映射，返回调用字符串被转换为小写的格式。</p><p><code>toLocaleUpperCase()</code>方法根据任何指定区域语言环境设置的大小写映射，返回调用字符串被转换为大写的格式。</p><p>注意：</p><ol><li>多数地区下，地区特定方法和通用方法相同，少数地区需要用地区特定方法。</li><li>如果不知道代码涉及什么语言，最好使用地区特定方法。</li></ol><h3 id="3-9-字符串模式匹配"><a href="#3-9-字符串模式匹配" class="headerlink" title="3.9 字符串模式匹配"></a>3.9 字符串模式匹配</h3><h4 id="3-9-1-match-返回匹配到的结果数组"><a href="#3-9-1-match-返回匹配到的结果数组" class="headerlink" title="3.9.1 match() 返回匹配到的结果数组"></a>3.9.1 match() 返回匹配到的结果数组</h4><p>match() 检索返回一个字符串匹配正则表达式的结果。接收一个参数，可以是一个正则表达式，也可以是一个RegExp 对象。返回一个<strong>数组</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> paragraph = <span class="hljs-string">&#x27;The quick brown fox jumps over the lazy dog. It barked.&#x27;</span>;<span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/[A-Z]/g</span>;<span class="hljs-keyword">const</span> found = paragraph.<span class="hljs-title function_">match</span>(regex);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(found);     <span class="hljs-comment">// [ &#x27;T&#x27;, &#x27;I&#x27; ]</span></code></pre></div><h4 id="3-9-2-search-返回一个匹配到的位置索引"><a href="#3-9-2-search-返回一个匹配到的位置索引" class="headerlink" title="3.9.2 search() 返回一个匹配到的位置索引"></a>3.9.2 search() 返回一个匹配到的位置索引</h4><p>search() 方法执行正则表达式和 String 对象之间的一个搜索匹配。接收一个参数，可以是一个正则表达式，也可以是一个 RegExp 对象。返回第一个匹配位置的<strong>索引</strong>，如果没有找到则返回-1。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> paragraph = <span class="hljs-string">&quot;the Quick brown fox jumps over the lazy dog. It barked.&quot;</span>;<span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/[A-Z]/g</span>;<span class="hljs-keyword">const</span> found = paragraph.<span class="hljs-title function_">search</span>(regex);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(found);     <span class="hljs-comment">// 4</span></code></pre></div><h4 id="3-9-3-replace-、replaceAll-字符串替换"><a href="#3-9-3-replace-、replaceAll-字符串替换" class="headerlink" title="3.9.3 replace()、replaceAll() 字符串替换"></a>3.9.3 replace()、replaceAll() 字符串替换</h4><p><strong><code>replace()</code></strong> 方法返回一个由替换值（<code>replacement</code>）替换部分或所有的模式（<code>pattern</code>）匹配项后的<strong>新</strong>字符串。模式可以是一个字符串或者一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">正则表达式</a>，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。<strong>如果<code>pattern</code>是字符串，则仅替换第一个匹配项。</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-string">&#x27;The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;monkey&#x27;</span>));<span class="hljs-comment">// expected output: &quot;The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?&quot;</span><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/dog/g</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">replace</span>(regex, <span class="hljs-string">&#x27;ferret&#x27;</span>));<span class="hljs-comment">// expected output: &quot;The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?&quot;</span></code></pre></div><p><strong><code>replaceAll()</code></strong> 方法返回一个<strong>新</strong>字符串，新字符串所有满足 <code>pattern</code> 的部分都已被<code>replacement</code> 替换。<code>pattern</code>可以是一个字符串或一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a>， <code>replacement</code>可以是一个字符串或一个在每次匹配被调用的函数。原始字符串保持不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-string">&#x27;The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;monkey&#x27;</span>));<span class="hljs-comment">// expected output: &quot;The quick brown fox jumps over the lazy monkey. If the monkey reacted, was it really lazy?&quot;</span><span class="hljs-comment">// global flag required when calling replaceAll with regex</span><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/Dog/ig</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">replaceAll</span>(regex, <span class="hljs-string">&#x27;ferret&#x27;</span>));<span class="hljs-comment">// expected output: &quot;The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?&quot;</span></code></pre></div><h4 id="3-9-4-split-字符串分割，返回数组"><a href="#3-9-4-split-字符串分割，返回数组" class="headerlink" title="3.9.4 split() 字符串分割，返回数组"></a>3.9.4 split() 字符串分割，返回数组</h4><p><code>split() </code>方法使用指定的分隔符字符串将一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 </p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;The quick brown fox&quot;</span>;<span class="hljs-keyword">const</span> words = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(words);             <span class="hljs-comment">// [ &#x27;The&#x27;, &#x27;quick&#x27;, &#x27;brown&#x27;, &#x27;fox&#x27; ]</span><span class="hljs-keyword">const</span> chars = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chars[<span class="hljs-number">8</span>]);          <span class="hljs-comment">// k</span><span class="hljs-keyword">const</span> strCopy = str.<span class="hljs-title function_">split</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strCopy);           <span class="hljs-comment">// [ &#x27;The quick brown fox&#x27; ]</span></code></pre></div><h3 id="3-10-localeCompare"><a href="#3-10-localeCompare" class="headerlink" title="3.10 localeCompare()"></a>3.10 localeCompare()</h3><p>这个方法比较两个字符串：</p><ol><li><p>按照字母表排序，如果字符串应该排在字符串参数<strong>前面</strong>，则返回<strong>负值</strong>。（通常是 -1，具体看实现）</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s1 = <span class="hljs-string">&#x27;abc&#x27;</span><span class="hljs-keyword">const</span> s2 = <span class="hljs-string">&#x27;bcd&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-title function_">localeCompare</span>(s2));  <span class="hljs-comment">// -1</span></code></pre></div></li><li><p>字符串和字符串参数<strong>相等</strong>，返回 0。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s1 = <span class="hljs-string">&#x27;abcd&#x27;</span><span class="hljs-keyword">const</span> s2 = <span class="hljs-string">&#x27;abcd&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-title function_">localeCompare</span>(s2));  <span class="hljs-comment">// 0</span></code></pre></div></li><li><p>按照字母表排序，如果字符串应该排在字符串参数<strong>后面</strong>，则返回<strong>正值</strong>。（通常是 1，具体看实现）</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s1 = <span class="hljs-string">&#x27;bcd&#x27;</span><span class="hljs-keyword">const</span> s2 = <span class="hljs-string">&#x27;abc&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-title function_">localeCompare</span>(s2));  <span class="hljs-comment">// 1</span></code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】8.基本引用类型：Date、RegExp</title>
    <link href="/archives/ba185f0c.html"/>
    <url>/archives/ba185f0c.html</url>
    
    <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟上一个构造函数（constructor）来创建。比如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()</code></pre></div><p>这行代码创建了引用类型 Date 的一个新实例，并将其保存到变量 date 中。<code>Date()</code> 在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。</p><h1 id="1-Date"><a href="#1-Date" class="headerlink" title="1 Date"></a>1 Date</h1><p>创建一个 JavaScript <code>Date</code> 实例，该实例呈现时间中的某个时刻。<code>Date</code> 对象则基于 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16">Unix Time Stamp</a>，即自1970年1月1日（UTC）起经过的毫秒数。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E8%AF%AD%E6%B3%95">语法</a></h2><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>;<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(<span class="hljs-params">value</span>)</span>;<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(<span class="hljs-params">dateString</span>)</span>;<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(<span class="hljs-params">year</span>, <span class="hljs-params">monthIndex</span> [, <span class="hljs-params">day</span> [, <span class="hljs-params">hours</span> [, <span class="hljs-params">minutes</span> [, <span class="hljs-params">seconds</span> [, <span class="hljs-params">milliseconds</span>]]]]])</span>;</code></pre></div><p><strong>备注：</strong>创建一个新<code>Date</code>对象的唯一方法是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a> 操作符，例如：<code>let now = new Date();</code><br>若将它作为常规函数调用（即不加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a> 操作符），将返回一个字符串，而非 <code>Date</code> 对象。 </p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E5%8F%82%E6%95%B0">参数</a></h3><p><code>Date()</code>构造函数有四种基本形式</p><h4 id="没有参数"><a href="#没有参数" class="headerlink" title="没有参数"></a>没有参数</h4><p>如果没有提供参数，那么新创建的Date对象表示实例化时刻的日期和时间。</p><h4 id="Unix时间戳"><a href="#Unix时间戳" class="headerlink" title="Unix时间戳"></a>Unix时间戳</h4><ul><li><p><code>value</code></p><p>一个 Unix 时间戳（<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16">Unix Time Stamp</a>），它是一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数，忽略了闰秒。请注意大多数 Unix 时间戳功能仅精确到最接近的秒。</p></li><li><p>时间戳字符串 <code>dateString</code></p><p>表示日期的字符串值。该字符串应该能被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse"><code>Date.parse()</code></a> 正确方法识别（即符合 <a href="https://tools.ietf.org/html/rfc2822#page-14">IETF-compliant RFC 2822 timestamps</a> 或 <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">version of ISO8601</a>）。<strong>备注：</strong>由于浏览器之间的差异与不一致性，强烈不推荐使用<code>Date</code>构造函数来解析日期字符串 (或使用与其等价的<code>Date.parse</code>)。对 RFC 2822 格式的日期仅有约定俗成的支持。 对 ISO 8601 格式的支持中，仅有日期的串 (例如 “1970-01-01”) 会被处理为 UTC 而不是本地时间，与其他格式的串的处理不同。</p></li></ul><h4 id="分别提供日期与时间的每一个成员"><a href="#分别提供日期与时间的每一个成员" class="headerlink" title="分别提供日期与时间的每一个成员"></a>分别提供日期与时间的每一个成员</h4><p>当至少提供了年份与月份时，这一形式的 <code>Date() </code>返回的 <code>Date </code>对象中的每一个成员都来自下列参数。没有提供的成员将使用最小可能值（对日期为<code>1</code>，其他为<code>0</code>）。</p><ul><li><p><code>year</code></p><p>表示年份的整数值。 0到99会被映射至1900年至1999年，其它值代表实际年份。参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B0%86%E4%B8%A4%E4%BD%8D%E6%95%B0%E5%B9%B4%E4%BB%BD%E6%98%A0%E5%B0%84%E4%B8%BA_1900_-_1999_%E5%B9%B4">示例</a>。</p></li><li><p><code>monthIndex</code></p><p>表示月份的整数值，从 0（1月）到 11（12月）。</p></li><li><p>date可选</p><p>表示一个月中的第几天的整数值，从1开始。默认值为1。</p></li><li><p><code>hours</code> 可选</p><p>表示一天中的小时数的整数值 (24小时制)。默认值为0（午夜）。</p></li><li><p><code>minutes</code> 可选</p><p>表示一个完整时间（如 01:10:00）中的分钟部分的整数值。默认值为0。</p></li><li><p><code>seconds</code> 可选</p><p>表示一个完整时间（如 01:10:00）中的秒部分的整数值。默认值为0。</p></li><li><p><code>milliseconds</code> 可选</p><p>表示一个完整时间的毫秒部分的整数值。默认值为0。</p></li></ul><h2 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A">使用注释</a></h2><p><strong>备注：</strong>参数<code>monthIndex</code> 是从“0”开始计算的，这就意味着一月份为“0”，十二月份为“11”。</p><p><strong>备注：</strong>当Date作为构造函数调用并传入多个参数时，如果数值大于合理范围时（如月份为 13 或者分钟数为 70），相邻的数值会被调整。比如 new Date(2013, 13, 1)等于new Date(2014, 1, 1)，它们都表示日期2014-02-01（注意月份是从0开始的）。其他数值也是类似，new Date(2013, 2, 1, 0, 70)等于new Date(2013, 2, 1, 1, 10)，都表示同一个时间：<code>2013-03-01T01:10:00</code>。</p><p><strong>备注：</strong>当Date作为构造函数调用并传入多个参数时，所定义参数代表的是当地时间。如果需要使用世界协调时 UTC，使用 <code>new Date(Date.UTC(...))</code> 和相同参数。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E7%AE%80%E4%BB%8B">简介</a></h2><ul><li>如果没有输入任何参数，则Date的构造器会依据系统设置的当前时间来创建一个Date对象。</li><li>如果提供了至少两个参数，其余的参数均会默认设置为 1（如果没有指定 day 参数）或者 0（如果没有指定 day 以外的参数）。</li><li>JavaScript的时间由世界标准时间（UTC）1970年1月1日开始，用毫秒计时，一天由 86,400,000 毫秒组成。<code>Date</code> 对象的范围是 -100,000,000 天至 100,000,000 天（等效的毫秒值）。</li><li><code>Date</code> 对象为跨平台提供了统一的行为。时间属性可以在不同的系统中表示相同的时刻，而如果使用了本地时间对象，则反映当地的时间。</li><li><code>Date</code> 对象支持多个处理 UTC 时间的方法，也相应地提供了应对当地时间的方法。UTC，也就是我们所说的格林威治时间，指的是time中的世界时间标准。而当地时间则是指执行JavaScript的客户端电脑所设置的时间。</li><li>以一个函数的形式来调用 <code>Date</code> 对象（即不使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a> 操作符）会返回一个代表当前日期和时间的字符串。</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E5%B1%9E%E6%80%A7">属性</a></h2><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date.prototype</code> (en-US)</a></p><p>允许为 <code>Date</code> 对象添加属性。</p></li><li><p><code>Date.length</code></p><p><code>Date.length</code> 的值是 7。这是该构造函数可接受的参数个数。</p></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E6%96%B9%E6%B3%95">方法</a></h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/now"><code>Date.now()</code></a></p><p>返回自 1970-1-1 00:00:00  UTC（世界标准时间）至今所经过的毫秒数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse"><code>Date.parse()</code></a></p><p>解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。<strong>备注：</strong> 由于浏览器差异和不一致，强烈建议不要使用<code>Date.parse</code>解析字符串。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC"><code>Date.UTC()</code></a></p><p>接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。</p></li></ul><h2 id="JavaScript-Date-实例"><a href="#JavaScript-Date-实例" class="headerlink" title="JavaScript Date 实例"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#javascript_date_%E5%AE%9E%E4%BE%8B">JavaScript <code>Date</code> 实例</a></h2><p>所有的 <code>Date</code> 实例都继承自 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date.prototype</code> (en-US)</a>。修改 <code>Date </code>构造函数的原型对象会影响到所有的 <code>Date</code> 实例。</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">实例属性</a></h3><ul><li><p><code>Date.prototype.constructor</code></p><p>返回创建了实例的构造函数，默认是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 构造函数。</p></li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a></h3><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate"><code>Date.prototype.getDate()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象为一个月中的哪一日（<code>1</code>-<code>31</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay"><code>Date.prototype.getDay()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象是在一周中的第几天（<code>0</code>-<code>6</code>），0 表示星期天。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear"><code>Date.prototype.getFullYear()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的完整年份（四位数年份）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours"><code>Date.prototype.getHours()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的小时（<code>0</code>–<code>23</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds"><code>Date.prototype.getMilliseconds()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的毫秒数（<code>0</code>–<code>999</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes"><code>Date.prototype.getMinutes()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的分钟数（<code>0</code>–<code>59</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth"><code>Date.prototype.getMonth()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的月份（<code>0</code>–<code>11</code>），0 表示一年中的第一月。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds"><code>Date.prototype.getSeconds()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的秒数（<code>0</code>–<code>59</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime"><code>Date.prototype.getTime()</code></a></p><p>返回一个数值，表示从 1970 年 1 月 1 日 0 时 0 分 0 秒（UTC，即协调世界时）距离该 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象所代表时间的毫秒数。（更早的时间会用负数表示）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset"><code>Date.prototype.getTimezoneOffset()</code></a></p><p>返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDate"><code>Date.prototype.getUTCDate()</code></a></p><p>以协调世界时为标准，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象为一个月中的哪一日（<code>1</code>-<code>31</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDay"><code>Date.prototype.getUTCDay()</code></a></p><p>以协调世界时为标准，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象是在一周中的第几天（<code>0</code>-<code>6</code>），0 表示星期天。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear"><code>Date.prototype.getUTCFullYear()</code></a></p><p>以协调世界时为标准，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的完整年份（四位数年份）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCHours"><code>Date.prototype.getUTCHours()</code></a></p><p>以协调世界时为标准，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的小时（<code>0</code>–<code>23</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMilliseconds"><code>Date.prototype.getUTCMilliseconds()</code></a></p><p>以协调世界时为标准，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的毫秒数（<code>0</code>–<code>999</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMinutes"><code>Date.prototype.getUTCMinutes()</code></a></p><p>以协调世界时为标准，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的分钟数（<code>0</code>–<code>59</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMonth"><code>Date.prototype.getUTCMonth()</code></a></p><p>以协调世界时为标准，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的月份（<code>0</code>–<code>11</code>），0 表示一年中的第一月。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCSeconds"><code>Date.prototype.getUTCSeconds()</code></a></p><p>以协调世界时为标准，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的秒数（<code>0</code>–<code>59</code>）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getYear"><code>Date.prototype.getYear()</code></a></p><p>根据本地时间，返回一个指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的相对年份（相对1900年，通常是 2 到 3 位数字）。请改用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear"><code>getFullYear</code></a> 。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate"><code>Date.prototype.setDate()</code></a></p><p>根据本地时间，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象在所属月份中的天数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear"><code>Date.prototype.setFullYear()</code></a></p><p>根据本地时间，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的完整年份（四位数年份）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours"><code>Date.prototype.setHours()</code></a></p><p>根据本地时间，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的小时数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds"><code>Date.prototype.setMilliseconds()</code></a></p><p>根据本地时间，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的豪秒数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes"><code>Date.prototype.setMinutes()</code></a></p><p>根据本地时间，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的分钟数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth"><code>Date.prototype.setMonth()</code></a></p><p>根据本地时间，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的月份。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds"><code>Date.prototype.setSeconds()</code></a></p><p>根据本地时间，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的秒数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime"><code>Date.prototype.setTime()</code></a></p><p>用一个从1970-1-1 00:00:00 UTC计时的毫秒数来为一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象设置时间。用负数来设置更早的时间。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setUTCDate"><code>Date.prototype.setUTCDate()</code></a></p><p>以协调世界时为标准，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象在所属月份中的天数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setUTCFullYear"><code>Date.prototype.setUTCFullYear()</code></a></p><p>以协调世界时为标准，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的完整年份（四位数年份）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setUTCHours"><code>Date.prototype.setUTCHours()</code></a></p><p>以协调世界时为标准，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的小时数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setUTCMilliseconds"><code>Date.prototype.setUTCMilliseconds()</code></a></p><p>以协调世界时为标准，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的豪秒数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setUTCMinutes"><code>Date.prototype.setUTCMinutes()</code></a></p><p>以协调世界时为标准，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的分钟数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setUTCMonth"><code>Date.prototype.setUTCMonth()</code></a></p><p>以协调世界时为标准，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的月份。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setUTCSeconds"><code>Date.prototype.setUTCSeconds()</code></a></p><p>以协调世界时为标准，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的秒数。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setYear"><code>Date.prototype.setYear()</code></a></p><p>根据本地时间，设置一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的相对年份（相对1900年，通常是 2 到 3 位数字）。请改用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear"><code>setFullYear</code></a> 。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toDateString"><code>Date.prototype.toDateString()</code></a></p><p>以美式英语和人类易读的表述形式返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象日期部分的字符串。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString"><code>Date.prototype.toISOString()</code></a></p><p>将指定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象转换成 ISO 格式表述的字符串并返回。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON"><code>Date.prototype.toJSON()</code></a></p><p>返回指定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString"><code>toISOString()</code></a> 方法的返回值。在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> 中使用。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString"><code>Date.prototype.toGMTString()</code></a></p><p>基于 GMT (UTC) 时区来返回一个表述指定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的字符串形式。请改用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString"><code>toUTCString()</code></a>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleDateString"><code>Date.prototype.toLocaleDateString()</code></a></p><p>返回一个表述指定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的日期部分字符串。该字符串格式因不同语言而不同。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString"><code>Date.prototype.toLocaleString()</code></a></p><p>返回一个表述指定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的字符串。该字符串格式因不同语言而不同。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString"><code>Date.prototype.toLocaleTimeString()</code></a></p><p>返回一个表述指定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象时间部分的的字符串。该字符串格式因不同语言而不同。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toString"><code>Date.prototype.toString()</code></a></p><p>返回一个字符串，表示该 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象。覆盖了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a> 方法。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toTimeString"><code>Date.prototype.toTimeString()</code></a></p><p>以人类易读形式返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象时间部分的字符串，该字符串以美式英语格式化。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString"><code>Date.prototype.toUTCString()</code></a></p><p>使用UTC时区，把一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象转换为一个字符串。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/valueOf"><code>Date.prototype.valueOf()</code></a></p><p>返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a> 对象的原始值。覆盖了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a> 方法。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E4%BE%8B%E5%AD%90">例子</a></h2><h3 id="例子：创建一个日期对象的几种方法"><a href="#例子：创建一个日期对象的几种方法" class="headerlink" title="例子：创建一个日期对象的几种方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%3E%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95">例子：创建一个日期对象的几种方法</a></h3><p>下例展示了用来创建一个日期对象的多种方法。</p><p><strong>备注：</strong> 由于浏览器差异和不一致性，强烈建议不要使用<code>Date</code>构造函数（和<code>Date.parse</code>，它们是等效的）解析日期字符串。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> today = new Date();<span class="hljs-attribute">var</span> birthday = new Date(&#x27;December <span class="hljs-number">17</span>, <span class="hljs-number">1995</span> <span class="hljs-number">03</span>:<span class="hljs-number">24</span>:<span class="hljs-number">00</span>&#x27;);<span class="hljs-attribute">var</span> birthday = new Date(&#x27;<span class="hljs-number">1995</span>-<span class="hljs-number">12</span>-<span class="hljs-number">17</span>T03:<span class="hljs-number">24</span>:<span class="hljs-number">00</span>&#x27;);<span class="hljs-attribute">var</span> birthday = new Date(<span class="hljs-number">1995</span>, <span class="hljs-number">11</span>, <span class="hljs-number">17</span>);<span class="hljs-attribute">var</span> birthday = new Date(<span class="hljs-number">1995</span>, <span class="hljs-number">11</span>, <span class="hljs-number">17</span>, <span class="hljs-number">3</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);</code></pre></div><p>Copy to Clipboard</p><h3 id="例子：将两位数年份映射为-1900-1999-年"><a href="#例子：将两位数年份映射为-1900-1999-年" class="headerlink" title="例子：将两位数年份映射为 1900 - 1999 年"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B0%86%E4%B8%A4%E4%BD%8D%E6%95%B0%E5%B9%B4%E4%BB%BD%E6%98%A0%E5%B0%84%E4%B8%BA_1900_-_1999_%E5%B9%B4">例子：将两位数年份映射为 1900 - 1999 年</a></h3><p>为了创建和获取 0 到 99 之间的年份，应使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear"><code>Date.prototype.setFullYear()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear"><code>Date.prototype.getFullYear()</code></a> 方法。</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">98</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)</span><span class="hljs-comment">// 已弃用的方法, 同样将 98 映射为 1998</span><span class="hljs-built_in">date</span>.setYear(<span class="hljs-number">98</span>);           <span class="hljs-comment">// Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)</span><span class="hljs-built_in">date</span>.setFullYear(<span class="hljs-number">98</span>);       <span class="hljs-comment">// Sat Feb 01 0098 00:00:00 GMT+0000 (BST)</span></code></pre></div><p>Copy to Clipboard</p><h3 id="例子：计算经过的时间"><a href="#例子：计算经过的时间" class="headerlink" title="例子：计算经过的时间"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E4%BE%8B%E5%AD%90%EF%BC%9A%E8%AE%A1%E7%AE%97%E7%BB%8F%E8%BF%87%E7%9A%84%E6%97%B6%E9%97%B4">例子：计算经过的时间</a></h3><p>下例展示了如何以毫秒精度计算两个日期对象的时间差：</p><p>由于不同日期、月份、年份长度的不同（日期长度不同来自夏令时的切换），使用大于秒、分钟、小时的单位表示经过的时间会遇到很多问题，在使用前需要经过详尽的调研。</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-comment">// 使用 Date 对象</span><span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>();<span class="hljs-comment">// 调用一个消耗一定时间的方法：</span>doSomethingForALongTime();<span class="hljs-keyword">var</span> end = <span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>();<span class="hljs-keyword">var</span> elapsed = end - start; <span class="hljs-comment">// 以毫秒计的运行时长</span></code></pre></div><p>Copy to Clipboard</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 使用内建的创建方法</span>var start = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>;<span class="hljs-comment">// 调用一个消耗一定时间的方法：</span><span class="hljs-keyword">do</span><span class="hljs-constructor">SomethingForALongTime()</span>;var <span class="hljs-keyword">end</span> = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>;var elapsed = <span class="hljs-keyword">end</span>.get<span class="hljs-constructor">Time()</span> - start.get<span class="hljs-constructor">Time()</span>; <span class="hljs-comment">// 运行时间的毫秒值</span></code></pre></div><p>Copy to Clipboard</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// to test a function and get back its return</span><span class="hljs-keyword">function</span> printElapsedTime (fTest) &#123;    var nStartTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Date</span>.</span></span>now<span class="hljs-literal">()</span>,        vReturn = f<span class="hljs-constructor">Test()</span>,        nEndTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Date</span>.</span></span>now<span class="hljs-literal">()</span>;    alert(<span class="hljs-string">&quot;Elapsed time: &quot;</span> + <span class="hljs-constructor">String(<span class="hljs-params">nEndTime</span> - <span class="hljs-params">nStartTime</span>)</span> + <span class="hljs-string">&quot; milliseconds&quot;</span>);    return vReturn;&#125;yourFunctionReturn = print<span class="hljs-constructor">ElapsedTime(<span class="hljs-params">yourFunction</span>)</span>;</code></pre></div><p>Copy to Clipboard</p><p><strong>备注：</strong>在支持 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/performance_property"><code>Web Performance API</code></a> 的高精细度（high-resolution）时间功能的浏览器中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now"><code>Performance.now()</code></a> 提供的所经过的时间比 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/now"><code>Date.now()</code></a> 更加可靠、精确。</p><h3 id="获取自-Unix-起始时间以来经过的秒数"><a href="#获取自-Unix-起始时间以来经过的秒数" class="headerlink" title="获取自 Unix 起始时间以来经过的秒数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E8%8E%B7%E5%8F%96%E8%87%AA_unix_%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4%E4%BB%A5%E6%9D%A5%E7%BB%8F%E8%BF%87%E7%9A%84%E7%A7%92%E6%95%B0">获取自 Unix 起始时间以来经过的秒数</a></h3><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> seconds = Math.<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>() / <span class="hljs-number">1000</span>);</code></pre></div><p>Copy to Clipboard</p><p>注意此处需要返回一个整数 （仅做除法得到的不是整数），并且需要返回实际已经经过的秒数（所以这里使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/floor"><code>Math.floor()</code></a>而不是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/round"><code>Math.round()</code></a>).</p><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date</a></p><h1 id="2-RegExp-正则表达式"><a href="#2-RegExp-正则表达式" class="headerlink" title="2 RegExp(正则表达式)"></a>2 RegExp(正则表达式)</h1><p><strong><code>RegExp</code></strong> 对象用于将文本与一个模式匹配。</p><p>有关正则表达式的介绍，请阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/">JavaScript指南</a>中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式章节</a>。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E6%8F%8F%E8%BF%B0">描述</a></h2><h3 id="字面量和构造函数"><a href="#字面量和构造函数" class="headerlink" title="字面量和构造函数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">字面量和构造函数</a></h3><p>有两种方法可以创建一个 <code>RegExp</code> 对象：一种是字面量，另一种是构造函数。</p><ul><li><p>字面量</p><p>由斜杠(&#x2F;)包围而不是引号包围。</p></li><li><p>构造函数的字符串参数</p><p>由引号而不是斜杠包围。</p></li></ul><p>以下三种表达式都会创建相同的正则表达式：</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/ab+c/i</span>; <span class="hljs-regexp">//</span>字面量形式new RegExp(<span class="hljs-string">&#x27;ab+c&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>); <span class="hljs-regexp">//</span> 首个参数为字符串模式的构造函数new RegExp(<span class="hljs-regexp">/ab+c/</span>, <span class="hljs-string">&#x27;i&#x27;</span>); <span class="hljs-regexp">//</span> 首个参数为常规字面量的构造函数</code></pre></div><p>Copy to Clipboard</p><p>当表达式被赋值时，字面量形式提供正则表达式的编译（compilation）状态，当正则表达式保持为常量时使用字面量。例如当你在循环中使用字面量构造一个正则表达式时，正则表达式不会在每一次迭代中都被重新编译（recompiled）。</p><p>而正则表达式对象的构造函数，如 <code>new RegExp(&#39;ab+c&#39;)</code> 提供了正则表达式运行时编译（runtime compilation）。如果你知道正则表达式模式将会改变，或者你事先不知道什么模式，而是从另一个来源获取，如用户输入，这些情况都可以使用构造函数。</p><h3 id="构造函数中的标志参数-flags"><a href="#构造函数中的标志参数-flags" class="headerlink" title="构造函数中的标志参数(flags)"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%A0%87%E5%BF%97%E5%8F%82%E6%95%B0flags">构造函数中的标志参数(flags)</a></h3><p>从 ECMAScript 6 开始，当第一个参数为正则表达式而第二个标志参数存在时，<code>new RegExp(/ab+c/, &#39;i&#39;)</code> 不再抛出 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a> （<code>&quot;从另一个RegExp构造一个RegExp时无法提供标志&quot;</code>）的异常，取而代之，将使用这些参数创建一个新的正则表达式。</p><p>当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 <code>\</code>）。</p><p>比如，以下是等价的：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;\\w+&quot;</span>);<span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/\w+/</span>;</code></pre></div><p>Copy to Clipboard</p><h3 id="Perl-like-RegExp-属性"><a href="#Perl-like-RegExp-属性" class="headerlink" title="Perl-like RegExp 属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#perl-like_regexp_%E5%B1%9E%E6%80%A7">Perl-like RegExp 属性</a></h3><p>请注意，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a>属性有长名称和短名称（类似Perl）。两个名称总是引用同一个值。（Perl是JavaScript为其正则表达式建模的编程语言）。另请参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features#regexp_properties">不推荐使用的RegExp属性。</a></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp"><code>RegExp()</code></a></p><p>创建一个新的 <code>RegExp</code> 对象。</p></li></ul><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7">静态属性</a></h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@species"><code>get RegExp[@@species]</code></a></p><p>该构造函数用于创建派生对象。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>RegExp.lastIndex</code></a></p><p>该索引表示从哪里开始下一个匹配</p></li></ul><h2 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">实例属性</a></h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/flags"><code>RegExp.prototype.flags</code></a></p><p>含有 <code>RegExp</code> 对象 flags 的字符串。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll"><code>RegExp.prototype.dotAll</code></a></p><p><code>.</code> 是否要匹配新行（newlines）。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global"><code>RegExp.prototype.global</code></a></p><p>针对字符串中所有可能的匹配项测试正则表达式，还是仅针对第一个匹配项。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/ignoreCase"><code>RegExp.prototype.ignoreCase</code></a></p><p>匹配文本的时候是否忽略大小写。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline"><code>RegExp.prototype.multiline</code></a></p><p>是否进行多行搜索。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/source"><code>RegExp.prototype.source</code></a></p><p>正则表达式的文本。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky"><code>RegExp.prototype.sticky</code></a></p><p>搜索是否是 sticky。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode"><code>RegExp.prototype.unicode</code></a></p><p>Unicode 功能是否开启。</p></li></ul><h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a></h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/compile"><code>RegExp.prototype.compile()</code></a></p><p>运行脚本的期间（重新）编译正则表达式。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>RegExp.prototype.exec()</code></a></p><p>在该字符串中执行匹配项的搜索。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>RegExp.prototype.test()</code></a></p><p>该正则在字符串里是否有匹配。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@match"><code>RegExp.prototype[@@match]()</code></a></p><p>对给定字符串执行匹配并返回匹配结果。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@matchAll"><code>RegExp.prototype[@@matchAll]()</code></a></p><p>对给定字符串执行匹配，返回所有匹配结果。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@replace"><code>RegExp.prototype[@@replace]()</code></a></p><p>给定新的子串，替换所有匹配结果。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@search"><code>RegExp.prototype[@@search]()</code></a></p><p>在给定字符串中搜索匹配项，并返回在字符串中找到字符索引。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@split"><code>RegExp.prototype[@@split]()</code></a></p><p>通过将给定字符串拆分为子字符串，并返回字符串形成的数组。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/toString"><code>RegExp.prototype.toString()</code></a></p><p>返回表示指定对象的字符串。重写<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a>方法。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#syntax">示例</a></h2><h3 id="使用正则改变数据结构"><a href="#使用正则改变数据结构" class="headerlink" title="使用正则改变数据结构"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#using_a_regular_expression_to_change_data_format">使用正则改变数据结构</a></h3><p>下例使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace()</code></a> 方法去匹配姓名 <em>first last</em> 输出新的格式 <em>last</em>, <em>first</em>。</p><p>在替换的文本中，脚本中使用 <code>$1</code> 和 <code>$2</code> 指明括号里先前的匹配.</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/(\w+)\s(\w+)/</span>;<span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;John Smith&quot;</span>;<span class="hljs-keyword">let</span> newstr = str.<span class="hljs-title function_">replace</span>(re, <span class="hljs-string">&quot;$2, $1&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newstr);</code></pre></div><p>Copy to Clipboard</p><p>这将显示 “Smith, John”.</p><h3 id="使用正则来划分带有多种行结束符和换行符的文本"><a href="#使用正则来划分带有多种行结束符和换行符的文本" class="headerlink" title="使用正则来划分带有多种行结束符和换行符的文本"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E6%9D%A5%E5%88%92%E5%88%86%E5%B8%A6%E6%9C%89%E5%A4%9A%E7%A7%8D%E8%A1%8C%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%92%8C%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E6%96%87%E6%9C%AC">使用正则来划分带有多种行结束符和换行符的文本</a></h3><p>对于不同的平台（Unix，Windows等等），其默认的行结束符是不一样的. 而下面的划分方式适用于所有平台。</p><div class="code-wrapper"><pre><code class="hljs vhdl">let <span class="hljs-literal">text</span> = <span class="hljs-symbol">&#x27;Some</span> <span class="hljs-literal">text</span>\<span class="hljs-keyword">nAnd</span> some more\r\<span class="hljs-keyword">nAnd</span> yet\rThis <span class="hljs-keyword">is</span> the <span class="hljs-keyword">end</span>&#x27;let lines = <span class="hljs-literal">text</span>.split(/\r\n|\r|\n/)console.log(lines) // logs [ <span class="hljs-symbol">&#x27;Some</span> <span class="hljs-literal">text</span>&#x27;, <span class="hljs-symbol">&#x27;And</span> some more&#x27;, <span class="hljs-symbol">&#x27;And</span> yet&#x27;, <span class="hljs-symbol">&#x27;This</span> <span class="hljs-keyword">is</span> the <span class="hljs-keyword">end</span>&#x27; ]</code></pre></div><p>注意：在正则表达式中，以竖线分割的子模式的顺序会影响匹配结果。</p><h3 id="在多行文本中使用正则表达式"><a href="#在多行文本中使用正则表达式" class="headerlink" title="在多行文本中使用正则表达式"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E5%9C%A8%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">在多行文本中使用正则表达式</a></h3><div class="code-wrapper"><pre><code class="hljs awk">let s = <span class="hljs-string">&quot;Please yes\nmake my day!&quot;</span>;s.match(<span class="hljs-regexp">/yes.*day/</span>);<span class="hljs-regexp">//</span> Returns nulls.match(<span class="hljs-regexp">/yes[^]*day/</span>);<span class="hljs-regexp">//</span> Returns <span class="hljs-string">&#x27;yes\nmake my day&#x27;</span></code></pre></div><p>Copy to Clipboard</p><h3 id="使用带有-sticky-标志的正则表达式"><a href="#使用带有-sticky-标志的正则表达式" class="headerlink" title="使用带有 sticky 标志的正则表达式"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#using_a_regular_expression_with_the_sticky_flag">使用带有 sticky 标志的正则表达式</a></h3><p>带有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky"><code>sticky</code></a>标志的正则表达式将会从源字符串的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>RegExp.prototype.lastIndex</code></a>位置开始匹配，也就是进行“粘性匹配”。</p><div class="code-wrapper"><pre><code class="hljs stylus">let str = <span class="hljs-string">&#x27;#foo#&#x27;</span>let regex = /foo/yregex<span class="hljs-selector-class">.lastIndex</span> = <span class="hljs-number">1</span>regex<span class="hljs-selector-class">.test</span>(str)      <span class="hljs-comment">// true</span>regex<span class="hljs-selector-class">.lastIndex</span> = <span class="hljs-number">5</span>regex<span class="hljs-selector-class">.test</span>(str)      <span class="hljs-comment">// false (lastIndex is taken into account with sticky flag)</span>regex<span class="hljs-selector-class">.lastIndex</span>      <span class="hljs-comment">// 0 (reset after match failure)</span></code></pre></div><p>Copy to Clipboard</p><h3 id="sticky-标志和-global-标志的不同点"><a href="#sticky-标志和-global-标志的不同点" class="headerlink" title=" sticky 标志和 global 标志的不同点"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#sticky_%E6%A0%87%E5%BF%97%E5%92%8C_global_%E6%A0%87%E5%BF%97%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9"> sticky 标志和 global 标志的不同点</a></h3><p>如果正则表达式有粘性 <code>y</code> 标志，下一次匹配一定在 <code>lastIndex</code> 位置开始；如果正则表达式有全局 <code>g</code> 标志，下一次匹配可能在 <code>lastIndex</code> 位置开始，也可能在这个位置的后面开始。</p><div class="code-wrapper"><pre><code class="hljs awk">re = <span class="hljs-regexp">/\d/y</span>;<span class="hljs-keyword">while</span> (r = re.exec(<span class="hljs-string">&quot;123 456&quot;</span>)) console.log(r, <span class="hljs-string">&quot;AND re.lastIndex&quot;</span>, re.lastIndex);<span class="hljs-regexp">//</span> [ <span class="hljs-string">&#x27;1&#x27;</span>, index: <span class="hljs-number">0</span>, input: <span class="hljs-string">&#x27;123 456&#x27;</span>, groups: undefined ] AND re.lastIndex <span class="hljs-number">1</span><span class="hljs-regexp">//</span> [ <span class="hljs-string">&#x27;2&#x27;</span>, index: <span class="hljs-number">1</span>, input: <span class="hljs-string">&#x27;123 456&#x27;</span>, groups: undefined ] AND re.lastIndex <span class="hljs-number">2</span><span class="hljs-regexp">//</span> [ <span class="hljs-string">&#x27;3&#x27;</span>, index: <span class="hljs-number">2</span>, input: <span class="hljs-string">&#x27;123 456&#x27;</span>, groups: undefined ] AND re.lastIndex <span class="hljs-number">3</span><span class="hljs-regexp">//</span>   ... and no more match.</code></pre></div><p>Copy to Clipboard</p><p>如果使用带有全局标志<code>g</code>的正则表达式<code>re</code>，就会捕获字符串中的所有6个数字，而非3个</p><h3 id="使用正则表达式和-Unicode-字符"><a href="#使用正则表达式和-Unicode-字符" class="headerlink" title="使用正则表达式和 Unicode 字符"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#browser_compatibility">使用正则表达式和 Unicode 字符</a></h3><p>正如上面表格提到的，<code>\w</code> 或 <code>\W</code> 只会匹配基本的 ASCII 字符；如 <code>a</code> 到 <code>z</code>、 <code>A</code> 到 <code>Z</code>、 <code>0</code> 到 <code>9</code> 及 <code>_</code>。</p><p>为了匹配其他语言中的字符，如西里尔（Cyrillic）或 希伯来语（Hebrew），要使用 <code>\uhhhh</code>，<code>hhhh</code> 表示以十六进制表示的字符的 Unicode 值。</p><p>下例展示了怎样从一个单词中分离出 Unicode 字符。</p><div class="code-wrapper"><pre><code class="hljs arcade">let <span class="hljs-built_in">text</span> = <span class="hljs-string">&quot;Образец text на русском языке&quot;</span>;let regex = <span class="hljs-regexp">/[\u0400-\u04FF]+/g</span>;let match = regex.exec(<span class="hljs-built_in">text</span>);<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(match[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// prints &quot;Образец&quot;</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(regex.lastIndex);  <span class="hljs-comment">// prints &quot;7&quot;</span>let match2 = regex.exec(<span class="hljs-built_in">text</span>);<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(match2[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// prints &quot;на&quot; [did not print &quot;text&quot;]</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(regex.lastIndex);  <span class="hljs-comment">// prints &quot;15&quot;</span><span class="hljs-comment">// and so on</span></code></pre></div><p>Copy to Clipboard</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes">Unicode属性转义特性</a>引入了一种解决方案，它允许使用像\p{scx&#x3D;Cyrl}这样简单的语句。这里有一个外部资源，用来获取 Unicode 中的不同区块范围：<a href="http://kourge.net/projects/regexp-unicode-block">Regexp-unicode-block</a></p><h3 id="从-URL-中提取子域名"><a href="#从-URL-中提取子域名" class="headerlink" title="从 URL 中提取子域名"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#%E4%BB%8E_url_%E4%B8%AD%E6%8F%90%E5%8F%96%E5%AD%90%E5%9F%9F%E5%90%8D">从 URL 中提取子域名</a></h3><div class="code-wrapper"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> <span class="hljs-built_in">url</span> = <span class="hljs-string">&quot;http://xxx.domain.com&quot;</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/[^.]+/</span>.exec(<span class="hljs-built_in">url</span>)[<span class="hljs-number">0</span>].substr(<span class="hljs-number">7</span>)); <span class="hljs-comment">// logs &quot;xxx&quot;</span></code></pre></div><p>Copy to Clipboard</p><p><strong>备注：</strong>使用浏览器内建的<a href="https://developer.mozilla.org/en-US/docs/Web/API/URL_API">URL API</a>而非正则表达式来解析URL是更好的做法</p><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】7.变量、作用域</title>
    <link href="/archives/271687d2.html"/>
    <url>/archives/271687d2.html</url>
    
    <content type="html"><![CDATA[<h1 id="变量、作用域"><a href="#变量、作用域" class="headerlink" title="变量、作用域"></a>变量、作用域</h1><h2 id="1-原始值和引用值"><a href="#1-原始值和引用值" class="headerlink" title="1 原始值和引用值"></a>1 原始值和引用值</h2><p>原始值：Undefined、Null、Boolean、Number、BigInt、String 和 Symbol 值。</p><p>引用值：Object 对象值。</p><p>保存原始值的变量是<strong>按值访问</strong>的，保存引用值的变量是<strong>按引用访问</strong>的。</p><h3 id="1-1-动态属性"><a href="#1-1-动态属性" class="headerlink" title="1.1 动态属性"></a>1.1 动态属性</h3><p>对于引用值，可以随时添加、修改和删除其属性和方法。原始值不能拥有属性，尽管给原始值添加属性不会报错。</p><h3 id="1-2-复制值"><a href="#1-2-复制值" class="headerlink" title="1.2 复制值"></a>1.2 复制值</h3><p>复制原始值时，原始值会被复制到新变量的位置。</p><p>复制引用值时，储存在变量中的值也会被复制到新变量所在的位置，只不过这里的值是对象的引用。因此，在一个对象上面发生的变化也会在另一个对象上表现出来。</p><h3 id="1-3-传递参数"><a href="#1-3-传递参数" class="headerlink" title="1.3 传递参数"></a>1.3 传递参数</h3><h4 id="1-3-1-按值传参和按引用传参的区别"><a href="#1-3-1-按值传参和按引用传参的区别" class="headerlink" title="1.3.1 按值传参和按引用传参的区别"></a>1.3.1 按值传参和按引用传参的区别</h4><ol><li><p>按值传参：值会被复制到一个局部变量。C++ 例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;a = <span class="hljs-number">200</span>; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-built_in">fn</span>(a);cout&lt;&lt;a&lt;&lt;endl;<span class="hljs-comment">// 1</span>&#125;</code></pre></div></li><li><p>按引用传参：值在内存中的位置会被复制到一个局部变量。这意味着，对本地变量的修改会反映到函数的外部。C++ 例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;a = <span class="hljs-number">200</span>; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-built_in">fn</span>(a);cout&lt;&lt;a&lt;&lt;endl;<span class="hljs-comment">// 200</span>&#125;</code></pre></div></li></ol><h4 id="1-3-2-JavaScript-中按值传参"><a href="#1-3-2-JavaScript-中按值传参" class="headerlink" title="1.3.2 JavaScript 中按值传参"></a>1.3.2 JavaScript 中按值传参</h4><p><strong>ECMAScript 中所有函数的参数都是按值传递的</strong>。<strong>变量有按值访问和按引用访问，但是传参只有按值访问</strong>。</p><p>传递原始值时，看上去比较明显：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a</span>) &#123;    a = <span class="hljs-number">2</span>;&#125;<span class="hljs-title function_">fn</span>(a);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);   <span class="hljs-comment">// 1</span></code></pre></div><p>传递的是对象的话：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">o</span>) &#123;    o.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;&#125;<span class="hljs-title function_">fn</span>(obj);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>);<span class="hljs-comment">// 2</span></code></pre></div><p>我们创建了一个对象并保存在<code>obj</code>变量中。然后这个变量被传递给<code>fn()</code> 函数，并被复制到参数<code>o</code>中。在函数内部，<code>obj</code>和<code>o</code>都指向同一个对象。因此<code>o</code>对对象的改变也会反应到<code>obj</code>上。</p><p>并不是说，只要当局部作用域中修改对象而变化反应到全局时，就意味着参数是按引用传递的。为证明 ECMAScript 中，<strong>对象是按值传递</strong>的，看下面的例子：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">o</span>) &#123;    o.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;    o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();    o.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>;&#125;<span class="hljs-title function_">fn</span>(obj);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>);<span class="hljs-comment">// 2</span></code></pre></div><p>如果是按引用传递， <code>obj.a</code>最后结果应该是 3 而不是 2。这表明函数参数的值改变后，原始的引用仍没有改变。当<code>o</code>在函数内部被重写时，它变成了指向本地对象的指针，随后在函数执行结束时销毁。</p><h3 id="1-4-确定类型"><a href="#1-4-确定类型" class="headerlink" title="1.4 确定类型"></a>1.4 确定类型</h3><h4 id="1-4-1-typeof-操作符"><a href="#1-4-1-typeof-操作符" class="headerlink" title="1.4.1 typeof 操作符"></a>1.4.1 typeof 操作符</h4><p>适合用来判断字符串、数值、布尔值、undefined。如果值是对象或者 null，那么都会返回<code>&quot;object&quot;</code>（如果是函数则返回<code>&quot;function&quot;</code>）。</p><h4 id="1-4-2-instanceof-操作符"><a href="#1-4-2-instanceof-操作符" class="headerlink" title="1.4.2 instanceof 操作符"></a>1.4.2 instanceof 操作符</h4><p>如果变量是给定引用类型的实例则 instanceof 操作符返回 true。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span></code></pre></div><p>注意：</p><ol><li>所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测引用值和 Object 构造函数都返回 true。</li><li>如果使用 instanceof 检测原始值，则始终返回 false。</li></ol><h2 id="2-执行上下文和作用域"><a href="#2-执行上下文和作用域" class="headerlink" title="2 执行上下文和作用域"></a>2 执行上下文和作用域</h2><p>执行上下文简称<strong>上下文</strong>，变量和函数的上下文决定了它们可以访问哪些数据，以及它们的行为。</p><ol><li>全局上下文就是最外层的上下文。宿主不一样，全局上下文可能不一样。每个上下文都有一个<strong>变量对象</strong>，上下文中所有的变量都存在这个对象身上。</li><li>在浏览器中，全局上下文是 window 对象。在全局作用域中，使用 var 定义的变量和函数都会成为 window 对象身上的属性，而 const 和 let 不会，但是在作用域链中的解析是一样的。</li><li>上下文在代码执行完毕后会被销毁。包括里面定义的变量和函数。</li><li>每个函数都有自己的上下文，函数参数被当作上下文中的变量。</li><li>上下文代码执行时，会创建变量对象的<strong>作用域链</strong>。作用域链决定了各级上下文代码在访问变量和函数时的顺序。代码执行时的标识符解析是通过沿着作用域链<strong>逐级搜索</strong>标识符完成的。</li></ol><h3 id="2-1-作用域链增强"><a href="#2-1-作用域链增强" class="headerlink" title="2.1 作用域链增强"></a>2.1 作用域链增强</h3><p>有其它方式来增强作用域链。某些语句会导致作用域链前端临时加上一个上下文：</p><ol><li>try&#x2F;catch 语句的 catch 块。catch 语句会创建一个新的<strong>变量对象</strong>，包含要抛出的错误对象的声明。</li><li>with 语句。向作用域前端添加指定的对象。</li></ol><h3 id="2-2-变量声明"><a href="#2-2-变量声明" class="headerlink" title="2.2 变量声明"></a>2.2 变量声明</h3><h4 id="2-3-1-使用-var-的函数作用域声明"><a href="#2-3-1-使用-var-的函数作用域声明" class="headerlink" title="2.3.1 使用 var 的函数作用域声明"></a>2.3.1 使用 var 的函数作用域声明</h4><ol><li><p>使用 var 声明变量时，变量会自动加到最接近的上下文中（而不是全局上下文）。</p></li><li><p>在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1, num2</span>) &#123;<span class="hljs-keyword">var</span> sum = num1 + num2;<span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<span class="hljs-comment">// 报错</span></code></pre></div></li><li><p>如果变量未经声明便被初始化，那么它会自动加到全局上下文中。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1, num2</span>) &#123;    sum = num1 + num2;    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<span class="hljs-comment">// 30</span></code></pre></div></li><li><p>var 存在声明提升，可以多次声明不会报错。</p></li></ol><h4 id="2-3-2-使用-let-的块级作用域声明"><a href="#2-3-2-使用-let-的块级作用域声明" class="headerlink" title="2.3.2 使用 let 的块级作用域声明"></a>2.3.2 使用 let 的块级作用域声明</h4><ol><li>块级作用域由最近的一对儿花括号<code>&#123;&#125;</code>界定。if 块、while 块、function 块和单独的块都是 let 声明的作用域。</li><li>let 不能在同一作用域内声明两次。</li><li>let 也会被提升，但是由于存在暂时性死区。实际上，不能在声明之前使用 let 变量。</li></ol><h4 id="2-3-3-使用-const-的常量声明"><a href="#2-3-3-使用-const-的常量声明" class="headerlink" title="2.3.3 使用 const 的常量声明"></a>2.3.3 使用 const 的常量声明</h4><ol><li><p>使用 const 声明的变量必须同时初始化。一经声明在声明周期内都不能再重新赋值。</p></li><li><p>赋值为对象的 const 变量不能再被重新赋值为其它引用值，但对象的键不受限制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-comment">// 报错</span>obj.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// &#123;a:1&#125;</span></code></pre></div></li><li><p>如果想让整个对象都不能修改，可以使用 <code>Object.freeze()</code>。这样再给属性赋值时，虽然不会报错但是会<strong>静默失败</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(&#123;&#125;);obj.<span class="hljs-property">a</span> =<span class="hljs-number">1</span><span class="hljs-comment">// 不报错，静默失败</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// &#123;&#125;</span></code></pre></div></li></ol><h4 id="2-3-4-标识符查找"><a href="#2-3-4-标识符查找" class="headerlink" title="2.3.4 标识符查找"></a>2.3.4 标识符查找</h4><p>当在特定上下文中引用一个标识符时，必须沿着作用域链搜索确定这个标识符是什么。这个过程一直持续到搜索至全局上下文的变量对象。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】6.语言基础 - 操作符、语句</title>
    <link href="/archives/385fbcdb.html"/>
    <url>/archives/385fbcdb.html</url>
    
    <content type="html"><![CDATA[<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="1-一元操作符"><a href="#1-一元操作符" class="headerlink" title="1 一元操作符"></a>1 一元操作符</h2><p>只操作一个值的操作符叫一元操作符。</p><h3 id="1-1-自增自减-、"><a href="#1-1-自增自减-、" class="headerlink" title="1.1 自增自减 ++ 、--"></a>1.1 自增自减 <code>++</code> 、<code>--</code></h3><p><code>++</code>和<code>--</code>用法照搬 C 语言。不仅可以用在数值类型上，用在其它类型上的规则如下：</p><ol><li>对于字符串，如果是有效的数值形式，则转换为数值后再应用改变。如果不是有效的形式，则将变量的值设置为 <code>NaN</code>。</li><li>对于布尔值，如果是 <code>false</code>，则转换成<code>0</code>后再应用改变。如果是 <code>true</code>，则转换成<code>1</code>后再应用改变。</li><li>如果是对象，则调用其 <code>valueOf()</code> 方法取得可以操作的值。接着应用上述的规则。如果是 <code>NaN</code>，则调用 <code>toString()</code> 并再次应用其它规则。</li></ol><p>注意：使用自增或者自减操作符后，<strong>变量的类型会转变成数值</strong>。</p><h3 id="1-2-正负-、"><a href="#1-2-正负-、" class="headerlink" title="1.2 正负+、-"></a>1.2 正负<code>+</code>、<code>-</code></h3><p>在非数值类型的变量前使用<strong>加号</strong>，则会执行与使用 <code>Number()</code> 转型函数一样类型转换。</p><p>在非数值类型的变量前使用<strong>减号</strong>，则先会执行与使用<code>Number()</code> 转型函数一样类型转换，再转成负数。</p><h2 id="2-位操作符"><a href="#2-位操作符" class="headerlink" title="2 位操作符"></a>2 位操作符</h2><p>位操作符用来操作内存中表示数据的比特。</p><h3 id="2-1-正数和负数在内存中的表示形式"><a href="#2-1-正数和负数在内存中的表示形式" class="headerlink" title="2.1 正数和负数在内存中的表示形式"></a>2.1 正数和负数在内存中的表示形式</h3><p>有符号整数使用 32 位的前 31 位表示整数值，第 32 位是符号位。比如 0 正 1 负。</p><p>负数使用<strong>二补数</strong>进行存储，通过三个步骤得到二补数：<strong>绝对值</strong>，<strong>取反</strong>，<strong>加一</strong>。比如：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">18</span><span class="hljs-string">：</span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0010</span><span class="hljs-number">-18</span><span class="hljs-string">：</span><span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">绝对值</span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0010</span><span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">取反</span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1110 </span><span class="hljs-number">1101</span><span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">加一</span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1110 </span><span class="hljs-number">1110</span></code></pre></div><p>使用 <code>toString()</code> 方法来输出负数的二进制表示：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = -<span class="hljs-number">18</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// -10010</span></code></pre></div><p>对非数值类型进行位操作，会先使用 <code>Number()</code> 方法将该值转换为数值，之后再进行位操作。</p><h3 id="2-2-按位非"><a href="#2-2-按位非" class="headerlink" title="2.2 按位非 ~"></a>2.2 按位非 <code>~</code></h3><p>使用<code>~</code>对操作数的每个比特位进行取反。最终效果是对数值进行<strong>取反减一</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">15</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(~num);  <span class="hljs-comment">// -16</span></code></pre></div><h3 id="2-3-按位与-amp"><a href="#2-3-按位与-amp" class="headerlink" title="2.3 按位与 &amp;"></a>2.3 按位与 <code>&amp;</code></h3><p>使用<code>&amp;</code>对两个操作数进行按位与。规则如下：两个比特位，如果都是1，则该位结果是1，否则是0。</p><h3 id="2-4-按位或"><a href="#2-4-按位或" class="headerlink" title="2.4 按位或 |"></a>2.4 按位或 <code>|</code></h3><p>使用<code>|</code>对两个操作数进行按位或。规则如下：两个比特位，只要有一位是1，则该位结果是1，否则是0。</p><h3 id="2-5-按位异或"><a href="#2-5-按位异或" class="headerlink" title="2.5 按位异或 ^"></a>2.5 按位异或 <code>^</code></h3><p>使用<code>^</code>对两个操作数按位异或。规则如下：两个比特位，有且仅有一位是1时，该位结果是1，否则是0。</p><h3 id="2-6-左移-lt-lt"><a href="#2-6-左移-lt-lt" class="headerlink" title="2.6 左移 &lt;&lt;"></a>2.6 左移 <code>&lt;&lt;</code></h3><p>使用<code>&lt;&lt;</code>会对操作数的所有位向左移动。左移会<strong>保留符号</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num&lt;&lt;<span class="hljs-number">5</span>);  <span class="hljs-comment">// 64</span></code></pre></div><h3 id="2-7-有符号右移-gt-gt"><a href="#2-7-有符号右移-gt-gt" class="headerlink" title="2.7 有符号右移 &gt;&gt;"></a>2.7 有符号右移 <code>&gt;&gt;</code></h3><p>使用<code>&gt;&gt;</code>会对操作数的所有位向右移动。有符号右移会<strong>保留符号</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">32</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num &gt;&gt; <span class="hljs-number">3</span>);  <span class="hljs-comment">// 4</span></code></pre></div><h3 id="2-8-无符号右移-gt-gt-gt"><a href="#2-8-无符号右移-gt-gt-gt" class="headerlink" title="2.8 无符号右移&gt;&gt;&gt;"></a>2.8 无符号右移<code>&gt;&gt;&gt;</code></h3><p>使用<code>&gt;&gt;&gt;</code>会对操作数的所有位向右移动。对于<strong>正数</strong>，无符号右移和有符号右移结果相同。对于<strong>负数</strong>，无符号右移会将负数的二补数当作正数来处理，所以无符号右移之后结果变得会非常大。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = -<span class="hljs-number">32</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num &gt;&gt;&gt; <span class="hljs-number">3</span>); <span class="hljs-comment">// 536870908</span></code></pre></div><h2 id="3-布尔操作符"><a href="#3-布尔操作符" class="headerlink" title="3 布尔操作符"></a>3 布尔操作符</h2><h3 id="3-1-逻辑非"><a href="#3-1-逻辑非" class="headerlink" title="3.1 逻辑非 !"></a>3.1 逻辑非 <code>!</code></h3><p>使用<code>!</code>会对操作数进行取反。</p><p>如果应用到<strong>非布尔值</strong>，首先转换为布尔值，随后进行取反。使用<code>!!</code>，相当于对操作数使用<code>Boolean()</code>函数。</p><h3 id="3-2-逻辑与-amp-amp"><a href="#3-2-逻辑与-amp-amp" class="headerlink" title="3.2 逻辑与 &amp;&amp;"></a>3.2 逻辑与 <code>&amp;&amp;</code></h3><p><code>&amp;&amp;</code> 有两个操作数。两个操作数中，只有都为 true，才返回 true，否则返回 false。</p><p>如果应用到<strong>非布尔值</strong>，逻辑与不一定返回布尔值，规则如下：</p><ol><li>如果第一个数是对象，则返回第二个操作数。</li><li>如果第二个操作数是对象，只有第一个操作数求值为 true 时，才会返回该对象。</li><li>如果有一个操作数是 null，则返回 null。</li><li>如果有一个操作数是 NaN，则返回 NaN。</li><li>如果有一个操作数是 undefined，则返回 undefined。</li><li>如果两个操作数是 null、NaN、undefined，则返回第一个操作数。</li></ol><p>逻辑与有<strong>短路特性</strong>：如果第一个操作符决定了结果，那么永远不会对第二个操作符求值。对于逻辑与，如果第一个操作符是 false，那么永远不会对第二个操作符进行求值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">false</span> &amp;&amp; b;<span class="hljs-comment">// 即使 b 没有被定义也不会出错，因为不会执行 &amp;&amp; 后面</span></code></pre></div><h3 id="3-3-逻辑或"><a href="#3-3-逻辑或" class="headerlink" title="3.3 逻辑或 ||"></a>3.3 逻辑或 <code>||</code></h3><p><code>||</code> 有两个操作数。两个操作数中，只要有一个为 true，就返回 true，否则返回 false。</p><p>如果应用到<strong>非布尔值</strong>，逻辑或不一定返回布尔值，规则如下：</p><ol><li>如果第一个数是对象，则返回第一个操作数。</li><li>如果第一个操作数求值是 false，则返回第二个操作数。</li><li>如果两个操作数都是 null，则返回 null。</li><li>如果两个操作数都是 NaN，则返回 NaN。</li><li>如果两个操作数都是 undefined，则返回 undefined。</li></ol><p>逻辑或也有<strong>短路特性</strong>。对于逻辑或，如果第一个操作符是 true，那么永远不会对第二个操作符进行求值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">true</span> || b;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);</code></pre></div><p>特别的，利用这个特性，可以避免给变量赋值 null 或者 undefined：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = obj1 || obj2</code></pre></div><p>如果 obj1 不是 null 或者 undefined，则 a 被赋值为 obj1，否则赋值为 obj2。</p><h2 id="4-乘法-，除法-，取模-，指数"><a href="#4-乘法-，除法-，取模-，指数" class="headerlink" title="4 乘法 *，除法 /，取模 %，指数 **"></a>4 乘法 <code>*</code>，除法 <code>/</code>，取模 <code>%</code>，指数 <code>**</code></h2><h3 id="4-1-乘法"><a href="#4-1-乘法" class="headerlink" title="4.1 乘法"></a>4.1 乘法</h3><p>如果两个操作数中有非数值，则会先调用 Number() 转型函数转换为数值。特别的：</p><ol><li>Infinity 乘以0，则返回 NaN。</li><li>Infinity 乘以非0有限数值，根据<strong>第二个操作数</strong>的符号返回 Infinity 或 -Infinity。</li><li>Infinity 乘以 Infinity，则返回 Infinity。</li></ol><h3 id="4-2-除法"><a href="#4-2-除法" class="headerlink" title="4.2 除法"></a>4.2 除法</h3><p>如果两个操作数中有非数值，则会先调用 Number() 转型函数转换为数值。特别的：</p><ol><li>Infinity 除以 Infinity，则返回 NaN。</li><li>0 除以 0，返回 NaN。</li><li>非0有限数值除以0，根据<strong>第一个操作数</strong>的符号返回 Infinity 或 -Infinity。</li><li>Infinity 除以任何数值，根据<strong>第二个操作数</strong>的符号返回 Infinity 或 -Infinity。</li></ol><h3 id="4-3-取模"><a href="#4-3-取模" class="headerlink" title="4.3 取模"></a>4.3 取模</h3><p>如果两个操作数中有非数值，则会先调用 Number() 转型函数转换为数值。特别的：</p><ol><li>被除数是无限值，除数是有限值，则返回NaN。</li><li>被除数是有限值，除数是无限值，则返回被除数。</li><li>被除数是有限值，除数是0，则返回NaN。</li><li>Infinity 除以 Infinity，则返回 NaN。</li><li>被除数是0，除数不是0，则返回0。</li></ol><p><strong>结果的符号和被除数相同</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span> % <span class="hljs-number">6</span>);<span class="hljs-comment">// 4</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span> % -<span class="hljs-number">6</span>);<span class="hljs-comment">// 4</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">10</span> % <span class="hljs-number">6</span>);<span class="hljs-comment">// -4</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">10</span> % -<span class="hljs-number">6</span>);<span class="hljs-comment">// -4</span></code></pre></div><h3 id="4-4-指数操作符"><a href="#4-4-指数操作符" class="headerlink" title="4.4 指数操作符**"></a>4.4 指数操作符<code>**</code></h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>));<span class="hljs-comment">// 9</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>**<span class="hljs-number">2</span>);<span class="hljs-comment">// 9</span></code></pre></div><h2 id="5-加法-、减法"><a href="#5-加法-、减法" class="headerlink" title="5 加法+、减法-"></a>5 加法<code>+</code>、减法<code>-</code></h2><h3 id="5-1-加法"><a href="#5-1-加法" class="headerlink" title="5.1 加法"></a>5.1 加法</h3><p>如果<strong>两个</strong>操作数都是<strong>数值</strong>，运算规则如下：</p><ol><li><p>任一操作数是 NaN，返回 NaN。</p></li><li><p>&#96;&#96;&#96;<br>Infinity + Infinity &#x3D; Infinity<br>-Infinity + -Infinity &#x3D; -Infinity<br>-Infinity + Infinity &#x3D; NaN</p><div class="code-wrapper"><pre><code class="hljs subunit">3. ```   <span class="hljs-string">+0</span> + (<span class="hljs-string">+0</span>) = <span class="hljs-string">+0</span>   <span class="hljs-string">-0</span> + (<span class="hljs-string">+0</span>) = <span class="hljs-string">+0</span>   <span class="hljs-string">-0</span> + (<span class="hljs-string">-0</span>) = <span class="hljs-string">-0</span></code></pre></div></li></ol><p>如果有<strong>一个</strong>操作数是<strong>字符串</strong>，运算规则如下：</p><ol><li>如果都是字符串，则将第二个字符串拼接到第一个字符串后面</li><li>如果只有一个操作符是字符串，则将另一个操作符转为字符串，再将两个字符串拼接到一起。</li></ol><p>如果有任一操作数是<strong>对象</strong>、<strong>数值</strong>或<strong>布尔值</strong>，则调用<code>toString()</code>方法获取字符串，随后应用上述规则。</p><p>如果是<code>undefined</code>或<code>null</code>则调用<code>String()</code>函数，结果值为”undefined”和”null”。</p><h3 id="5-2-减法"><a href="#5-2-减法" class="headerlink" title="5.2 减法"></a>5.2 减法</h3><p>如果两个数字是数值，则执行运算并返回结果。其余规则：</p><ol><li><p>任一操作数是 NaN，返回 NaN。</p></li><li><p>&#96;&#96;&#96;<br>Infinity - Infinity &#x3D; NaN<br>-Infinity - (-Infinity) &#x3D; NaN<br>Infinity - (-Infinity) &#x3D; Infinity<br>-Infinity - Infinity &#x3D; -Infinity</p><div class="code-wrapper"><pre><code class="hljs subunit">3. ```   <span class="hljs-string">+0</span> - (<span class="hljs-string">+0</span>) = <span class="hljs-string">+0</span>   <span class="hljs-string">+0</span> - (<span class="hljs-string">-0</span>) = <span class="hljs-string">-0</span>   <span class="hljs-string">-0</span> - (<span class="hljs-string">-0</span>) = <span class="hljs-string">+0</span></code></pre></div></li></ol><p>如果有任一操作数是<strong>字符串</strong>、<strong>布尔值</strong>、<strong>null</strong> 或 <strong>undefined</strong>，先在后台使用 <code>Number()</code> 转为数值，随后执行以上规则。</p><p>如果任意操作数是<strong>对象</strong>，则调用 <code>valueoOf()</code> 方法取得数值。如果对象没有 <code>valueOf()</code> 方法，则调用 <code>toString()</code> 方法，然后将得到的字符串转换为数值。</p><h2 id="6-关系操作符-gt-lt"><a href="#6-关系操作符-gt-lt" class="headerlink" title="6 关系操作符 &gt;&lt;"></a>6 关系操作符 &gt;&lt;</h2><p>规则如下：</p><ol><li>如果两个操作数都是数值，执行数值比较。</li><li>如果两个操作数都是字符串，则逐个比较字符串中对应的编码。（大写字符编码<strong>小于</strong>小写字符）</li><li>如果有任一操作数是数值，则将另一个操作数转换为数值，再执行比较。</li><li>任何涉及 NaN 的比较都返回 false。</li><li>如果有任一操作数是对象，则调用其 valueOf() 方法，将取得的结果按上述规则比较。如果没有 valueOf() 方法，则调用 toString() 方法，将取得的结果按上述规则比较。</li><li>如果有任一操作数是布尔值，则将其转为数值再比较。</li></ol><h2 id="7-相等操作符"><a href="#7-相等操作符" class="headerlink" title="7 相等操作符"></a>7 相等操作符</h2><p>有两组操作符，第一组是等于和不等于，它们在比较前执行转换。第二组是全等和不全等，它们在比较前不会发生转换。</p><h3 id="7-1-等于和不等于"><a href="#7-1-等于和不等于" class="headerlink" title="7.1 等于和不等于"></a>7.1 等于和不等于</h3><p><code>==</code>和<code>!=</code>会先对操作数进行强制类型转换，再判断操作数是否相等。规则如下：</p><ul><li>如果两个操作数都是对象，则仅当两个操作数都引用同一个对象时才返回<code>true</code>。</li><li>如果一个操作数是<code>null</code>，另一个操作数是<code>undefined</code>，则返回<code>true</code>。</li><li>如果两个操作数是不同类型的，就会尝试在比较之前将它们转换为相同类型：<ul><li>当数字与字符串进行比较时，会尝试将字符串转换为数字值。</li><li>如果操作数之一是<code>Boolean</code>，则将布尔操作数转换为1或0。<ul><li>如果是<code>true</code>，则转换为<code>1</code>。</li><li>如果是 <code>false</code>，则转换为<code>0</code>。</li></ul></li><li>如果操作数之一是对象，另一个是数字或字符串，会尝试使用对象的<code>valueOf()</code>和<code>toString()</code>方法将对象转换为原始值。</li></ul></li><li>如果操作数具有相同的类型，则将它们进行如下比较：<ul><li><code>String</code>：<code>true</code>仅当两个操作数具有相同顺序的相同字符时才返回。</li><li><code>Number</code>：<code>true</code>仅当两个操作数具有相同的值时才返回。<code>+0</code>并被<code>-0</code>视为相同的值。如果任一操作数为<code>NaN</code>，则返回<code>false</code>。</li><li><code>Boolean</code>：<code>true</code>仅当操作数为两个<code>true</code>或两个<code>false</code>时才返回<code>true</code>。</li></ul></li></ul><h3 id="7-2-全等和不全等"><a href="#7-2-全等和不全等" class="headerlink" title="7.2 全等和不全等"></a>7.2 全等和不全等</h3><p><code>===</code>和<code>!==</code>不会对操作数进行强制类型转换。与相等运算符不同，全等运算符总是认为不同类型的操作数是不同的。规则如下：</p><ul><li>如果操作数的类型不同，则返回 <code>false</code>。</li><li>如果两个操作数都是对象，只有当它们指向同一个对象时才返回 <code>true</code>。</li><li>如果两个操作数都为 <code>null</code>，或者两个操作数都为 <code>undefined</code>，返回 <code>true</code>。</li><li>如果两个操作数有任意一个为 <code>NaN</code>，返回 <code>false</code>。</li><li>否则，比较两个操作数的值：<ul><li>数字类型必须拥有相同的数值。<code>+0</code> 和 <code>-0</code> 会被认为是相同的值。</li><li>字符串类型必须拥有相同顺序的相同字符。</li><li>布尔类型必须同时为 <code>true</code> 或同时为 <code>false</code>。</li></ul></li></ul><h2 id="8-三元操作符"><a href="#8-三元操作符" class="headerlink" title="8 三元操作符"></a>8 三元操作符</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">10</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">5</span><span class="hljs-keyword">let</span> max = num1 &gt; num2 ? num1 : num2</code></pre></div><h2 id="9-赋值操作符"><a href="#9-赋值操作符" class="headerlink" title="9 赋值操作符 ="></a>9 赋值操作符 <code>=</code></h2><p>复合赋值操作符：<code>+=</code>、<code>-=</code>等等</p><h2 id="10-逗号操作符"><a href="#10-逗号操作符" class="headerlink" title="10 逗号操作符 ,"></a>10 逗号操作符 <code>,</code></h2><ol><li><p>一条语句中执行多个操作</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">2</span>,c = <span class="hljs-number">3</span></code></pre></div></li><li><p>赋值时，使用逗号分隔值，最终会返回最后一个值</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// num = 5</span></code></pre></div></li></ol><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="1-if、do-while、while、for"><a href="#1-if、do-while、while、for" class="headerlink" title="1 if、do-while、while、for"></a>1 if、do-while、while、for</h2><p>略。</p><h2 id="2-for-in"><a href="#2-for-in" class="headerlink" title="2 for-in"></a>2 for-in</h2><p>for-in 语句用来枚举对象中<strong>非符号属性</strong>，例如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foo&quot;</span>)]: <span class="hljs-string">&#x27;foo&#x27;</span>,&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> obj) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prop, obj[prop]);<span class="hljs-comment">// a 1   b 2 </span>&#125;</code></pre></div><p>注意：</p><ol><li>ECMAScript 中对象的属性是<strong>无序</strong>的，因此 for-in 无法保证对象属性的顺序。</li><li>如果要迭代的变量是 null 或 undefined，则不会执行循环体（不报错）。</li></ol><h2 id="3-for-of"><a href="#3-for-of" class="headerlink" title="3 for-of"></a>3 for-of</h2><p>for-of 用来遍历可迭代对象的元素，例如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> nums) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<span class="hljs-comment">// 1 2 3</span>&#125;</code></pre></div><p>注意：如果尝试迭代的对象不支持迭代，for-of 会抛出错误。</p><h2 id="4-标签语句配合-break-和-continue"><a href="#4-标签语句配合-break-和-continue" class="headerlink" title="4 标签语句配合 break 和 continue"></a>4 标签语句配合 break 和 continue</h2><h3 id="4-1-标签语句"><a href="#4-1-标签语句" class="headerlink" title="4.1 标签语句"></a>4.1 标签语句</h3><p>格式：<code>标签：语句</code>，例如：</p><div class="code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-symbol">flag:</span><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span></code></pre></div><h3 id="4-2-配合-break-和-continue"><a href="#4-2-配合-break-和-continue" class="headerlink" title="4.2 配合 break 和 continue"></a>4.2 配合 break 和 continue</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">flag</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;        <span class="hljs-keyword">if</span> (j % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span> flag;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i, j);    &#125;&#125;</code></pre></div><p>执行到 break 和 continue 时，会跳转到指定的位置继续执行。</p><h2 id="5-with-语句"><a href="#5-with-语句" class="headerlink" title="5 with 语句"></a>5 with 语句</h2><p>with 语句的用途是将代码的作用域设置为特定的对象，比如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj =&#123;    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,    <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,    <span class="hljs-attr">c</span>:<span class="hljs-number">3</span>,    <span class="hljs-attr">d</span>:<span class="hljs-number">4</span>&#125;<span class="hljs-title function_">with</span>(<span class="hljs-params">obj</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// 1</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<span class="hljs-comment">// 2</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<span class="hljs-comment">// 3</span>    <span class="hljs-keyword">let</span> d = <span class="hljs-number">400</span>;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d);<span class="hljs-comment">// 400</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); <span class="hljs-comment">//报错</span>&#125;</code></pre></div><p>注意：</p><ol><li>在语句内部，每个变量会先被认为是局部变量。如果没有找到局部变量，就去 with 后面的对象身上去找。如果还找不到就报错。</li><li>with 影响性能并且难以调试，因此不建议使用 with 语句。</li></ol><h2 id="6-switch-语句"><a href="#6-switch-语句" class="headerlink" title="6 switch 语句"></a>6 switch 语句</h2><p>注意：switch 语句在比较每个条件的值时，使用的是<strong>全等操作符</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】5.语言基础 - 数据类型</title>
    <link href="/archives/52155ef2.html"/>
    <url>/archives/52155ef2.html</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>ECMAScript 2015 <strong>之前</strong>共有 6 种数据类型。其中，有 5 种<strong>简单数据类型</strong>（原始类型)：Undefined，Null，Boolean，String，Number。还有1种<strong>复杂数据类型</strong>（对象类型）：Object。</p><p>ECMAScript 2015 新增了 Symbol 原始类型。</p><p>ECMAScript 2020 新增了 BigInt 原始类型。</p><p><strong>至此，ECMAScript 共有 8 种数据类型。包括 7 种原始类型：Undefined，Null，Boolean，String，Number，Symbol，BigInt。还有对象类型 Object</strong>。</p><h2 id="1-typeof-操作符"><a href="#1-typeof-操作符" class="headerlink" title="1 typeof 操作符"></a>1 typeof 操作符</h2><p>使用 typeof 操作符可以确定变量的数据类型。typeof 操作符的使用结果是 8 个字符串之一：”undefined”、”boolean”、”number”、”string”、’’bigint’’、”object”、”function”和”symbol”。</p><ol><li><p>调用 <code>typeof null</code> 会返回 <code>&quot;object&quot;</code>，因为 null 被认为是<strong>空对象</strong>的引用。</p></li><li><p>函数并不是一种数据类型，但是调用 typeof 会返回 <code>&quot;function&quot;</code>。</p></li><li><p>typeof 是操作符不是函数，但也可以当作函数进行传参：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(a))</code></pre></div></li></ol><h2 id="2-Undefined-类型"><a href="#2-Undefined-类型" class="headerlink" title="2 Undefined 类型"></a>2 Undefined 类型</h2><p>Undefined 类型只有一个值 undefined。声明变量但未赋予初始值就相当于赋值 undefined。</p><ol><li><p>对已声明但未初始化的变量调用 typeof，返回的是<code>&quot;undefined&quot;</code>。对未声明的变量调用 typeof，返回的也是<code>&quot;undefined&quot;</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a);<span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> b);<span class="hljs-comment">// undefined</span></code></pre></div></li><li><p>undefined 是一个假值（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy"><strong>falsy</strong> 值</a>）。</p></li></ol><h2 id="3-Null-类型"><a href="#3-Null-类型" class="headerlink" title="3 Null 类型"></a>3 Null 类型</h2><p>Null 类型只有一个值 null。表示一个空对象指针。</p><ol><li><p>在定义一个将来要保存<strong>对象值</strong>的变量时，建议使用 null 来初始化。</p></li><li><p>undefined 是由 null 派生来的，因此<strong>表面上</strong>相等：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>);<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> === <span class="hljs-literal">null</span>);<span class="hljs-comment">// false</span></code></pre></div></li><li><p>null 是一个假值。</p></li></ol><h2 id="4-Boolean-类型"><a href="#4-Boolean-类型" class="headerlink" title="4 Boolean 类型"></a>4 Boolean 类型</h2><p>Boolean 类型有两个字面值：true 和 false。</p><ol><li><p>任何值都有对应的布尔值等价形式，<code>Boolean()</code> 转型函数可以将任意值转成相应的布尔值。</p><table><thead><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr></thead><tbody><tr><td>String</td><td>非空字符串</td><td>空串</td></tr><tr><td>Number</td><td>非0数值</td><td>0、NaN</td></tr><tr><td>BigInt</td><td>非0数值</td><td>0</td></tr><tr><td>Symbol</td><td>任何符号</td><td>无</td></tr><tr><td>Object</td><td>任意对象</td><td>无</td></tr><tr><td>Null</td><td>无</td><td>null</td></tr><tr><td>Undefined</td><td>无</td><td>undefined</td></tr></tbody></table></li><li><p>if 等流程控制语句会自动执行上面的转换。</p></li></ol><h2 id="5-Number-类型"><a href="#5-Number-类型" class="headerlink" title="5 Number 类型"></a>5 Number 类型</h2><p>Number 类型使用 IEEE 754 表示整数和浮点值（双精度值）。</p><h3 id="5-1-整数"><a href="#5-1-整数" class="headerlink" title="5.1 整数"></a>5.1 整数</h3><ol><li><p>最基本的数值字面量是十进制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">5</span></code></pre></div></li><li><p>八进制字面量：<code>0</code>或<code>0o</code>开头，然后是八进制数字（0-7）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">076</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);     <span class="hljs-comment">// 62</span><span class="hljs-keyword">let</span> b = <span class="hljs-number">0o76</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);     <span class="hljs-comment">// 62</span></code></pre></div><p><code>0</code>开头表示八进制数时，如果有数字超出八进制数字范围，引擎会忽略前置0，并将后面内容按十进制数处理。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">078</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 78</span></code></pre></div><p><code>0o</code>开头表示八进制数时，如果有数字超出八进制数字范围，会报错。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = 0o79;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);  <span class="hljs-comment">// 报错</span></code></pre></div></li><li><p>十六进制字面量：<code>0x</code> 开头（这里的<code>0x</code>严格小写），然后是十六进制数字（0-9，A-F）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0x2a</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 42</span></code></pre></div></li></ol><p>注意：</p><ol><li><p>使用八进制和十六进制格式创建的数值在所有<strong>数学操作</strong>种都被视为十进制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">043</span>;<span class="hljs-keyword">let</span> num2 = <span class="hljs-number">032</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, num2);  <span class="hljs-comment">// 35 26</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1 + num2); <span class="hljs-comment">// 61</span></code></pre></div></li><li><p>正0等于负0。</p></li></ol><h3 id="5-2-浮点数"><a href="#5-2-浮点数" class="headerlink" title="5.2 浮点数"></a>5.2 浮点数</h3><ol><li><p>定义浮点数，数值中必须含有<strong>小数点</strong>，而且小数点后至少有一个数字。小数点前不是必须有整数，但是推荐加上。</p></li><li><p>浮点数内存空间是整数的两倍。为节省空间，ECMAScript 总是想办法把值转化为整数。比如：小数点后没有数字时会被视为整数；小数点后面都是0时会被视为整数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1.0</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 1</span></code></pre></div></li><li><p>小数点后至少含有 6 个 0 的浮点数会被转换为科学计数法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0.0000001</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);     <span class="hljs-comment">// 1e-7</span></code></pre></div></li><li><p>因为使用了 IEEE 754数值，存在舍入错误。比如：<code>0.1 + 0.2 !== 0.3</code>。因此<strong>不要</strong>测试特定的浮点值。</p></li></ol><h3 id="5-3-值的范围"><a href="#5-3-值的范围" class="headerlink" title="5.3 值的范围"></a>5.3 值的范围</h3><ol><li><p>由于内存限制，JavaScript 中可以表示的最大值为<code>Number.MAX_VALUE</code>，最小值为<code>Number.MIN_VALUE</code>。无法表示的正数用<code>Infinity</code>表示，无法表示的负数用<code>-Infinity</code>表示。</p></li><li><p>使用<code>isFinite()</code>函数来判断是否在最大值和最小值之间。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">2</span> * <span class="hljs-title class_">Infinity</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(num));<span class="hljs-comment">// false</span></code></pre></div></li></ol><h3 id="5-4-NaN-和-Infinity"><a href="#5-4-NaN-和-Infinity" class="headerlink" title="5.4 NaN 和 Infinity"></a>5.4 NaN 和 Infinity</h3><p><code>NaN</code> 是一个特殊的数（即<strong>不是数值</strong>），表示本来要返回数值的操作失败了。</p><ol><li><p>0、-0、+0之间相除会得到 NaN：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>/<span class="hljs-number">0</span>);<span class="hljs-comment">// NaN</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">0</span>/+<span class="hljs-number">0</span>);<span class="hljs-comment">// NaN</span></code></pre></div></li><li><p>分母是 0、-0、+0，但分子不是。此时得到 <code>Infinity</code>和<code>-Infinity</code></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);<span class="hljs-comment">// Infinity</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);<span class="hljs-comment">// -Infinity</span></code></pre></div></li><li><p>涉及 <code>NaN</code> 的操作都返回 <code>NaN</code>。</p></li><li><p><code>NaN</code> 不等于包括自己在内的任何数。</p></li><li><p><code>isNaN()</code> 函数可以判断是否<strong>不是数值</strong>。这个函数接收任意类型的参数，并尝试将转换成数值。不能转换成数值则返回 true。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Infinity</span>))<span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>));<span class="hljs-comment">// false (可以转换成数值1)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">false</span>));<span class="hljs-comment">// false (可以转换成数值0)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;10&quot;</span>));<span class="hljs-comment">// false (可以转换成数值10)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;1.4&quot;</span>));<span class="hljs-comment">// false (可以转换成数值1.4)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">// fasle (2)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;1true&quot;</span>));<span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;true&quot;</span>));<span class="hljs-comment">// true</span></code></pre></div></li></ol><h3 id="5-5-数值转换"><a href="#5-5-数值转换" class="headerlink" title="5.5 数值转换"></a>5.5 数值转换</h3><h4 id="5-5-1-Number-转型函数"><a href="#5-5-1-Number-转型函数" class="headerlink" title="5.5.1 Number() 转型函数"></a>5.5.1 Number() 转型函数</h4><p>可用于任何数据类型，规则如下：</p><ol><li><p>undefined，返回 NaN。null，返回0。</p></li><li><p>true，返回1。false，返回0。</p></li><li><p>数值直接返回。</p></li><li><p>字符串：</p><ul><li>如果字符串是表示数值字符（整数浮点数都可以），包括前面的正负号，则会转换成一个十进制的数。此时会<strong>忽略前缀0</strong>，也就是说只识别<code>0o</code>开头的八进制数和<code>0x</code>开头的十六进制数。不识别<code>0</code>开头的八进制数，<code>0</code>开头的会被当作十进制。</li><li><strong>空串返回0</strong>。</li><li>其余情况返回 NaN。</li></ul></li><li><p>对象。调用<code>valueOf()</code>方法，并按照以上规则转换返回的值。如果转换结果是<code>NaN</code>，则调用<code>toString()</code>方法。再按照转换字符串的规则进行转换。</p></li></ol><h4 id="5-5-2-parseInt-函数"><a href="#5-5-2-parseInt-函数" class="headerlink" title="5.5.2 parseInt() 函数"></a>5.5.2 parseInt() 函数</h4><p><code>parseInt()</code>函数更专注于<strong>字符串</strong>中是否含有数值。接收两个参数，第一个参数是需要转换的字符串，第二个参数是进制，规则如下：</p><ol><li><p>字符串前面的空格会被忽略，从第一个非零数值开始转换。如果第一个字符不是数值字符、正负号，那么立即返回 NaN。也就是说，<strong>空串返回 NaN</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;&quot;</span>));      <span class="hljs-comment">// NaN  </span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;qwe&#x27;</span>));<span class="hljs-comment">// NaN</span></code></pre></div></li><li><p>继续检测每一个字符，直到字符串末尾或者是遇到<strong>非整数字符</strong>。（小数点不是有效的整数字符）</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1234blue&quot;</span>));<span class="hljs-comment">// 1234</span></code></pre></div></li><li><p>可以识别不同进制的整数。比如：<code>0</code>开头的整数会被识别成<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">八进制或十进制</a>（多数情况下会被识别成十进制，不同环境的实现不同），<code>0o</code>开头的整数会被识别成八进制，<code>0x</code>开头的整数会被识别成十六进制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;073&#x27;</span>));<span class="hljs-comment">// 73</span></code></pre></div></li><li><p>在使用 parseInt() 时，建议<strong>指定第二个参数</strong>，用一个整数规定进制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;073&#x27;</span>,<span class="hljs-number">8</span>));<span class="hljs-comment">// 59</span></code></pre></div></li></ol><h4 id="5-5-3-parseFloat-函数"><a href="#5-5-3-parseFloat-函数" class="headerlink" title="5.5.3 parseFloat() 函数"></a>5.5.3 parseFloat() 函数</h4><p><code>parseFloat()</code>函数和<code>parseInt()</code>函数类似。</p><ol><li><code>parseFloat()</code>函数解析到字符串末尾或者解析到第一个无效的字符串。</li><li>第一个出现的小数点是有效的，第二个出现的小数点及其之后的内容无效，不会被识别。</li><li><strong>只接收一个字符串参数</strong>。只能解析十进制数，不能指定底数。</li></ol><h2 id="6-String-类型"><a href="#6-String-类型" class="headerlink" title="6  String 类型"></a>6  String 类型</h2><p>字符串可以使用单引号<code>&#39;&#39;</code>、双引号<code>&quot;&quot;</code>或反引号&#96;&#96;标识。</p><h3 id="6-1-字符字面量"><a href="#6-1-字符字面量" class="headerlink" title="6.1 字符字面量"></a>6.1 字符字面量</h3><p><code>\n</code> 、<code>\t</code>、<code>\xnn</code>（十六进制编码表示的字符）、<code>\unnnn</code>（十六进制编码表示的 Unicode 字符）</p><p>字符字面量被作为单个字符解释。</p><h3 id="6-2-字符串的不可变性"><a href="#6-2-字符串的不可变性" class="headerlink" title="6.2 字符串的不可变性"></a>6.2 字符串的不可变性</h3><p>字符串是不可变的。如果改变字符串的值，会销毁之前的值，并把新值保存到变量中。这是后台发生的，前台无感知。</p><h3 id="6-3-转换为字符串"><a href="#6-3-转换为字符串" class="headerlink" title="6.3 转换为字符串"></a>6.3 转换为字符串</h3><h4 id="6-3-1-toString-方法"><a href="#6-3-1-toString-方法" class="headerlink" title="6.3.1 toString() 方法"></a>6.3.1 toString() 方法</h4><p>该函数的作用是返回当前值的字符串等价物。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">true</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toString</span>());<span class="hljs-comment">// &quot;true&quot;</span><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-title function_">toString</span>());<span class="hljs-comment">// &quot;10&quot;</span></code></pre></div><ol><li><p><strong>undefined 和 null 没有 toString() 方法</strong>。</p></li><li><p>可以接收一个参数来指定底数。即以什么底数来输出数值的字符串表示。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">10</span>));<span class="hljs-comment">// 10</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>));<span class="hljs-comment">// 12</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>));<span class="hljs-comment">// a</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">// 1010</span></code></pre></div></li></ol><h4 id="6-3-2-String-转型函数"><a href="#6-3-2-String-转型函数" class="headerlink" title="6.3.2 String() 转型函数"></a>6.3.2 String() 转型函数</h4><p>如果不确定一个值是不是 undefined 或者 null，可以使用 String() 转型函数。String() 函数的规则如下：</p><ol><li>如果值有 toString() 方法则调用值的 toString() 方法。</li><li>undefined，返回”undefined”；null，返回”null”。</li></ol><h4 id="6-3-3-“”-转成字符串"><a href="#6-3-3-“”-转成字符串" class="headerlink" title="6.3.3 + “” 转成字符串"></a>6.3.3 + “” 转成字符串</h4><p>给一个值加上空串也可以将其转为字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num + <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 10</span></code></pre></div><h3 id="6-4-模板字面量"><a href="#6-4-模板字面量" class="headerlink" title="6.4 模板字面量"></a>6.4 模板字面量</h3><ol><li><p>使用反引号标识的字符串是模板字面量。</p></li><li><p>可以保留换行符，可以跨行定义字符串。因此定义模板时特别有用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pageHtml = <span class="hljs-string">`</span><span class="hljs-string">&lt;div&gt;</span><span class="hljs-string">&lt;span&gt;&lt;/span&gt;</span><span class="hljs-string">&lt;/div&gt;</span><span class="hljs-string">`</span></code></pre></div><p>模板字面量会保留反引号内部的空格，因此可能会看起来缩进不当。</p></li></ol><h3 id="6-5-字符串插值"><a href="#6-5-字符串插值" class="headerlink" title="6.5 字符串插值"></a>6.5 字符串插值</h3><p>模板字面量支持字符串插值：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> sum = <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> stirng = <span class="hljs-string">`<span class="hljs-subst">$&#123;num&#125;</span> + <span class="hljs-subst">$&#123;num&#125;</span> = <span class="hljs-subst">$&#123;sum&#125;</span>`</span>;<span class="hljs-comment">// 1 + 1 = 2 </span></code></pre></div><ol><li>插入的值会使用 toString() 方法强制转为字符串，undefined 插值显示 “undefined”，null 插值显示 “null”。</li><li>任何 <strong>JavaScript 表达式</strong>都可以用于插值表达式，可以调用函数和方法。</li><li>可以嵌套使用。</li><li>可以插入自己之前的值。</li></ol><h2 id="7-Symbol-类型"><a href="#7-Symbol-类型" class="headerlink" title="7 Symbol 类型"></a>7 Symbol 类型</h2><p>Symbol（符号） 是 ES6 新增的数据类型。符号实例是唯一的不可变的。符号的用途是保证对象属性使用唯一的标识符，不会发生属性冲突。符号的作用是用来创建唯一记号，进而用作非字符串形式的对象属性。</p><h3 id="7-1-基本用法"><a href="#7-1-基本用法" class="headerlink" title="7.1 基本用法"></a>7.1 基本用法</h3><ol><li><p>使用 Symbol() 函数初始化。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<span class="hljs-comment">// Symbol()</span></code></pre></div></li><li><p>可以传入一个字符串参数作为符号的描述。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)<span class="hljs-comment">// Symbol(foo)</span></code></pre></div><p>这个字符串参数和符号没有任何关系，仅仅是为了调试代码。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2);<span class="hljs-comment">// false</span></code></pre></div></li><li><p>符号没有字面量。只要创建 Symbol() 实例并将其作为对象的新属性，就可以保证它不会覆盖原有属性。</p></li><li><p>Symbol() 函数不能用作构造函数，不能与 <code>new</code> 关键字一同使用。</p></li></ol><h3 id="7-2-全局符号注册表"><a href="#7-2-全局符号注册表" class="headerlink" title="7.2 全局符号注册表"></a>7.2 全局符号注册表</h3><p>如果运行时的不同部分需要<strong>共享和重用</strong>符号，可以使用一个字符串为键，在<strong>全局符号注册表</strong>中创建并使用符号。</p><h4 id="7-2-1-Symbol-for-方法"><a href="#7-2-1-Symbol-for-方法" class="headerlink" title="7.2.1 Symbol.for() 方法"></a>7.2.1 Symbol.for() 方法</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fooSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foobar&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooSymbol);<span class="hljs-comment">// Symbol(foobar)</span></code></pre></div><p>Symbol.for() 和 Symbol() 定义的符号不相同。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fooSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foobar&quot;</span>);<span class="hljs-keyword">let</span> barSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;foobar&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooSymbol === barSymbol);<span class="hljs-comment">// false</span></code></pre></div><p>Symbol.for() 对每个字符串执行<strong>幂等操作</strong>。第一次使用某个字符串时，检查全局运行时注册表，发现不存在对应的符号，于是会生成一个符号实例并添加到注册表中。后续使用相同的字符串调用时，会同样检查注册表，发现存在于该字符串对应的符号，则返回这个实例。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fooSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;foobar&quot;</span>);<span class="hljs-comment">// 创建新符号</span><span class="hljs-keyword">let</span> barSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;foobar&quot;</span>);<span class="hljs-comment">// 返回已有的符号</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooSymbol === barSymbol);<span class="hljs-comment">// true</span></code></pre></div><h4 id="7-2-2-Symbol-keyFor-方法"><a href="#7-2-2-Symbol-keyFor-方法" class="headerlink" title="7.2.2 Symbol.keyFor() 方法"></a>7.2.2 Symbol.keyFor() 方法</h4><p>使用<code>Symbol.keyFor()</code> 来查询全局注册表。这个方法接收符号，返回全局符号对应的字符串。如果查询不到字符串则返回 undefined。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> barSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;foobar&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(barSymbol));<span class="hljs-comment">// foobar</span></code></pre></div><h3 id="7-3-使用符号作为属性"><a href="#7-3-使用符号作为属性" class="headerlink" title="7.3 使用符号作为属性"></a>7.3 使用符号作为属性</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;bar&quot;</span>);<span class="hljs-keyword">let</span> obj = &#123;[s1]: <span class="hljs-string">&quot;foo val&quot;</span>,&#125;;obj[s2]=<span class="hljs-string">&#x27;bar val&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">// &#123;Symbol(foo): &#x27;foo val&#x27;, Symbol(bar): &#x27;bar val&#x27;&#125;</span></code></pre></div><h2 id="8-BigInt-类型"><a href="#8-BigInt-类型" class="headerlink" title="8 BigInt 类型"></a>8 BigInt 类型</h2><p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt">MDN</a>。</p><h2 id="9-Object-类型"><a href="#9-Object-类型" class="headerlink" title="9 Object 类型"></a>9 Object 类型</h2><p>ECMAScript 中，对象是一组数据和功能的集合。</p><ol><li><p>对象通过 new 操作符后跟上对象类型的名称来创建。也可以通过创建 Object 类型实例来创建自己的对象，随后添加属性和方法。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()</code></pre></div><p>ECMAScript 只要求在给构造函数传递参数时使用括号，如果不传参数，可以省略括号。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span></code></pre></div></li><li><p>Object 是其它对象的基类，Object 类型的所有属性和方法在派生的对象上同样存在。</p></li><li><p>每个 Object 实例上都有下面的属性和方法：</p><ul><li><code>constructor</code>：用于创建当前对象（函数）。</li><li><code>hasOwnProperty(propertyName)</code>：判断当前对象实例（而不是原型）上是否存在在给定的属性。</li><li><code>isPrototypeof(object)</code>：判断当前对象是否为另一个对象的原型。</li><li><code>propertyIsEnumerable(propertyName)</code>：判断给定的属性是否可枚举。</li><li><code>toLocaleString()</code>：返回对象的字符串表示。该字符串反映对象所在的<strong>本地化环境</strong>。</li><li><code>toString()</code>：返回对象的字符串表示。</li><li><code>valueOf()</code>：返回对象的原始值。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】4.语言基础 - 变量</title>
    <link href="/archives/78d9e65d.html"/>
    <url>/archives/78d9e65d.html</url>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>ECMAScript 6 之前只支持 var 关键字，ECMAScript 6 开始支持 let 和 const。</p><h2 id="1-var-关键字"><a href="#1-var-关键字" class="headerlink" title="1 var 关键字"></a>1 var 关键字</h2><h3 id="1-1-var-声明作用域"><a href="#1-1-var-声明作用域" class="headerlink" title="1.1 var 声明作用域"></a>1.1 var 声明作用域</h3><p>使用 var 操作符定义的变量会成为<strong>包含它的函数</strong>的局部变量。使用 var 在一个函数中定义的变量，意味着变量在退出函数时销毁：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">var</span> message = <span class="hljs-string">&#x27;hello&#x27;</span>;<span class="hljs-comment">// 使用 var 在函数中定义局部变量</span>&#125;<span class="hljs-title function_">test</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<span class="hljs-comment">// 出错</span></code></pre></div><p>省略 var 操作符可以将变量定义为<strong>全局变量</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;    message = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">// 全局变量</span>&#125;<span class="hljs-title function_">test</span>();<span class="hljs-comment">// 调用</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<span class="hljs-comment">// hello </span></code></pre></div><p>省略掉 var 操作符后，message 成了全局变量。但是，必须在 test() 函数被<strong>调用</strong>一次后才能访问到全局变量 message。</p><h3 id="1-2-var-声明提升"><a href="#1-2-var-声明提升" class="headerlink" title="1.2 var 声明提升"></a>1.2 var 声明提升</h3><p><strong>声明提升</strong>，就是把所有的变量声明都拉到函数作用域的顶部。比如，下面这种形式不会报错：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<span class="hljs-comment">// undefined</span>    <span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hello&quot;</span>;&#125;<span class="hljs-title function_">test</span>();</code></pre></div><p>因为，ECMAScript 在运行时将上面的代码看成下面的代码：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">var</span> messsge;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<span class="hljs-comment">// undefined</span>    message = <span class="hljs-string">&quot;hello&quot;</span>;&#125;<span class="hljs-title function_">test</span>();</code></pre></div><p>此外，<strong>多次声明同一变量</strong>也没有问题：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-keyword">var</span> a;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// 2</span></code></pre></div><h2 id="2-let-关键字"><a href="#2-let-关键字" class="headerlink" title="2 let 关键字"></a>2 let 关键字</h2><p>let 和 var 的作用差不多，最明显的区别是，let 声明的范围是<strong>块作用域</strong>，而 var 声明的是<strong>函数作用域</strong>。块作用域是函数作用域的<strong>子集</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">// var 声明的变量属于函数作用域，范围大于块作用域</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// 1</span><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<span class="hljs-comment">// let 声明的变量属于块作用域</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<span class="hljs-comment">// 出错</span></code></pre></div><p>let <strong>不允许</strong>同一个块作用域下出现冗余声明。并且，对于冗余声明的报错不因<strong>混用</strong> let 和 var 受影响。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<span class="hljs-keyword">var</span> a;<span class="hljs-keyword">let</span> b;<span class="hljs-keyword">let</span> b;<span class="hljs-comment">// 报错</span><span class="hljs-keyword">let</span> c;<span class="hljs-keyword">var</span> c;<span class="hljs-comment">// 报错</span><span class="hljs-keyword">var</span> d;<span class="hljs-keyword">let</span> d;<span class="hljs-comment">// 报错</span></code></pre></div><p>JavaScript 引擎会记住变量声明标识符及其所在的块作用域。因此嵌套使用标识符不会出错，因为在<strong>同一个块</strong>中没有嵌套声明：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);   <span class="hljs-comment">// 1</span></code></pre></div><h3 id="2-1-暂时性死区"><a href="#2-1-暂时性死区" class="headerlink" title="2.1 暂时性死区"></a>2.1 暂时性死区</h3><p>let 和 var 的另一个重要区别是，let <strong>不会</strong>声明提升。在 let 声明前使用变量的执行瞬间叫做<strong>暂时性死区</strong>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// undefined （声明提升，不会报错）</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<span class="hljs-comment">// 报错（此时称为暂时性死区）</span><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);</code></pre></div><p>虽然 JavaScript 引擎会注意到后面的变量声明，但是不会像 var 那样进行声明提升。</p><h3 id="2-2-全局声明"><a href="#2-2-全局声明" class="headerlink" title="2.2 全局声明"></a>2.2 全局声明</h3><p>与 var 关键字不同，使用 let 声明的变量不会成为 window 对象的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>);<span class="hljs-comment">// 1</span><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">b</span>);<span class="hljs-comment">// undefined</span></code></pre></div><h3 id="2-3-条件声明"><a href="#2-3-条件声明" class="headerlink" title="2.3 条件声明"></a>2.3 条件声明</h3><p>let 无法使用条件声明。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// let b;</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;    <span class="hljs-keyword">let</span> b;<span class="hljs-comment">// b被限制在if的块作用域内。这里声明的b，外面是感知不到的。</span>&#125;b = <span class="hljs-number">2</span>;<span class="hljs-comment">// 因为没有感知到上面定义的b，所以这里相当于对全局变量b赋值。</span></code></pre></div><p>注意：条件声明是一种反模式，<strong>尽量不要用条件声明</strong>。</p><h3 id="2-4-for-循环中的-let-声明"><a href="#2-4-for-循环中的-let-声明" class="headerlink" title="2.4 for 循环中的 let 声明"></a>2.4 for 循环中的 let 声明</h3><p>使用 var 定义循环变量会渗透到循环体外，造成污染：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">// 5</span></code></pre></div><p>使用 let 不会出现这个问题：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">// 报错，说明循环变量没有污染循环体外</span></code></pre></div><p>一个例子：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">// 5 5 5 5 5</span>    &#125;, <span class="hljs-number">100</span>);&#125;</code></pre></div><p>这个例子不会输出 0 1 2 3 4，而是会输出 5 5 5 5 5。这是因为退出循环时，迭代变量保存的是退出循环时的值 5。</p><p>而使用 let 不会出现这个问题，因为使用 let，引擎会为每个循环声明一个新的迭代变量：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">// 0 1 2 3 4 </span>    &#125;, <span class="hljs-number">100</span>);&#125;</code></pre></div><h2 id="3-const-声明"><a href="#3-const-声明" class="headerlink" title="3 const 声明"></a>3 const 声明</h2><p>const 的行为和 let 基本相同，唯一的重要区别是，const 声明的变量需要同时赋予初始值，并且修改 const 声明的变量会报错。</p><p>const 也不允许在同一个块中重复声明。</p><p>如果 const 变量引用的是一个对象，那么修改对象内部属性不会报错：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123;&#125;;a.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<span class="hljs-comment">// 没有违反const限制</span></code></pre></div><h2 id="4-声明风格与最佳实践"><a href="#4-声明风格与最佳实践" class="headerlink" title="4 声明风格与最佳实践"></a>4 声明风格与最佳实践</h2><ol><li>不使用 var</li><li>优先使用 const，在预知会修改变量时才去使用 let</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】3.语言基础 - 语法、标识符、关键字和保留字</title>
    <link href="/archives/9b501bb7.html"/>
    <url>/archives/9b501bb7.html</url>
    
    <content type="html"><![CDATA[<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h2><h3 id="1-1-区分大小写"><a href="#1-1-区分大小写" class="headerlink" title="1.1 区分大小写"></a>1.1 区分大小写</h3><p>ECMAScript 中一切都区分大小写。无论变量、函数名还是操作符，都区分大小写。<code>typeof</code>不能作为函数名，因为它是一个<strong>关键字</strong>，但是<code>Typeof</code>是有效的函数名。</p><h3 id="1-2-标识符"><a href="#1-2-标识符" class="headerlink" title="1.2 标识符"></a>1.2 标识符</h3><p><strong>标识符</strong>，就是变量、函数、属性和函数参数的名称。必须符合以下规定：</p><ul><li>第一个字符必须是一个字母、<code>_</code>或<code>$</code></li><li>其余字符可以是字母、<code>_</code>、<code>$</code>或数字</li></ul><blockquote><p>这里有一个疑问：<strong>属性名是标识符吗</strong>？</p><p><strong>带引号的</strong>属性的名不需要满足上述的规则，而且关键字，保留字，true，fasle等等都可以作为属性名。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123;<span class="hljs-string">&#x27;123abc&#x27;</span>: <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">const</span> b = &#123;<span class="hljs-attr">break</span>: <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">const</span> c = &#123;<span class="hljs-attr">true</span>: <span class="hljs-number">3</span>&#125;</code></pre></div><p>但是，如果在命名属性时<strong>不带引号</strong>，则需要满足上述的规则。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> d = &#123;123<span class="hljs-attr">abc</span>:<span class="hljs-number">1</span>&#125; <span class="hljs-comment">// 语法错误</span></code></pre></div></blockquote><p>注意：</p><ol><li><p>这里的字符可以是字母也可以是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Unicode">Unicode</a> 字母字符，比如汉字。</p></li><li><p>按照惯例，ECMAScript 中的标识符使用<strong>驼峰大小写</strong>，即第一个单词首字母小写，其余单词首字母大写。</p></li><li><p>关键字、保留字、<code>true</code>、<code>false</code>和<code>null</code>等等不能作为标识符。</p></li></ol><h3 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 单行注释</span><span class="hljs-comment">/*</span><span class="hljs-comment">多行注释</span><span class="hljs-comment">多行注释</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="1-4-语句"><a href="#1-4-语句" class="headerlink" title="1.4 语句"></a>1.4 语句</h3><ol><li><p>ECMAScript 中语句以分号结尾。<strong>语句末尾的分号不是必须的</strong>。</p></li><li><p>if 之类的控制语句<strong>只在执行多条语句时</strong>要求有代码块。最佳实践是始终在控制语句中使用代码块：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(test)&#123;...&#125;</code></pre></div></li></ol><h1 id="2-关键字和保留字"><a href="#2-关键字和保留字" class="headerlink" title="2 关键字和保留字"></a>2 关键字和保留字</h1><h2 id="2-1-关键字"><a href="#2-1-关键字" class="headerlink" title="2.1 关键字"></a>2.1 关键字</h2><p>ECMAScript 描述了一组关键字，它们有特殊用途。比如：控制语句开始和结束或者执行特定操作。</p><p><strong>关键字不能作为标识符和属性名来使用</strong>。</p><p>ECMAScript 第6版规定的关键字有：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">break</span>、<span class="hljs-keyword">do</span>、<span class="hljs-keyword">in</span>、<span class="hljs-keyword">typeof</span>、<span class="hljs-keyword">case</span>、<span class="hljs-keyword">else</span>、<span class="hljs-keyword">instanceof</span>、<span class="hljs-keyword">var</span>、<span class="hljs-keyword">catch</span>、<span class="hljs-keyword">export</span>、<span class="hljs-keyword">new</span>、<span class="hljs-keyword">void</span>、<span class="hljs-keyword">class</span>、<span class="hljs-keyword">extends</span>、<span class="hljs-keyword">return</span>、<span class="hljs-keyword">while</span>、<span class="hljs-keyword">const</span>、<span class="hljs-keyword">finally</span>、<span class="hljs-variable language_">super</span>、<span class="hljs-keyword">with</span>、<span class="hljs-keyword">continue</span>、<span class="hljs-keyword">for</span>、<span class="hljs-keyword">switch</span>、<span class="hljs-keyword">yield</span>、<span class="hljs-keyword">debugger</span>、<span class="hljs-keyword">function</span>、<span class="hljs-variable language_">this</span>、<span class="hljs-keyword">default</span>、<span class="hljs-keyword">if</span>、<span class="hljs-keyword">throw</span>、<span class="hljs-keyword">delete</span>、<span class="hljs-keyword">import</span>、<span class="hljs-keyword">try</span></code></pre></div><h2 id="2-2-保留字"><a href="#2-2-保留字" class="headerlink" title="2.2 保留字"></a>2.2 保留字</h2><p>保留字，在语言中没有特定的用途，但是它们是保留给未来做关键字用的。</p><p>同样地，<strong>保留字不能作为标识符和属性名来使用</strong>。</p><p>ECMAScript 第6版保留字：</p><ol><li>始终保留：<code>enum</code></li><li>严格模式下保留：<code>implements</code>、<code>package</code>、<code>public</code>、<code>interface</code>、<code>protected</code>、<code>static</code>、<code>let</code>、<code>private</code></li><li>模块代码中保留：<code>await</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】2.HTML中的JavaScript</title>
    <link href="/archives/a34cc8fd.html"/>
    <url>/archives/a34cc8fd.html</url>
    
    <content type="html"><![CDATA[<h1 id="HTML中的JavaScript"><a href="#HTML中的JavaScript" class="headerlink" title="HTML中的JavaScript"></a>HTML中的JavaScript</h1><h2 id="1-lt-script-gt-元素"><a href="#1-lt-script-gt-元素" class="headerlink" title="1 &lt;script&gt;元素"></a>1 <code>&lt;script&gt;</code>元素</h2><p>使用<code>&lt;script&gt;</code>元素在 HTML 中插入 JavaScript。</p><p><strong><code>&lt;script&gt;</code>元素的属性</strong>：</p><ul><li><p><code>src</code>：（可选）引用外部脚本的 URI，用来代替在文档中插入脚本。</p></li><li><p><code>type</code>：（可选）指定脚本语言的内容类型（MIME 类型）。缺失会被视为 JavaScript。<strong>最好不指定 type 属性</strong>。</p></li><li><p><code>async</code>：（可选）表示应该<strong>并行</strong>下载该脚本并尽快解析执行。只对<strong>外部脚本文件</strong>生效。这是一个<strong>布尔属性</strong>，存在即为 true 值，缺失即为 false 值。</p></li><li><p><code>defer</code>：（可选）表示应该在文档完成解析后执行该脚本。只对<strong>外部脚本文件</strong>生效。布尔属性。</p></li><li><p><code>crossorigin</code>：（可选）配置相关请求的 CORS 设置。</p><table><thead><tr><th>可选值</th><th>描述</th></tr></thead><tbody><tr><td>anonymous,””</td><td>对此元素的 CORS 请求将不设置凭据标志。</td></tr><tr><td>use-credentials</td><td>对此元素的 CORS 请求将设置凭证标志；这意味着请求将提供凭据。</td></tr></tbody></table></li><li><p><code>integrity</code>：（可选）表示允许将接收到的资源签名和指定的加密签名进行比对，用来验证子资源的完整性。如果收到的资源签名和该属性指定的签名不匹配，则页面报错并且不会执行脚本。</p></li><li><p><code>nomodule</code>：（可选）这个布尔属性被设置来标明这个脚本在支持 <a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/">ES2015 modules</a> 的浏览器中<strong>不执行</strong>。 — 实际上，这可用于在不支持模块化 JavaScript 的旧浏览器中提供回退脚本。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script#attr-nonce"><code>nonce</code></a>：详见 MDN</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script#attr-referrerpolicy"><code>referrerpolicy</code></a>：：详见 MDN</p></li><li><p><code>charset</code>：（废弃）如果存在，值必须为 “<code>utf-8</code>” 。当然声明 <code>charset</code> 是没有必要的，因为页面文档必须使用 UTF-8，而 <code>script</code> 元素会从页面文档中继承这个属性。</p></li><li><p><code>language</code>：（废弃）和 type 属性类似，这个属性定义脚本使用的语言。 但是与 type 不同的是，这个属性的可能值从未被标准化过。请用<code>type</code>属性代替这个属性。</p></li></ul><p><strong>注意</strong>：</p><ol><li>使用 <code>src</code>属性的<code>&lt;script&gt;</code>元素不应该在标签中包含其它代码。如果两者都提供，浏览器只会下载并执行脚本文件，不会执行标签中的代码。</li><li>如果<code>src</code>是一个完整的 URL，那么浏览器会向这个 URL 发送一个 <strong>GET</strong> 请求，以获取响应的资源。这个请求<strong>不受同源策略的限制</strong>，但是获取到的 JavaScript 内容是受同源策略限制的。</li></ol><h3 id="1-1-标签位置"><a href="#1-1-标签位置" class="headerlink" title="1.1 标签位置"></a>1.1 标签位置</h3><p>通常将所有的 JavaScript 引用放在<code>&lt;body&gt;</code>元素中、页面内容的后面。例如：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 这里是页面内容 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;... ...&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-comment">// ... ... </span></span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>这样，页面内容会在处理 JavaScript <strong>前</strong>渲染，减少了页面空白时间。</p><h3 id="1-2-异步执行脚本"><a href="#1-2-异步执行脚本" class="headerlink" title="1.2 异步执行脚本"></a>1.2 异步执行脚本</h3><p>如果<code>&lt;script&gt;</code>标签使用了<code>async</code>属性，浏览器会<strong>立即下载</strong>脚本，并且<strong>不会阻塞</strong>页面的渲染。</p><p>注意：</p><ul><li>只适用于外部脚本。</li><li>如果有两个使用<code>async</code>属性的<code>&lt;script&gt;</code>标签，浏览器<strong>不保证</strong>执行顺序。</li></ul><p>例如：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 页面内容 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;... ...&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;... ...&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>这个例子中，第二个脚本<strong>未必</strong>在第一个脚本之后执行。</p><h3 id="1-3-推迟执行脚本"><a href="#1-3-推迟执行脚本" class="headerlink" title="1.3 推迟执行脚本"></a>1.3 推迟执行脚本</h3><p>如果<code>&lt;script&gt;</code>标签使用了<code>defer</code>属性，浏览器会<strong>立即下载</strong>脚本，但是会在<strong>整个页面解析完成后</strong>再去<strong>执行</strong>脚本。例如：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;... ...&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 页面内容 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>这个例子中，虽然<code>script</code>标签写在<code>head</code>标签内。但是因为其具有<code>defer</code>属性，浏览器会解析完 DOM 后再去执行该脚本。</p><p><strong>注意</strong>：</p><ul><li><p>只适用于外部脚本。</p></li><li><p>如果有两个<code>defer</code>属性的脚本，浏览器会<strong>按照次序</strong>去<strong>顺序</strong>执行。</p></li></ul><h3 id="1-4-动态加载脚本"><a href="#1-4-动态加载脚本" class="headerlink" title="1.4 动态加载脚本"></a>1.4 动态加载脚本</h3><p>除了使用<code>script</code>标签，还可以通过向 DOM 中动态添加<code>script</code>元素的方式加载指定脚本。例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);script.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.2.33/vue.cjs.js&quot;</span>;<span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);</code></pre></div><p><strong>注意</strong>：</p><ol><li><p>默认情况下这种方式是异步形式进行加载的，相当于加上了<code>async</code>属性。</p></li><li><p>以这种形式获取的资源对浏览器<strong>预加载器</strong>是不可见的。想要让预加载器知道这些动态请求文件的存在，可以在文档的头部进行显式声明。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.2.33/vue.cjs.js&quot;</span>&gt;</span></code></pre></div></li></ol><h2 id="2-行内代码和外部文件"><a href="#2-行内代码和外部文件" class="headerlink" title="2 行内代码和外部文件"></a>2 行内代码和外部文件</h2><p>虽然可以在 HTML 中嵌入 JavaScript 代码，但是最佳实践时尽可能将 JavaScript 代码放在<strong>外部文件</strong>中。优点有：</p><ul><li>可维护性。使用一个目录保存所有 JavaScript 代码，比将 JavaScript 代码分散到各个 HTML 中更容易维护。</li><li>缓存。浏览器可以缓存所有外部链接文件。如果两个页面用到了同一个文件，那么浏览器就可以从缓存中加载该文件。</li></ul><h2 id="3-lt-noscript-gt-元素"><a href="#3-lt-noscript-gt-元素" class="headerlink" title="3 &lt;noscript&gt;元素"></a>3 <code>&lt;noscript&gt;</code>元素</h2><p><code>noscript</code>元素可以包含在任何出现在<code>body</code>中的 HTML 元素，<code>&lt;scrpit&gt;</code>除外。在下面两种情况下，浏览器将显示包含在<code>noscript</code>中的内容：</p><ol><li>浏览器不支持脚本。</li><li>浏览器对脚本的支持被禁用。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript红宝书】1.什么是JavaScript</title>
    <link href="/archives/175876eb.html"/>
    <url>/archives/175876eb.html</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-JavaScript"><a href="#什么是-JavaScript" class="headerlink" title="什么是 JavaScript"></a>什么是 JavaScript</h1><h2 id="简短的历史回顾"><a href="#简短的历史回顾" class="headerlink" title="简短的历史回顾"></a>简短的历史回顾</h2><p>1995年，网景公司的工程师 Brendan Eich 为即将发布的浏览器开发了一个叫做 Mocha 的脚本语言。后来这门脚本语言改名叫做 LiveScript。为了赶上发布时间，网景公司和 Sun 公司合作，共同完成 LiveScript 的开发。当时 Java 语言被媒体热烈炒作，因此网景公司将 LiveScript 改名为 JavaScript。</p><p>1996年8月，微软 IE 浏览器带着名为 JScript 的 JavaScript 实现重磅进入 Web 浏览器领域。JavaScript 两个不同版本并存的问题日渐突出，随后走上了标准化的征程。</p><p>1997年，JavaScript 1.1 作为提案提交给欧洲计算机制造商协会（Ecma）。第39技术委员会（TC39）承担了 JavaScript 标准化的任务，并在数月时间内打造出了 ECMA-262，也就是 ECMAScript 这个<strong>脚本语言标准</strong>。</p><p>此后，各家浏览器都以 ECMAScript 为实现的依据，虽然具体实现各有不同。</p><h2 id="JavaScript-实现"><a href="#JavaScript-实现" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h2><p>JavaScript 远远不限于 ECMAScript 标准，完整的 JavaScript 实现包括：</p><ul><li>核心（ECMAScript）</li><li>文档对象模型（DOM），提供与<strong>网页内容</strong>交互的方法和接口</li><li>浏览器对象模型（BOM），提供与<strong>浏览器</strong>交互的方法和接口</li></ul><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><p>ECMAScript 并不局限于 Web 浏览器。Web 浏览器只是 ECMAScript 可能存在于的一种<strong>宿主环境</strong>。宿主环境提供 ECMAScript 的标准实现和与环境本身交互的扩展。宿主环境除了 Web 浏览器，还有 Node.js 等。</p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型（DOM, Document Object Model）是一个 API。DOM 通过创建表示文档的<strong>树</strong>，让开发者随心所欲地通过操作<strong>节点</strong>来控制网页的内容。</p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型（BOM,Browser Object Model）是一个 API，用于支持访问和操作浏览器的窗口。使用 BOM，开发者可以操控浏览器显示页面之外的地方。BOM 没有相关标准。但是 HTML5 以规范的形式涵盖了尽可能多的 BOM 特性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux】Linux常用命令总结</title>
    <link href="/archives/e511c25d.html"/>
    <url>/archives/e511c25d.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Linux-文件系统"><a href="#1-Linux-文件系统" class="headerlink" title="1 Linux 文件系统"></a>1 Linux 文件系统</h1><h2 id="1-1-Linux-文件"><a href="#1-1-Linux-文件" class="headerlink" title="1.1 Linux 文件"></a>1.1 Linux 文件</h2><p>Linux 系统中一切皆文件。</p><h2 id="1-2-Linux-目录结构"><a href="#1-2-Linux-目录结构" class="headerlink" title="1.2 Linux 目录结构"></a>1.2 Linux 目录结构</h2><p>Linux 的目录是一颗树。逻辑上是以 <code>/</code>  为根的树，物理上通过<strong>挂载点</strong>实现不同的目录写入不同的硬盘或者分区。</p><blockquote><p>进入某个目录：<code>cd 目录名</code></p></blockquote><ul><li><code>/bin</code>：二进制文件，通常是一些命令。（链接，指向了<code>/usr/bin</code>）</li><li><code>/sbin</code>：超级管理员命令。（链接，指向了<code>/usr/sbin</code>）</li><li><code>/usr</code>：用户相关</li><li><code>/dev</code>：设备相关</li><li><code>/lib</code>：库文件。（链接，指向了<code>/usr/lib</code>）</li><li><code>/lib64</code>：库文件。（链接，指向了<code>/usr/lib64</code>）</li><li><code>/etc</code>：配置相关</li><li><code>/home</code>：普通用户的文件夹</li><li><code>/root</code>：超级管理员用户的主文件夹</li><li><code>/opt</code>：第三方软件默认存放的位置</li><li><code>/media</code>：可移动媒体设备（U盘、光驱）的挂载点</li><li><code>/mnt</code>：可移动媒体设备的另一个挂载点</li><li><code>/proc</code>：系统进程相关</li><li><code>/run</code>：当前系统运行信息，重启后清空</li><li><code>/srv</code>：服务相关</li><li><code>/sys</code>：系统硬件相关信息</li><li><code>/tmp</code>：存放临时文件</li><li><code>/var</code>：存放经常修改的文件，比如日志</li><li><code>/boot</code>：引导分区</li></ul><h1 id="2-Vim-编辑器"><a href="#2-Vim-编辑器" class="headerlink" title="2 Vim 编辑器"></a>2 Vim 编辑器</h1><h2 id="2-1-Vi-x2F-Vim-是什么"><a href="#2-1-Vi-x2F-Vim-是什么" class="headerlink" title="2.1 Vi &#x2F; Vim 是什么"></a>2.1 Vi &#x2F; Vim 是什么</h2><ol><li>Vi 是 Unix 操作系统中最通用的文本编辑器</li><li>Vim 是从 Vi 发展出来的更强大的文本编辑器，完全兼容 Vi</li></ol><h2 id="2-2-三种模式"><a href="#2-2-三种模式" class="headerlink" title="2.2 三种模式"></a>2.2 三种模式</h2><ol><li><p>一般模式：</p><p>即在终端输入 <code>vim 文件名</code> 后进入的模式。</p><p>主要操作是删除、复制和粘贴。</p></li><li><p>编辑模式：</p><p>一般模式下输入 <code>i</code>、<code>a</code> 或 <code>o</code>进入编辑模式。</p><p>编辑模式下按下 <code>ESC</code> 退出编辑模式，进入一般模式。</p><p>主要操作是编辑文本。</p></li><li><p>命令模式：</p><p>一般模式下输入 <code>:</code> 或者 <code>/</code> 进入命令模式。</p><blockquote><p>常用命令：<code>:wq</code> <code>:q</code> <code>:q!</code></p></blockquote></li></ol><h2 id="2-3-一般模式"><a href="#2-3-一般模式" class="headerlink" title="2.3 一般模式"></a>2.3 一般模式</h2><ol><li><p><code>yy</code>：复制当前行。<code>5yy</code>：复制包括当前行在内的5行。</p></li><li><p><code>y$</code>：复制光标位置到当前行结束的内容。<code>y^</code>：复制当前行开始到光标前一个位置的内容。</p></li><li><p><code>yw</code>：复制当前词</p></li><li><p><code>p</code>：粘贴</p></li><li><p><code>dd</code>：删除当前行。<code>3dd</code>：删除包括当前行在内的3行。</p></li><li><p><code>d$</code>：删除光标位置到当前行结束的内容。<code>d^</code>：删除当前行开始到光标前一个位置的内容。</p></li><li><p><code>dw</code>：删除当前词</p></li><li><p><code>u</code>：撤销</p></li><li><p><code>x</code>：剪切</p></li><li><p><code>r</code>：替换当前字符。<code>R</code> ：替换模式。</p></li><li><p><code>^</code>：移动到行头</p></li><li><p><code>$</code>：移动到行尾</p></li><li><p><code>w</code>：移动到下一个词的词头</p></li><li><p><code>e</code>：移动到当前词尾</p></li><li><p><code>b</code>：移动到当前词的词头</p></li><li><p><code>gg</code> 或 <code>H</code>：移动到文档开头</p></li><li><p><code>G</code> 或 <code>L</code>：移动到文档最后一行开头。<code>3G</code>：移动到第3行行头</p></li></ol><h2 id="2-4-编辑模式"><a href="#2-4-编辑模式" class="headerlink" title="2.4 编辑模式"></a>2.4 编辑模式</h2><ol><li><p>进入编辑模式</p><ul><li><code>i</code>：当前光标前插入。<code>I</code>：当前行的最前插入。</li><li><code>a</code>：当前光标后插入。<code>A</code>：当前行的最后插入。</li><li><code>o</code>：当前行的下一行。<code>O</code>：当前行的上一行。</li></ul></li><li><p>退出编辑模式</p><p>按下 <code>ESC</code></p></li></ol><h2 id="2-5-命令模式"><a href="#2-5-命令模式" class="headerlink" title="2.5 命令模式"></a>2.5 命令模式</h2><ol><li><p>输出 <code>:</code> 进入命令模式</p><ul><li><code>w</code>：保存</li><li><code>q</code>：退出</li><li><code>wq</code>：保存并退出</li><li><code>q!</code>：丢弃更改并强制退出</li><li><code>set nu</code>：显示行号。<code>set nonu</code>：隐藏行号。</li></ul></li><li><p>输入 <code>:/keyword</code>  按下回车，可以进行关键词查找。按 <code>n</code> 跳转到下一个关键词位置。按 <code>N</code> 跳转到上一个关键词位置。</p></li><li><p>输入 <code>:s/oldWord/newWord</code> 按下回车，可以将当前行第一个 <code>oldWord</code> 替换成 <code>newWord</code>。输入<code>:s/oldWord/newWord/g</code> 按下回车，可以将当前行所有 <code>oldWord</code> 替换成 <code>newWord</code>。输入<code>:%s/oldWord/newWord</code> 按下回车，可以将所有行第一个 <code>oldWord</code> 替换成 <code>newWord</code>。输入 <code>:%s/oldWord/newWord/g</code> 按下回车，可以将所有行<code>oldWord</code> 替换成 <code>newWord</code>。</p></li></ol><h1 id="3-网络配置和系统管理"><a href="#3-网络配置和系统管理" class="headerlink" title="3 网络配置和系统管理"></a>3 网络配置和系统管理</h1><ol><li><p>查看网络配置  </p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span></code></pre></div></li><li><p>修改网络配置</p><div class="code-wrapper"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/</span>vim ifcfg-网络设备名</code></pre></div></li><li><p>查看主机名</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hostname</span></code></pre></div></li><li><p>修改主机名</p><div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>hostname</code></pre></div><p>或</p><div class="code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> 新的主机名</code></pre></div><p>重启服务器即可</p></li><li><p>修改 hosts 文件</p><div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>hosts</code></pre></div></li></ol><h1 id="4-Linux-系统管理"><a href="#4-Linux-系统管理" class="headerlink" title="4 Linux 系统管理"></a>4 Linux 系统管理</h1><h2 id="4-1-进程和服务"><a href="#4-1-进程和服务" class="headerlink" title="4.1 进程和服务"></a>4.1 进程和服务</h2><ul><li>进程（process）：一个正在执行的程序或者命令</li><li>服务（service）：启动后一直存在，常驻内存</li></ul><h2 id="4-2-systemctl-命令"><a href="#4-2-systemctl-命令" class="headerlink" title="4.2 systemctl 命令"></a>4.2 systemctl 命令</h2><ol><li><p>基本语法</p><div class="code-wrapper"><pre><code class="hljs shell">systemctl start|stop|restart|enable|status 服务名</code></pre></div><p>分别表示启动、停止、重启、设置开机启动、查看当前状态</p></li><li><p>查看服务</p><div class="code-wrapper"><pre><code class="hljs shell">ls /usr/lib/systemd/system</code></pre></div></li></ol><h2 id="4-3-系统运行级别"><a href="#4-3-系统运行级别" class="headerlink" title="4.3 系统运行级别"></a>4.3 系统运行级别</h2><h3 id="4-3-1-Centos-7-中的运行级别"><a href="#4-3-1-Centos-7-中的运行级别" class="headerlink" title="4.3.1 Centos 7 中的运行级别"></a>4.3.1 Centos 7 中的运行级别</h3><ul><li><code>muti-user.target</code>：等价于运行级别3（多用户有网无GUI）</li><li><code>graphical.target</code>：等价于运行级别5（多用户有网有GUI）</li></ul><h3 id="4-3-2-查看运行级别"><a href="#4-3-2-查看运行级别" class="headerlink" title="4.3.2 查看运行级别"></a>4.3.2 查看运行级别</h3><div class="code-wrapper"><pre><code class="hljs actionscript">systemctl <span class="hljs-keyword">get</span>-<span class="hljs-keyword">default</span></code></pre></div><h3 id="4-3-3-查看服务是否开机自启动"><a href="#4-3-3-查看服务是否开机自启动" class="headerlink" title="4.3.3 查看服务是否开机自启动"></a>4.3.3 查看服务是否开机自启动</h3><div class="code-wrapper"><pre><code class="hljs delphi">systemctl list-<span class="hljs-keyword">unit</span>-files</code></pre></div><blockquote><p><strong>实战</strong>：开启&#x2F;关闭防火墙 </p><ol><li>查看防火墙服务状态</li></ol>  <div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status firewalld</span></code></pre></div><ol start="2"><li>关闭防火墙</li></ol>  <div class="code-wrapper"><pre><code class="hljs arduino">systemctl stop firewalld</code></pre></div><ol start="3"><li>开启防火墙</li></ol>  <div class="code-wrapper"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> firewalld</code></pre></div></blockquote><h2 id="4-4-关机和重启"><a href="#4-4-关机和重启" class="headerlink" title="4.4 关机和重启"></a>4.4 关机和重启</h2><h3 id="4-4-1-常见操作"><a href="#4-4-1-常见操作" class="headerlink" title="4.4.1 常见操作"></a>4.4.1 常见操作</h3><ul><li><code>sync</code>：将数据同步到硬盘中</li><li><code>halt</code>：停机。关闭系统，但不断电</li><li><code>poweroff</code>：关机，断电</li><li><code>reboot</code>：立即重启。相当于<code>shutdown -r now</code>。</li></ul><h3 id="4-4-2-关机"><a href="#4-4-2-关机" class="headerlink" title="4.4.2 关机"></a>4.4.2 关机</h3><ul><li><p>关机（默认一分钟后关机）</p><div class="code-wrapper"><pre><code class="hljs arduino">shutdown</code></pre></div></li><li><p>取消关机（未关机时操作）</p><div class="code-wrapper"><pre><code class="hljs arduino">shutdown -c</code></pre></div></li><li><p>立刻关机</p><div class="code-wrapper"><pre><code class="hljs arcade">shutdown <span class="hljs-built_in">now</span></code></pre></div></li><li><p>指定3分钟后关机</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">shutdown</span> <span class="hljs-number">3</span></code></pre></div></li><li><p>指定时间关机</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">shutdown</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span></code></pre></div></li></ul><h1 id="5-常用基本命令"><a href="#5-常用基本命令" class="headerlink" title="5 常用基本命令"></a>5 常用基本命令</h1><h2 id="5-1-帮助"><a href="#5-1-帮助" class="headerlink" title="5.1 帮助"></a>5.1 帮助</h2><h3 id="5-1-1-man-获取帮助信息"><a href="#5-1-1-man-获取帮助信息" class="headerlink" title="5.1.1 man 获取帮助信息"></a>5.1.1 man 获取帮助信息</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs inform7"><span class="hljs-keyword">man</span> 命令或配置文件</code></pre></div></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">man</span> <span class="hljs-built_in">ls</span></code></pre></div></li></ul><h3 id="5-1-2-help-获取-shell-内置命令的帮助信息"><a href="#5-1-2-help-获取-shell-内置命令的帮助信息" class="headerlink" title="5.1.2 help 获取 shell 内置命令的帮助信息"></a>5.1.2 help 获取 shell 内置命令的帮助信息</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">help</span> 内置命令</code></pre></div></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">help</span> <span class="hljs-built_in">cd</span></code></pre></div></li></ul><h3 id="5-1-3-–help-获取外部命令的帮助信息"><a href="#5-1-3-–help-获取外部命令的帮助信息" class="headerlink" title="5.1.3 –help 获取外部命令的帮助信息"></a>5.1.3 –help 获取外部命令的帮助信息</h3><ul><li>用法</li></ul>  <div class="code-wrapper"><pre><code class="hljs ada">外部命令 <span class="hljs-comment">--help</span></code></pre></div><ul><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> --<span class="hljs-built_in">help</span></code></pre></div></li></ul><h3 id="5-1-4-type-查看命令是内置命令还是外部命令"><a href="#5-1-4-type-查看命令是内置命令还是外部命令" class="headerlink" title="5.1.4 type 查看命令是内置命令还是外部命令"></a>5.1.4 type 查看命令是内置命令还是外部命令</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> 命令</code></pre></div></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">type</span> <span class="hljs-built_in">ls</span><span class="hljs-built_in">ls</span> 是 `<span class="hljs-built_in">ls</span> --color=auto<span class="hljs-string">&#x27; 的别名</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">type</span> <span class="hljs-keyword">cd</span><span class="hljs-keyword">cd</span> 是 <span class="hljs-keyword">shell</span> 内嵌</code></pre></div></li></ul><h2 id="5-2-文件目录相关"><a href="#5-2-文件目录相关" class="headerlink" title="5.2 文件目录相关"></a>5.2 文件目录相关</h2><h3 id="5-2-1-pwd-显示当前工作的绝对路径"><a href="#5-2-1-pwd-显示当前工作的绝对路径" class="headerlink" title="5.2.1 pwd 显示当前工作的绝对路径"></a>5.2.1 pwd 显示当前工作的绝对路径</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span></code></pre></div></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs awk">[root@localhost sysconfig]<span class="hljs-comment">#pwd</span><span class="hljs-regexp">/etc/</span>sysconfig</code></pre></div></li></ul><blockquote><p><strong>绝对路径</strong>：以 <code>/</code> 开头的路径。表示从根目录一直找到文件或文件夹</p><p><strong>相对路径</strong>：不以<code>/</code>开头的路径。表示从当前位置或上一级开始查找</p></blockquote><h3 id="5-2-2-ls-列目录内容"><a href="#5-2-2-ls-列目录内容" class="headerlink" title="5.2.2 ls 列目录内容"></a>5.2.2 ls 列目录内容</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs css">ls <span class="hljs-selector-attr">[选项]</span> <span class="hljs-selector-attr">[文件名]</span></code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-a, –all</td><td>列出目录中所有文件，包括以“.”开头的文件。</td></tr><tr><td>-l</td><td>等同于 <code>ll</code>，长数据串列出，包含文件属性和权限等数据。</td></tr></tbody></table></li></ul><h3 id="5-2-3-mkdir-建立目录"><a href="#5-2-3-mkdir-建立目录" class="headerlink" title="5.2.3 mkdir 建立目录"></a>5.2.3 mkdir 建立目录</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs arduino">mkdir [选项] 目录</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p,  –parents</td><td>为所给出的目录建立丢失了的父目录。</td></tr></tbody></table><blockquote><p>例如：已存在目录&#x2F;a，当用到命令’mkdir &#x2F;a’ 时报错，而’mkdir -p &#x2F;a’则不会。</p></blockquote></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">test</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css">mkdir -<span class="hljs-selector-tag">p</span> /<span class="hljs-selector-tag">a</span>/<span class="hljs-selector-tag">b</span>/c</code></pre></div></li></ul><h3 id="5-2-4-rmdir-删除目录"><a href="#5-2-4-rmdir-删除目录" class="headerlink" title="5.2.4 rmdir 删除目录"></a>5.2.4 rmdir 删除目录</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs arduino">rmdir [选项] 目录</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p,  –parents</td><td>如果目录由多个路径名组成，从最后一个路径名开始依次删除，  直到所有的路径名都被删完。</td></tr></tbody></table></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> <span class="hljs-built_in">test</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css">rmdir -<span class="hljs-selector-tag">p</span> /<span class="hljs-selector-tag">a</span>/<span class="hljs-selector-tag">b</span>/c</code></pre></div></li></ul><h3 id="5-2-5-touch-创建空文件"><a href="#5-2-5-touch-创建空文件" class="headerlink" title="5.2.5 touch 创建空文件"></a>5.2.5 touch 创建空文件</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> 文件</code></pre></div></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> test.txt</code></pre></div></li></ul><h3 id="5-2-6-cp-复制文件或目录"><a href="#5-2-6-cp-复制文件或目录" class="headerlink" title="5.2.6 cp 复制文件或目录"></a>5.2.6 cp 复制文件或目录</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-keyword">cp</span> [选项] 文件路径<span class="hljs-keyword">cp</span> [选项] 文件...目录</code></pre></div><blockquote><p>cp 复制文件(或者目录等).  </p><p>可以使用这个命令复制一个文件到一个指定的目的地, 或者复制任意多个文件到一个目的目录.  </p><p>如果最后一个命令参数为一个已经存在的目录名,cp 会将每一个源文件复制到那个目录下(维持原文件名).</p><p>如果所给的参数只有两个文件名.它把前一个文件复制到后一个文件上.  (覆盖)</p><p>如果最后一个参数不是文件名,目录名,和给出多于两个非选项参数,是 错误的.</p></blockquote></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> test.txt /home</code></pre></div></li></ul><h3 id="5-2-7-rm-删除文件或目录"><a href="#5-2-7-rm-删除文件或目录" class="headerlink" title="5.2.7 rm 删除文件或目录"></a>5.2.7 rm 删除文件或目录</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> [选项] 文件</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-r, -R</td><td>递归地移除目录树。</td></tr><tr><td>-f</td><td>不作确认提示。不会写出诊断信息。</td></tr></tbody></table><blockquote><p>删除当前文件夹下的全部文件</p><p><code>rm -rf ./*</code></p></blockquote></li></ul><h3 id="5-2-8-mv-移动文件"><a href="#5-2-8-mv-移动文件" class="headerlink" title="5.2.8 mv 移动文件"></a>5.2.8 mv 移动文件</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> [选项] 源文件 目标文件<span class="hljs-built_in">mv</span> [选项] 源文件 目录</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-f</td><td>覆盖前不提示</td></tr><tr><td>-v</td><td>说明完成了什么</td></tr></tbody></table></li></ul><h3 id="5-2-9-cat-查看文件内容"><a href="#5-2-9-cat-查看文件内容" class="headerlink" title="5.2.9 cat 查看文件内容"></a>5.2.9 cat 查看文件内容</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> [选项] 文件</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-n</td><td>显示行号</td></tr></tbody></table></li></ul><h3 id="5-2-10-more-文件分屏查看器"><a href="#5-2-10-more-文件分屏查看器" class="headerlink" title="5.2.10 more 文件分屏查看器"></a>5.2.10 more 文件分屏查看器</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs dos"><span class="hljs-built_in">more</span> 文件</code></pre></div></li></ul><h3 id="5-2-11-less-文件分屏查看器"><a href="#5-2-11-less-文件分屏查看器" class="headerlink" title="5.2.11 less 文件分屏查看器"></a>5.2.11 less 文件分屏查看器</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">less</span> 文件</code></pre></div><blockquote><p>用法和<code>more</code>类似，但是 <code>less</code> 查看文件时不会一次性将文件加入内存，加载更快。</p></blockquote></li></ul><h3 id="5-2-12-echo-控制它输出"><a href="#5-2-12-echo-控制它输出" class="headerlink" title="5.2.12 echo 控制它输出"></a>5.2.12 echo 控制它输出</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 文本(控制台输出文本)</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $                   (控制台输出环境变量)</code></pre></div></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> hello linuxhello linux</code></pre></div></li></ul><h3 id="5-2-13-gt-输出重定向-gt-gt-追加"><a href="#5-2-13-gt-输出重定向-gt-gt-追加" class="headerlink" title="5.2.13 &gt;输出重定向  &gt;&gt;追加"></a>5.2.13 &gt;输出重定向  &gt;&gt;追加</h3><ol><li><p>将列表内容写入到文件中</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l &gt; 文件</code></pre></div><p>例：<code>ls -l out.txt</code></p></li><li><p>将列表内容追加到文件中</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l &gt;&gt; 文件</code></pre></div><p>例：<code>ls -l &gt;&gt; out.txt</code></p></li><li><p>将文件1的内容覆盖到文件2</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> 文件<span class="hljs-number">1</span> &gt; 文件<span class="hljs-number">2</span></code></pre></div><p>例：<code>cat demo1.txt &gt; demo2.txt</code></p></li><li><p>将一段文本追加到文件末尾</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文本&quot;</span> &gt;&gt; demo1.txt</code></pre></div></li></ol><h3 id="5-2-14-head-显示文件头部内容"><a href="#5-2-14-head-显示文件头部内容" class="headerlink" title="5.2.14 head 显示文件头部内容"></a>5.2.14 head 显示文件头部内容</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> [选项] 文件</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-n</td><td>指定显示文件开头的行数。（缺省默认显示10行）</td></tr></tbody></table></li><li><p>举例：显示 demo 文件的前5行</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">head</span> -n <span class="hljs-number">5</span> demo</code></pre></div></li></ul><h3 id="5-2-15-tail-显示文件尾部内容"><a href="#5-2-15-tail-显示文件尾部内容" class="headerlink" title="5.2.15 tail 显示文件尾部内容"></a>5.2.15 tail 显示文件尾部内容</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> [选项] 文件</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-n</td><td>指定显示文件末尾的行数。（缺省默认显示10行）</td></tr><tr><td>-f</td><td>实时监控更新。（<code>ctrl + c</code> 停止监控）</td></tr></tbody></table></li><li><p>举例：显示 demo 文件的末5行</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">tail</span> -n <span class="hljs-number">5</span> demo</code></pre></div></li></ul><h3 id="5-2-16-ln-软链接"><a href="#5-2-16-ln-软链接" class="headerlink" title="5.2.16 ln 软链接"></a>5.2.16 ln 软链接</h3><blockquote><p>软连接可以指向不同文件系统里的文件（比如由NFS装载的不同机器文件系统上的文件），甚至可以指向一个不一定确实存在的文件。在软连接文件被访问（系统调用）的时候，操作系统用该文件所包含的路径替换该文件的访问介入点，从而实现对所指文件的访问。</p></blockquote><ol><li><p>给原文件或目录创建一个软连接（相当于快捷方式）</p><div class="code-wrapper"><pre><code class="hljs css">ln -s <span class="hljs-selector-attr">[源文件或目录]</span> <span class="hljs-selector-attr">[软连接名]</span></code></pre></div></li><li><p>删除软连接</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> 软连接名   （只删除软连接，对应文件或目录不会被删除）</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf 软连接名/  （不仅删除软连接，对应真实目录下的文件也会被删除）</code></pre></div></li></ol><blockquote><p>一个硬连接仅仅是一个文件名。（一个文件可以有好几个文件名，只有将最后一个文件名从磁盘上删除，才能把这个文件删掉。文件名的个数是由ls(1)来确定的。所有的文件名都处于同一个状态，也就没有什么“源名字” 之说。通常文件系统里的一个文件的所有名字包含着一样的数据信息，不过这样也不是必需的。）</p></blockquote><h3 id="5-2-17-history-查看执行过的历史指令"><a href="#5-2-17-history-查看执行过的历史指令" class="headerlink" title="5.2.17 history 查看执行过的历史指令"></a>5.2.17 history 查看执行过的历史指令</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">history</span><span class="hljs-built_in">history</span> 10!命令编号<span class="hljs-built_in">history</span> -c 清空历史</code></pre></div><h2 id="5-3-日期时间相关"><a href="#5-3-日期时间相关" class="headerlink" title="5.3 日期时间相关"></a>5.3 日期时间相关</h2><h3 id="5-3-1-date-打印系统日期和时间"><a href="#5-3-1-date-打印系统日期和时间" class="headerlink" title="5.3.1 date 打印系统日期和时间"></a>5.3.1 date 打印系统日期和时间</h3><ul><li><p>用法</p><ol><li><p>打印当前日期和时间</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">date</span></code></pre></div></li><li><p>打印当前年份</p><div class="code-wrapper"><pre><code class="hljs mel"><span class="hljs-keyword">date</span> +%Y</code></pre></div></li><li><p>打印当前月份</p><div class="code-wrapper"><pre><code class="hljs mel"><span class="hljs-keyword">date</span> +%m</code></pre></div></li><li><p>打印当前日期</p><div class="code-wrapper"><pre><code class="hljs mel"><span class="hljs-keyword">date</span> +%d</code></pre></div></li><li><p>打印指定格式的日期和时间</p><div class="code-wrapper"><pre><code class="hljs mel"><span class="hljs-keyword">date</span> +%Y-%m-%d_%H:%M:%S</code></pre></div></li></ol></li></ul><h3 id="5-3-2-cal-查看日历"><a href="#5-3-2-cal-查看日历" class="headerlink" title="5.3.2 cal 查看日历"></a>5.3.2 cal 查看日历</h3><ul><li><p>用法</p><ol><li><p>查看当前月的日历</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">cal</span></code></pre></div></li><li><p>查看上个月、当月、下个月的日历</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cal</span> -<span class="hljs-number">3</span></code></pre></div></li><li><p>查看当年日历</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">cal -y</span></code></pre></div></li></ol></li></ul><h2 id="5-4-用户管理相关"><a href="#5-4-用户管理相关" class="headerlink" title="5.4 用户管理相关"></a>5.4 用户管理相关</h2><h3 id="5-4-1-useradd-添加用户"><a href="#5-4-1-useradd-添加用户" class="headerlink" title="5.4.1 useradd 添加用户"></a>5.4.1 useradd 添加用户</h3><ol><li><p>添加一个用户</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">useradd</span> 用户名</code></pre></div></li><li><p>添加一个用户到某个组</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">useradd</span> 组名 用户名</code></pre></div></li><li><p>添加用户并指定主目录名</p><div class="code-wrapper"><pre><code class="hljs awk">useradd -d <span class="hljs-regexp">/home/</span>目录名 用户名</code></pre></div></li><li><p>添加用户并指定到存在的用户组</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">useradd</span> -g 用户组 用户</code></pre></div></li></ol><h3 id="5-4-2-passwd-修改用户密码"><a href="#5-4-2-passwd-修改用户密码" class="headerlink" title="5.4.2 passwd 修改用户密码"></a>5.4.2 passwd 修改用户密码</h3><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">passwd</span> 用户名</code></pre></div><h3 id="5-4-3-id-查看用户-UID-GID"><a href="#5-4-3-id-查看用户-UID-GID" class="headerlink" title="5.4.3 id 查看用户 UID GID"></a>5.4.3 id 查看用户 UID GID</h3><ol><li><p>查看当前用户的 UID GID</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span></code></pre></div></li><li><p>查看指定用户的 UID GID （也可以用来判断有没有这个用户）</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span> 用户名</code></pre></div></li></ol><h3 id="5-4-4-su-切换用户（switch-user）"><a href="#5-4-4-su-切换用户（switch-user）" class="headerlink" title="5.4.4 su 切换用户（switch user）"></a>5.4.4 su 切换用户（switch user）</h3><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">su root</span></code></pre></div><blockquote><p>root 用户切换到普通用户无密码</p><p>普通用户切换到普通用户需要密码</p><p>普通用户切换到 root 用户需要密码</p></blockquote><blockquote><p>切换用户相当于在当前会话内部嵌套了一层会话，使用 <code>exit</code> 退出当前会话，回到上一层会话。</p></blockquote><h3 id="5-4-5-who-am-i-和-whoami-查看当前登录用户身份"><a href="#5-4-5-who-am-i-和-whoami-查看当前登录用户身份" class="headerlink" title="5.4.5 who am i 和 whoami 查看当前登录用户身份"></a>5.4.5 who am i 和 whoami 查看当前登录用户身份</h3><ol><li><p>查看当前用户信息（创建最外层会话的用户）</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">who</span></code></pre></div><p>相当于</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">who</span> am i</code></pre></div><blockquote><p>如果 root 用户切换到 test 用户，此时输入 <code>who</code> 或 <code>who am i</code>   显示 <code>root</code></p></blockquote></li><li><p>查看当前用户信息（当前目前会话的用户）</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span></code></pre></div><blockquote><p>如果 root 用户切换到 test 用户，此时输入 <code>whoami</code> 显示 <code> test</code></p></blockquote></li></ol><h3 id="5-4-6-sudo-允许用户以超级用户执行命令"><a href="#5-4-6-sudo-允许用户以超级用户执行命令" class="headerlink" title="5.4.6 sudo 允许用户以超级用户执行命令"></a>5.4.6 sudo 允许用户以超级用户执行命令</h3><blockquote><p>只有在 <code>/etc/sudoers</code> 文件中被允许的用户才可以使用 <code>sudo</code> 提升权限</p></blockquote><h3 id="5-4-7-userdel-删除用户"><a href="#5-4-7-userdel-删除用户" class="headerlink" title="5.4.7 userdel 删除用户"></a>5.4.7 userdel 删除用户</h3><div class="code-wrapper"><pre><code class="hljs bash">userdel <span class="hljs-built_in">test</span></code></pre></div><p>注意：删除用户后，用户在 <code>/home</code> 下的文件夹还在。</p><h3 id="5-4-8-usermod-修改用户信息"><a href="#5-4-8-usermod-修改用户信息" class="headerlink" title="5.4.8 usermod 修改用户信息"></a>5.4.8 usermod 修改用户信息</h3><ol><li><p>添加用户到组</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">usermod</span> -g 组名 用户名</code></pre></div></li></ol><h3 id="5-4-9-groupadd-添加组"><a href="#5-4-9-groupadd-添加组" class="headerlink" title="5.4.9 groupadd 添加组"></a>5.4.9 groupadd 添加组</h3><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">groupadd</span> 组名</code></pre></div><h3 id="5-4-10-groupmod-修改组"><a href="#5-4-10-groupmod-修改组" class="headerlink" title="5.4.10 groupmod 修改组"></a>5.4.10 groupmod 修改组</h3><ol><li><p>修改组名</p><div class="code-wrapper"><pre><code class="hljs excel">groupmod -<span class="hljs-built_in">n</span> 新组名组名</code></pre></div></li></ol><h3 id="5-4-11-groupdel-删除组"><a href="#5-4-11-groupdel-删除组" class="headerlink" title="5.4.11 groupdel 删除组"></a>5.4.11 groupdel 删除组</h3><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">groupdel</span> 组名</code></pre></div><h2 id="5-5-文件权限相关"><a href="#5-5-文件权限相关" class="headerlink" title="5.5 文件权限相关"></a>5.5 文件权限相关</h2><h3 id="5-5-1-文件属性"><a href="#5-5-1-文件属性" class="headerlink" title="5.5.1 文件属性"></a>5.5.1 文件属性</h3><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p><p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p><ul><li><p>chown (change ownerp) ： 修改所属用户与组。</p></li><li><p>chmod (change mode) ： 修改用户的权限。</p></li></ul><p>在 Linux 中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组。</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs tap">[root@localhost ~]<span class="hljs-comment"># ll</span>总用量 36-rw-------.<span class="hljs-number"> 1 </span>root root <span class="hljs-number"> 1688 </span>4月  <span class="hljs-number"> 1 </span>18:08 anaconda-ks.cfg-rw-r--r--.<span class="hljs-number"> 1 </span>root root <span class="hljs-number"> 1736 </span>4月  <span class="hljs-number"> 1 </span>18:11 initial-setup-ks.cfg-rw-r--r--.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 27051 </span>3月 <span class="hljs-number"> 29 </span>15:05 install.sh</code></pre></div><p>每个部分代表的意义：</p><p><img src="/./images/Linux%E7%AC%94%E8%AE%B0/file-llls22.jpg" alt="img"></p><h3 id="5-5-2-文件权限"><a href="#5-5-2-文件权限" class="headerlink" title="5.5.2 文件权限"></a>5.5.2 文件权限</h3><p><img src="/./images/Linux%E7%AC%94%E8%AE%B0/363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p><p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p><p>第 <strong>0</strong> 位确定文件类型。</p><ul><li><code>d</code>：目录文件</li><li><code>l</code>：链接</li><li><code>c</code>：字符类型的设备文件。如：鼠标、键盘</li><li><code>b</code>：块类型的设备文件。如：硬盘</li><li><code>-</code>：文件</li></ul><p>第 <strong>1-3</strong> 位确定<strong>属主</strong>（该文件的所有者）拥有该文件的权限。</p><p>第<strong>4-6</strong>位确定<strong>属组</strong>（所有者的同组用户）拥有该文件的权限。</p><p>第<strong>7-9</strong>位确定<strong>其他用户</strong>拥有该文件的权限。</p><p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p><p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p><h3 id="5-5-3-chmod-更改文件权限"><a href="#5-5-3-chmod-更改文件权限" class="headerlink" title="5.5.3 chmod 更改文件权限"></a>5.5.3 chmod 更改文件权限</h3><ol><li><p>第一种</p><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">chmod</span>  <span class="hljs-params">(u g o a)</span>   <span class="hljs-params">(+ - =)</span>   <span class="hljs-params">(r w x)</span>   文件或目录</span></code></pre></div><blockquote><p><code>u</code>：所有者<code>g</code>：所有组<code>o</code>：其它用户<code>a</code>：所有人    (缺省为所有人)</p><p><code>+</code>：添加权限<code>-</code>：删除权限<code>=</code>：修改为</p><p><code>r</code>：读<code>w</code>：写<code>x</code>：执行</p></blockquote><img src="./images/Linux笔记/image-20220416170207287.png" alt="image-20220416170207287" style="zoom:50%;" /></li><li><p>举例：</p><div class="code-wrapper"><pre><code class="hljs tap">[root@localhost demo]<span class="hljs-comment"># ll</span>总用量 0-rw-r--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>4月 <span class="hljs-number"> 16 </span>17:07 test[root@localhost demo]<span class="hljs-comment"># chmod u+x test</span>[root@localhost demo]<span class="hljs-comment"># ll</span>总用量 0-rwxr--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>4月 <span class="hljs-number"> 16 </span>17:07 test</code></pre></div></li></ul></li><li><p>第二种</p><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs routeros">chmod [<span class="hljs-attribute">mode</span>=421] 文件</code></pre></div><blockquote><p>r &#x3D; 4 w &#x3D; 2 x &#x3D; 1,rwx &#x3D; 7r– &#x3D; 4</p></blockquote></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs tap">[root@localhost demo]<span class="hljs-comment"># ll</span>总用量 0-rwxr--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>4月 <span class="hljs-number"> 16 </span>17:07 test[root@localhost demo]<span class="hljs-comment"># chmod 777 test</span>[root@localhost demo]<span class="hljs-comment"># ll</span>总用量 0-rwxrwxrwx<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>4月 <span class="hljs-number"> 16 </span>17:07 test</code></pre></div></li></ul></li></ol><blockquote><p><code>chmod -R 777 demo/</code>：将 <code>demo/</code> 目录下的所有目录以及文件都修改权限</p></blockquote><h3 id="5-5-4-chown-更改文件所有者"><a href="#5-5-4-chown-更改文件所有者" class="headerlink" title="5.5.4 chown 更改文件所有者"></a>5.5.4 chown 更改文件所有者</h3><ul><li><p>用法：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [选项] 用户 文件</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-R</td><td>递归更改</td></tr></tbody></table></li></ul><h3 id="5-5-5-chgrp-更改文件所属组"><a href="#5-5-5-chgrp-更改文件所属组" class="headerlink" title="5.5.5 chgrp 更改文件所属组"></a>5.5.5 chgrp 更改文件所属组</h3><ul><li><p>用法：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">chgrp</span> [选项] 用户组 文件</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-R</td><td>递归更改</td></tr></tbody></table></li></ul><h2 id="5-6-搜索查找相关"><a href="#5-6-搜索查找相关" class="headerlink" title="5.6 搜索查找相关"></a>5.6 搜索查找相关</h2><h3 id="5-6-1-find-查找文件或目录"><a href="#5-6-1-find-查找文件或目录" class="headerlink" title="5.6.1 find 查找文件或目录"></a>5.6.1 find 查找文件或目录</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs css">find <span class="hljs-selector-attr">[搜索范围]</span> <span class="hljs-selector-attr">[选项]</span></code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式来查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找指定用户的所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定文件大小查找文件</td></tr></tbody></table></li><li><p>举例</p><ol><li><p>查找 <code>/home</code>文件夹下的 <code>info</code>文件</p><div class="code-wrapper"><pre><code class="hljs arduino">find /home -name info</code></pre></div></li><li><p>查找<code>/home</code>文件夹下的<code>.txt</code>后缀名的文件</p><div class="code-wrapper"><pre><code class="hljs arduino">find /home -name <span class="hljs-string">&quot;*.txt&quot;</span></code></pre></div></li><li><p>查找 <code>/home</code> 文件夹下<code>test</code>用户的所有文件</p><div class="code-wrapper"><pre><code class="hljs crmsh">find /home -<span class="hljs-keyword">user</span> <span class="hljs-title">test</span></code></pre></div></li><li><p>查找 <code>/home</code>文件夹下<strong>大于10M</strong>的文件</p><div class="code-wrapper"><pre><code class="hljs arduino">find /home -size +<span class="hljs-number">10</span>M</code></pre></div></li></ol></li></ul><h3 id="5-6-2-locate-快速定位文件路径"><a href="#5-6-2-locate-快速定位文件路径" class="headerlink" title="5.6.2 locate 快速定位文件路径"></a>5.6.2 locate 快速定位文件路径</h3><blockquote><p><code>locate</code>命令利用了事先建立好的 locate 数据库，无需遍历文件系统，查询速度较快。</p><p>为保证结果准确度，管理员需要定期更新 lacate。</p></blockquote><ul><li><p>用法</p><ol><li><p>更新 locate 数据库</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">updatedb</span></code></pre></div></li><li><p>查找文件</p><div class="code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">locate</span> 文件</code></pre></div></li></ol></li></ul><h3 id="5-6-3-which-或-whereis-定位命令"><a href="#5-6-3-which-或-whereis-定位命令" class="headerlink" title="5.6.3 which 或 whereis 定位命令"></a>5.6.3 which 或 whereis 定位命令</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> 命令</code></pre></div></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> <span class="hljs-built_in">ls</span></code></pre></div></li></ul><h3 id="5-6-4-grep-过滤查找-及-管道符"><a href="#5-6-4-grep-过滤查找-及-管道符" class="headerlink" title="5.6.4 grep 过滤查找 及 | 管道符"></a>5.6.4 grep 过滤查找 及 | 管道符</h3><blockquote><p><code>|</code>，管道符。表示将前一个命令的处理结果输出传递给后面的命令处理</p></blockquote><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs css">grep <span class="hljs-selector-attr">[选项]</span> 查找内容 源文件</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行和行号</td></tr></tbody></table></li><li><p>举例</p><ol><li><p>查找 test 文件在第几行</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> | grep -n <span class="hljs-built_in">test</span></code></pre></div></li><li><p>查找 demo 在 test 文件的第几行</p><div class="code-wrapper"><pre><code class="hljs bash">grep -n demo <span class="hljs-built_in">test</span></code></pre></div></li></ol></li></ul><h3 id="5-6-5-wc-统计文件行数、词数、字节数（word-count）"><a href="#5-6-5-wc-统计文件行数、词数、字节数（word-count）" class="headerlink" title="5.6.5 wc 统计文件行数、词数、字节数（word count）"></a>5.6.5 wc 统计文件行数、词数、字节数（word count）</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">wc</span> 文件</code></pre></div></li><li><p>举例</p><div class="code-wrapper"><pre><code class="hljs actionscript">wc <span class="hljs-keyword">case</span>.sh<span class="hljs-number">12</span> <span class="hljs-number">20</span> <span class="hljs-number">96</span> <span class="hljs-keyword">case</span>.sh</code></pre></div><p>即：12行 20词 96字节 文件名 case.sh</p></li></ul><h2 id="5-7-压缩解压相关"><a href="#5-7-压缩解压相关" class="headerlink" title="5.7 压缩解压相关"></a>5.7 压缩解压相关</h2><h3 id="5-7-1-gzip-x2F-gunzip"><a href="#5-7-1-gzip-x2F-gunzip" class="headerlink" title="5.7.1 gzip &#x2F; gunzip"></a>5.7.1 gzip &#x2F; gunzip</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gzip</span> 文件gunzip 压缩文件(.gz结尾)</code></pre></div></li><li><p>注意</p><ol><li>只能压缩文件，不能压缩目录</li><li>不保留源文件</li><li>同时压缩多个文件，会产生多个压缩包</li></ol></li></ul><h3 id="5-7-2-zip-x2F-unzip"><a href="#5-7-2-zip-x2F-unzip" class="headerlink" title="5.7.2 zip &#x2F; unzip"></a>5.7.2 zip &#x2F; unzip</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs scss">zip <span class="hljs-selector-attr">[选项]</span> 压缩后的文件名  文件或目录unzip <span class="hljs-selector-attr">[选项]</span> 文件或目录(.zip结尾)</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-r</td><td>递归压缩目录</td></tr><tr><td>-d</td><td>指定位置</td></tr></tbody></table></li><li><p>注意</p><ol><li>可以压缩目录</li><li>保留源文件</li></ol></li></ul><h3 id="5-7-3-tar-打包、解包"><a href="#5-7-3-tar-打包、解包" class="headerlink" title="5.7.3 tar 打包、解包"></a>5.7.3 tar 打包、解包</h3><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs css">tar <span class="hljs-selector-attr">[选项]</span> 名称 内容</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-c</td><td>产生<code>.tar</code>打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>使用 gzip 进行压缩或者解压</td></tr><tr><td>-x</td><td>解压<code>.tar</code>文件</td></tr><tr><td>-C</td><td>解压到指定目录</td></tr></tbody></table></li><li><p>举例</p><ol><li><p>打包并压缩<code>demo1</code>和<code>demo2</code>两个文件夹，并将打包后的文件命名为<code>tmp.tar.gz</code></p><div class="code-wrapper"><pre><code class="hljs awk">tar -zcvf tmp.tar.gz demo1<span class="hljs-regexp">/ demo2/</span></code></pre></div></li><li><p>解压<code>tmp.tar.gz</code>文件，并将解压出来的文件存放到<code>test</code>文件夹中</p><div class="code-wrapper"><pre><code class="hljs stylus">tar -zxvf tmp<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> -C test/</code></pre></div></li></ol></li></ul><h2 id="5-8-磁盘管理相关"><a href="#5-8-磁盘管理相关" class="headerlink" title="5.8 磁盘管理相关"></a>5.8 磁盘管理相关</h2><h3 id="5-8-1-tree-查看目录结构"><a href="#5-8-1-tree-查看目录结构" class="headerlink" title="5.8.1 tree 查看目录结构"></a>5.8.1 tree 查看目录结构</h3><ol><li><p>安装 tree 工具</p><div class="code-wrapper"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> tree</code></pre></div></li><li><p>查看当前目录结构</p><div class="code-wrapper"><pre><code class="hljs dos"><span class="hljs-built_in">tree</span></code></pre></div></li></ol><h3 id="5-8-2-du-统计文件或目录大小（disk-usage）"><a href="#5-8-2-du-统计文件或目录大小（disk-usage）" class="headerlink" title="5.8.2 du 统计文件或目录大小（disk usage）"></a>5.8.2 du 统计文件或目录大小（disk usage）</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> 目录或文件</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-h</td><td>显示 G M K 等单位</td></tr><tr><td>-a</td><td>不仅查看子目录，而且查看文件</td></tr><tr><td>-c</td><td>显示目录和文件大小以及总和</td></tr><tr><td>-s</td><td>只显示总和</td></tr><tr><td>–max-depth &#x3D; n</td><td>限制深度为n</td></tr></tbody></table><h3 id="5-8-3-df-查看磁盘使用情况（disk-free）"><a href="#5-8-3-df-查看磁盘使用情况（disk-free）" class="headerlink" title="5.8.3 df 查看磁盘使用情况（disk free）"></a>5.8.3 df 查看磁盘使用情况（disk free）</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">df</span></code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-h</td><td>显示 G M K 等单位</td></tr></tbody></table><h3 id="5-8-4-free-查看内存使用情况"><a href="#5-8-4-free-查看内存使用情况" class="headerlink" title="5.8.4 free 查看内存使用情况"></a>5.8.4 free 查看内存使用情况</h3><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">free</span></code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-h</td><td>显示 G M K 等单位</td></tr></tbody></table><h3 id="5-8-5-lsblk-查看设备挂载情况（list-block）"><a href="#5-8-5-lsblk-查看设备挂载情况（list-block）" class="headerlink" title="5.8.5 lsblk 查看设备挂载情况（list block）"></a>5.8.5 lsblk 查看设备挂载情况（list block）</h3><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">lsblk</span></code></pre></div><h3 id="5-8-6-mount-挂载-x2F-umount-卸载"><a href="#5-8-6-mount-挂载-x2F-umount-卸载" class="headerlink" title="5.8.6 mount 挂载 &#x2F; umount 卸载"></a>5.8.6 mount 挂载 &#x2F; umount 卸载</h3><ol><li><p>挂载</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">mount</span> 设备 目录</code></pre></div></li><li><p>卸载</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">umount</span> 设备文件名或挂载点</code></pre></div></li><li><p>开机自动挂载</p><div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>fstab</code></pre></div></li></ol><h3 id="5-8-7-fdisk-分区"><a href="#5-8-7-fdisk-分区" class="headerlink" title="5.8.7 fdisk 分区"></a>5.8.7 fdisk 分区</h3><ol><li><p>查看分区详情</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">fdisk -l</span></code></pre></div></li><li><p>对新磁盘进行分区操作</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">fdisk</span> 硬盘设备名</code></pre></div></li></ol><h3 id="5-8-8-mkfs-指定文件系统"><a href="#5-8-8-mkfs-指定文件系统" class="headerlink" title="5.8.8 mkfs 指定文件系统"></a>5.8.8 mkfs 指定文件系统</h3><div class="code-wrapper"><pre><code class="hljs excel">mkfs -<span class="hljs-built_in">t</span> 文件系统 设备</code></pre></div><h2 id="5-9-进程管理相关"><a href="#5-9-进程管理相关" class="headerlink" title="5.9 进程管理相关"></a>5.9 进程管理相关</h2><h3 id="5-9-1-ps-查看当前系统进程状态（process-status）"><a href="#5-9-1-ps-查看当前系统进程状态（process-status）" class="headerlink" title="5.9.1 ps 查看当前系统进程状态（process status）"></a>5.9.1 ps 查看当前系统进程状态（process status）</h3><ol><li><p>查看系统中所有的进程</p><div class="code-wrapper"><pre><code class="hljs dos">ps <span class="hljs-built_in">aux</span></code></pre></div></li><li><p>查看子父进程之间的关系</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ps -ef</span></code></pre></div></li></ol><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>列出带有终端的所有用户的进程</td></tr><tr><td>x</td><td>列出当前用户的所有进程，包括没有终端的进程</td></tr><tr><td>u</td><td>面向用户友好</td></tr><tr><td>-e</td><td>列出所有进程</td></tr><tr><td>-u</td><td>列出某个用户相关的所有进程</td></tr><tr><td>-f</td><td>显示完整格式</td></tr></tbody></table><h3 id="5-9-2-kill-终止进程"><a href="#5-9-2-kill-终止进程" class="headerlink" title="5.9.2 kill 终止进程"></a>5.9.2 kill 终止进程</h3><p>通过 pid 终止某进程</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> pid</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-9</td><td>强迫进程立即停止</td></tr></tbody></table><h3 id="5-9-3-pstree-查看进程树"><a href="#5-9-3-pstree-查看进程树" class="headerlink" title="5.9.3 pstree 查看进程树"></a>5.9.3 pstree 查看进程树</h3><div class="code-wrapper"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> pstreepstree</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p</td><td>显示进程的 pid</td></tr><tr><td>-u</td><td>显示进程所属用户</td></tr></tbody></table><h3 id="5-9-4-top-实时监控系统进程状态"><a href="#5-9-4-top-实时监控系统进程状态" class="headerlink" title="5.9.4 top 实时监控系统进程状态"></a>5.9.4 top 实时监控系统进程状态</h3><div class="code-wrapper"><pre><code class="hljs coq"><span class="hljs-built_in">top</span></code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d 秒数</td><td>每隔几秒刷新，默认3秒</td></tr><tr><td>-i</td><td>不显示闲置或者僵死进程</td></tr><tr><td>-p</td><td>指定 pid 来监控某个进程的状态</td></tr></tbody></table><h3 id="5-9-5-netstat-显示网络状态和端口占用信息"><a href="#5-9-5-netstat-显示网络状态和端口占用信息" class="headerlink" title="5.9.5 netstat 显示网络状态和端口占用信息"></a>5.9.5 netstat 显示网络状态和端口占用信息</h3><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">netstat</span><span class="hljs-meta"> [选项]</span></code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>显示所有正在或不在监听的套接字</td></tr><tr><td>-n</td><td>显示数字形式的地址而不是去解析主机、端口或用户名</td></tr><tr><td>-l</td><td>只显示在监听的服务状态</td></tr><tr><td>-p</td><td>显示哪个进程在调用</td></tr></tbody></table><p>举例：</p><ol><li><p>查看该进程网络信息</p><div class="code-wrapper"><pre><code class="hljs 1c">netstat -anp <span class="hljs-string">| grep 进程号</span></code></pre></div></li><li><p>查看网络端口号占用情况</p><div class="code-wrapper"><pre><code class="hljs 1c">netstat -nlp <span class="hljs-string">| grep 端口号</span></code></pre></div></li></ol><h2 id="5-10-crontab-系统定时服务管理-任务"><a href="#5-10-crontab-系统定时服务管理-任务" class="headerlink" title="5.10 crontab 系统定时服务管理 任务"></a>5.10 crontab 系统定时服务管理 任务</h2><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">crontab</span><span class="hljs-meta"> [选项]</span></code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-e</td><td>编辑 crontab 定时任务</td></tr><tr><td>-l</td><td>查询 crontab 任务</td></tr><tr><td>-r</td><td>删除当前用户所有的 crontab 任务</td></tr></tbody></table><p>时间格式如下：（<a href="https://www.runoob.com/linux/linux-comm-crontab.html%EF%BC%89">https://www.runoob.com/linux/linux-comm-crontab.html）</a></p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">f1</span> <span class="hljs-built_in">f2</span> <span class="hljs-built_in">f3</span> <span class="hljs-built_in">f4</span> <span class="hljs-built_in">f5</span> program</code></pre></div><ul><li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li><li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</li><li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li><li>当 f1 为 *&#x2F;n 时表示每 n 分钟个时间间隔执行一次，f2 为 *&#x2F;n 表示每 n 小时个时间间隔执行一次，其馀类推</li><li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li></ul><div class="code-wrapper"><pre><code class="hljs gherkin"><span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>-    -    -    -    -|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>||<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><span class="hljs-string"></span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +---------- 月份 (1 - 12) </span><span class="hljs-string"></span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +--------------- 一个月中的第几天 (1 - 31)</span><span class="hljs-string"></span>|<span class="hljs-string">    +-------------------- 小时 (0 - 23)</span><span class="hljs-string">+------------------------- 分钟 (0 - 59)</span></code></pre></div><p>使用者也可以将所有的设定先存放在文件中，用 crontab file 的方式来设定执行时间。</p><p>举例：</p><p>每一分钟执行一次 &#x2F;bin&#x2F;ls：</p><div class="code-wrapper"><pre><code class="hljs arcade">* * * * * <span class="hljs-regexp">/bin/</span>ls</code></pre></div><p>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 &#x2F;usr&#x2F;bin&#x2F;backup：</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">6</span>-<span class="hljs-number">12</span>/<span class="hljs-number">3</span> * <span class="hljs-number">12</span> * /<span class="hljs-keyword">usr</span>/bin/backup</code></pre></div><p>周一到周五每天下午 5:00 寄一封信给 <a href="mailto:&#97;&#108;&#x65;&#x78;&#64;&#100;&#x6f;&#109;&#97;&#x69;&#110;&#x2e;&#x6e;&#x61;&#109;&#101;">&#97;&#108;&#x65;&#x78;&#64;&#100;&#x6f;&#109;&#97;&#x69;&#110;&#x2e;&#x6e;&#x61;&#109;&#101;</a>：</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">17</span> * * <span class="hljs-number">1</span>-<span class="hljs-number">5</span> mail -s <span class="hljs-string">&quot;hi&quot;</span> alex@domain.<span class="hljs-keyword">name</span> &lt; /tmp/maildata</code></pre></div><p>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”：</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">20 </span><span class="hljs-number">0</span>-<span class="hljs-number">23</span>/<span class="hljs-number">2</span> * * * echo <span class="hljs-string">&quot;haha&quot;</span></code></pre></div><p>下面再看看几个具体的例子：</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>*/<span class="hljs-number">2</span> * * * /sbin/service httpd restart  意思是每两个小时重启一次apache <span class="hljs-symbol">50 </span><span class="hljs-number">7</span> * * * /sbin/service sshd start  意思是每天<span class="hljs-number">7</span>：<span class="hljs-number">50</span>开启ssh服务 <span class="hljs-symbol">50 </span><span class="hljs-number">22</span> * * * /sbin/service sshd <span class="hljs-keyword">stop</span>  意思是每天<span class="hljs-number">22</span>：<span class="hljs-number">50</span>关闭ssh服务 <span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span>,<span class="hljs-number">15</span> * * fsck /home  每月<span class="hljs-number">1</span>号和<span class="hljs-number">15</span>号检查/home 磁盘 <span class="hljs-symbol">1 </span>* * * * /home/bruce/backup  每小时的第一分执行 /home/bruce/backup这个文件 <span class="hljs-symbol">00 </span><span class="hljs-number">03</span> * * <span class="hljs-number">1</span>-<span class="hljs-number">5</span> find /home <span class="hljs-string">&quot;*.xxx&quot;</span> -mtime +<span class="hljs-number">4</span> -exec rm &#123;&#125; \;  每周一至周五<span class="hljs-number">3</span>点钟，在目录/home中，查找文件名为*.xxx的文件，并删除<span class="hljs-number">4</span>天前的文件。<span class="hljs-symbol">30 </span><span class="hljs-number">6</span> */<span class="hljs-number">10</span> * * ls  意思是每月的<span class="hljs-number">1</span>、<span class="hljs-number">11</span>、<span class="hljs-number">21</span>、<span class="hljs-number">31</span>日是的<span class="hljs-number">6</span>：<span class="hljs-number">30</span>执行一次ls命令</code></pre></div><h1 id="6-软件包管理"><a href="#6-软件包管理" class="headerlink" title="6 软件包管理"></a>6 软件包管理</h1><h2 id="6-1-rpm"><a href="#6-1-rpm" class="headerlink" title="6.1 rpm"></a>6.1 rpm</h2><h3 id="6-1-1-rpm-查询命令（rpm-qa）"><a href="#6-1-1-rpm-查询命令（rpm-qa）" class="headerlink" title="6.1.1 rpm 查询命令（rpm -qa）"></a>6.1.1 rpm 查询命令（rpm -qa）</h3><ul><li><p>用法：</p><ol><li><p>查询所安装的所有 rpm 软件包</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">rpm -qa</span></code></pre></div></li><li><p>查询某个包的详情信息</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">rpm</span> -qi 包</code></pre></div></li></ol></li><li><p>举例</p><ol><li><p>查询所有包信息</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">rpm -qa</span></code></pre></div></li><li><p>查询 firefox 包的详细信息</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">rpm -qi firefox</span></code></pre></div></li></ol></li></ul><h3 id="6-1-2-rpm-卸载命令（rpm-e）"><a href="#6-1-2-rpm-卸载命令（rpm-e）" class="headerlink" title="6.1.2 rpm 卸载命令（rpm -e）"></a>6.1.2 rpm 卸载命令（rpm -e）</h3><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">rpm</span> -e 包</code></pre></div><h3 id="6-1-3-rpm-安装命令（rpm-i）"><a href="#6-1-3-rpm-安装命令（rpm-i）" class="headerlink" title="6.1.3 rpm 安装命令（rpm -i）"></a>6.1.3 rpm 安装命令（rpm -i）</h3><div class="code-wrapper"><pre><code class="hljs css">rpm -<span class="hljs-selector-tag">i</span> 包</code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-i</td><td>安装</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-h</td><td>显示进度条</td></tr></tbody></table><h2 id="6-2-yum"><a href="#6-2-yum" class="headerlink" title="6.2 yum"></a>6.2 yum</h2><div class="code-wrapper"><pre><code class="hljs css">yum <span class="hljs-selector-attr">[选项]</span> <span class="hljs-selector-attr">[参数]</span></code></pre></div><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-y</td><td>对所有的提问都回答yes</td></tr></tbody></table><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>install</td><td>安装 rpm 软件包</td></tr><tr><td>update</td><td>更新 rpm 软件包</td></tr><tr><td>check-update</td><td>检查是否有可用可更新的 rpm 软件包</td></tr><tr><td>remove</td><td>删除指定的 rpm 软件包</td></tr><tr><td>list</td><td>显示软件包信息</td></tr><tr><td>clean</td><td>清理缓存</td></tr><tr><td>deplist</td><td>显示 yum 软件包的依赖关系</td></tr></tbody></table><p>举例：</p><div class="code-wrapper"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> firefox</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>运维</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue2】Vue Router笔记</title>
    <link href="/archives/64b7bd5b.html"/>
    <url>/archives/64b7bd5b.html</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>本篇笔记参考：</p><ul><li><a href="https://v3.router.vuejs.org/zh/">https://v3.router.vuejs.org/zh/</a></li><li><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH">https://www.bilibili.com/video/BV1Zy4y1K7SH</a></li></ul><p>本篇笔记代码地址：<a href="https://github.com/zhangtuo1999/study-vue-router">https://github.com/zhangtuo1999/study-vue-router</a></p></blockquote><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><blockquote><p>Vue Router 是 <a href="http://cn.vuejs.org/">Vue.js </a>官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p></blockquote><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><h2 id="2-1-NPM"><a href="#2-1-NPM" class="headerlink" title="2.1 NPM"></a>2.1 NPM</h2><p>如果在一个模块化工程中使用 Vue Router：</p><div class="code-wrapper"><pre><code class="hljs bash">npm install vue-router</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)</code></pre></div><h2 id="2-2-Vue-CLI"><a href="#2-2-Vue-CLI" class="headerlink" title="2.2 Vue CLI"></a>2.2 Vue CLI</h2><p>如果在一个 Vue CLI 项目中使用 Vue Router：</p><div class="code-wrapper"><pre><code class="hljs bash">vue add router</code></pre></div><p>CLI 可以生成 2.1 节中的代码及两个示例路由。**并覆盖 <code>App.vue</code>**。</p><h1 id="三、基本路由"><a href="#三、基本路由" class="headerlink" title="三、基本路由"></a>三、基本路由</h1><h2 id="3-1-基本路由使用"><a href="#3-1-基本路由使用" class="headerlink" title="3.1 基本路由使用"></a>3.1 基本路由使用</h2><p>在 src&#x2F;router&#x2F;index.js 中：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeView</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/HomeView.vue&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<span class="hljs-keyword">const</span> routes = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-title class_">HomeView</span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;about&#x27;</span>,    <span class="hljs-comment">// route level code-splitting</span>    <span class="hljs-comment">// this generates a separate chunk (about.[hash].js) for this route</span>    <span class="hljs-comment">// which is lazy-loaded when the route is visited.</span>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="hljs-string">&#x27;../views/AboutView.vue&#x27;</span>)  &#125;]<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;  routes&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router</code></pre></div><p>在 src&#x2F;App.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;nav&gt;      &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; |      &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;    &lt;/nav&gt;    &lt;router-view/&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></div><h2 id="3-2-动态路由匹配"><a href="#3-2-动态路由匹配" class="headerlink" title="3.2 动态路由匹配"></a>3.2 动态路由匹配</h2><h3 id="3-2-1-动态路径参数"><a href="#3-2-1-动态路径参数" class="headerlink" title="3.2.1 动态路径参数"></a>3.2.1 动态路径参数</h3><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 <code>User</code> 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果。</p><p>在路由配置中：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [       &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<span class="hljs-comment">//动态路由参数</span>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>,        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserView.vue&#x27;</span>)    &#125;]</code></pre></div><p>一个“路径参数”使用冒号 <code>:</code> 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。</p><p>在 UserView 中：</p><div class="code-wrapper"><pre><code class="hljs vue">export default &#123;  name: &quot;UserView&quot;,  data() &#123;    return &#123;      currentID: undefined,    &#125;  &#125;,  created() &#123;    this.currentID = this.$route.params.id  &#125;,&#125;</code></pre></div><p>在 App.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;router-link to=&quot;/user/1&quot;&gt;User&lt;/router-link&gt;</code></pre></div><p>此时 <code>1</code> 作为参数，可以被组件 UserView 接收到。</p><h3 id="3-2-2-监听路由参数的变化"><a href="#3-2-2-监听路由参数的变化" class="headerlink" title="3.2.2 监听路由参数的变化"></a>3.2.2 监听路由参数的变化</h3><p>动态路径参数变化时，由于组件是被复用的，组件的生命周期钩子不会被再次调用。因此，如果想对参数做出响应，应该监听 <code>$route</code> 对象。</p><p>在 UserView.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">watch: &#123;$route(to, from) &#123;this.currentID = to.params.idconsole.log(&#x27;to:&#x27;, to.params.id, &#x27;from:&#x27;, from.params.id)&#125;&#125;</code></pre></div><h2 id="3-3-使用通配符路由"><a href="#3-3-使用通配符路由" class="headerlink" title="3.3 使用通配符路由"></a>3.3 使用通配符路由</h2><p>常规参数只会匹配被 <code>/</code> 分隔的 URL 片段中的字符。如果想匹配<strong>任意路径</strong>，我们可以使用通配符 (<code>*</code>)：</p><div class="code-wrapper"><pre><code class="hljs js">&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user-*&#x27;</span>,<span class="hljs-comment">// 会匹配以 `/user-` 开头的任意路径</span>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;userInfo&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserInfo&#x27;</span>)&#125;,&#123;     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-comment">// 会匹配所有路径</span>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;404&#x27;</span>,     <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/404&#x27;</span>)&#125;</code></pre></div><p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分：</p><div class="code-wrapper"><pre><code class="hljs vue">export default &#123;  name: &quot;UserInfo&quot;,  created() &#123;// 如果路径是&#x27;/user-Tony&#x27;,这里的 currentName 值为&#x27;Tony&#x27;    this.currentName = this.$route.params.pathMatch  &#125;,  data() &#123;    return &#123;      currentName: &#x27;&#x27;    &#125;  &#125;&#125;</code></pre></div><h2 id="3-4-路由优先级"><a href="#3-4-路由优先级" class="headerlink" title="3.4 路由优先级"></a>3.4 路由优先级</h2><p>按照路由定义的顺序，越早定义优先级越高。</p><h1 id="四、嵌套路由（多级路由）"><a href="#四、嵌套路由（多级路由）" class="headerlink" title="四、嵌套路由（多级路由）"></a>四、嵌套路由（多级路由）</h1><p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件。使用嵌套路由配置，可以上述的这种关系。</p><p>比如想在 UersView 组件中嵌套 UserProfile 和 UserPosts 组件。在路由配置参数中，使用 <code>children</code> ：</p><div class="code-wrapper"><pre><code class="hljs js">&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserView.vue&#x27;</span>),    <span class="hljs-attr">children</span>: [        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserProfile.vue&#x27;</span>),        &#125;,        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;posts&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserPosts.vue&#x27;</span>),        &#125;    ]&#125;,</code></pre></div><p>注意：子路由的 path 不需要在前面加上 <code>/</code>。所有前面带 <code>/</code> 的 path 都被视为最高级别的路由，即跟路径。</p><p>这时访问 <code>/user/1</code> 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由：</p><div class="code-wrapper"><pre><code class="hljs js">&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserView.vue&#x27;</span>),    <span class="hljs-attr">children</span>: [        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">// 空的子路由</span>            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserHome.vue&#x27;</span>)        &#125;,        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserProfile.vue&#x27;</span>),        &#125;,        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;posts&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserPosts.vue&#x27;</span>),        &#125;    ]&#125;,</code></pre></div><h1 id="五、命名路由"><a href="#五、命名路由" class="headerlink" title="五、命名路由"></a>五、命名路由</h1><p>可以使用 <code>name</code> 属性给路由设置名称：</p><div class="code-wrapper"><pre><code class="hljs js">&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/school/:schoolName&#x27;</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;school&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/School.vue&#x27;</span>)&#125;</code></pre></div><p>声明式导航到 <code>/school/BUCT</code>：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;router-link :to=&quot;&#123;name:&#x27;school&#x27;,params:&#123;schoolName:&#x27;BUCT&#x27;&#125;&#125;&quot;&gt;School&lt;/router-link&gt;</code></pre></div><p>编程式导航到上述 <code>/school/BUCT</code>：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">schoolName</span>:<span class="hljs-string">&#x27;BUCT&#x27;</span>&#125;&#125;)</code></pre></div><h1 id="六、命名视图"><a href="#六、命名视图" class="headerlink" title="六、命名视图"></a>六、命名视图</h1><p>如果想在同一个页面上展示多个视图，可以在界面中写多个单独命名的视图。如果不设置名字，那么默认是 <code>default</code> 。</p><p>在页面上：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;router-view&gt;&lt;/router-view&gt;// 默认名字是 default&lt;router-view name=&quot;helper&quot;&gt;&lt;/router-view&gt;// 把视图命名为 helper</code></pre></div><p>在路由配置中，使用 <code>components</code> 配置（带上s）：</p><div class="code-wrapper"><pre><code class="hljs js">&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/settings&#x27;</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;settings&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserSettings</span>,    <span class="hljs-attr">children</span>: [        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;email&#x27;</span>,            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;email&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/Settings/UserEmailSubscriptions&#x27;</span>)        &#125;,        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,            <span class="hljs-attr">components</span>: &#123;                <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/Settings/UserProfile&#x27;</span>),                <span class="hljs-attr">helper</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/Settings/UserProfilePreview&#x27;</span>)            &#125;        &#125;   ]&#125;</code></pre></div><h1 id="七、重定向和别名"><a href="#七、重定向和别名" class="headerlink" title="七、重定向和别名"></a>七、重定向和别名</h1><h2 id="7-1-重定向"><a href="#7-1-重定向" class="headerlink" title="7.1 重定向"></a>7.1 重定向</h2><ul><li><p>重定向到 path：</p><div class="code-wrapper"><pre><code class="hljs js">&#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/redirectToAbout&#x27;</span>,<span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/about&#x27;</span> &#125;</code></pre></div></li><li><p>重定向到 name：</p><div class="code-wrapper"><pre><code class="hljs js">&#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/redirectToAbout&#x27;</span>,<span class="hljs-attr">redirect</span>:&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;about&#x27;</span>&#125; &#125;</code></pre></div></li></ul><h2 id="7-2-别名"><a href="#7-2-别名" class="headerlink" title="7.2 别名"></a>7.2 别名</h2><p>可以给 path 起一个别名，例如：</p><div class="code-wrapper"><pre><code class="hljs js">&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;about&#x27;</span>,    <span class="hljs-attr">alias</span>: <span class="hljs-string">&#x27;/a&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/AboutView.vue&#x27;</span>)&#125;</code></pre></div><h2 id="7-3-重定向和别名的区别"><a href="#7-3-重定向和别名的区别" class="headerlink" title="7.3 重定向和别名的区别"></a>7.3 重定向和别名的区别</h2><ul><li>将 <code>/redirectToAbout</code>  重定向到  <code>about</code> 。相当于访问<code>/redirectToAbout</code>时，url 会被替换成 <code>/about</code>。</li><li>给 <code>/about</code> 起一个别名 <code>/a </code>。相当于，访问 <code>/a</code> 时，url 会保持为 <code>/a</code> ，但是就像访问 <code>/about</code> 一样。</li></ul><h1 id="八、路由组件传参"><a href="#八、路由组件传参" class="headerlink" title="八、路由组件传参"></a>八、路由组件传参</h1><p>将组件与路由解耦：</p><p>未解耦前：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span>&#125;<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;  <span class="hljs-attr">routes</span>: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> &#125;]&#125;)</code></pre></div><p>解耦后：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = &#123;  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;id&#x27;</span>],  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span>&#125;<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;  <span class="hljs-attr">routes</span>: [    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> &#125;,  ]&#125;)</code></pre></div><p>这样便可以在任何地方使用该组件，使得该组件更易于重用和测试。</p><h2 id="8-1-布尔模式"><a href="#8-1-布尔模式" class="headerlink" title="8.1 布尔模式"></a>8.1 布尔模式</h2><p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性。</p><h2 id="8-2-对象模式"><a href="#8-2-对象模式" class="headerlink" title="8.2 对象模式"></a>8.2 对象模式</h2><p>如果 <code>props</code> 是一个对象，它会被按原样设置为组件属性。当 <code>props</code> 是固定不变的时候有用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;  <span class="hljs-attr">routes</span>: [    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/promotion/from-newsletter&#x27;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-title class_">Promotion</span>,      <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">newsletterPopup</span>: <span class="hljs-literal">false</span> &#125;    &#125;  ]&#125;)</code></pre></div><h1 id="九、push-模式和-replace-模式"><a href="#九、push-模式和-replace-模式" class="headerlink" title="九、push 模式和 replace 模式"></a>九、push 模式和 replace 模式</h1><h2 id="9-1-push-模式"><a href="#9-1-push-模式" class="headerlink" title="9.1 push 模式"></a>9.1 push 模式</h2><p>在路由的 history 栈中压入一条记录。</p><h2 id="9-2-replace-模式"><a href="#9-2-replace-模式" class="headerlink" title="9.2 replace 模式"></a>9.2 replace 模式</h2><p>替换路由的 history 栈顶的记录。</p><h1 id="十、编程式路由导航"><a href="#十、编程式路由导航" class="headerlink" title="十、编程式路由导航"></a>十、编程式路由导航</h1><p>声明式的导航：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;</code></pre></div><h2 id="10-1-push"><a href="#10-1-push" class="headerlink" title="10.1 push"></a>10.1 push</h2><p>使用方法：</p><ul><li><p>字符串</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/user/1&#x27;</span>)<span class="hljs-comment">// 字符串路径</span></code></pre></div></li><li><p>对象</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>&#125;)<span class="hljs-comment">// 描述地址的对象</span></code></pre></div></li><li><p>命名的路由</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">userID</span>:<span class="hljs-number">1</span>&#125;&#125;)</code></pre></div></li><li><p>带查询参数（参数会在 url 后进行拼接）</p><div class="code-wrapper"><pre><code class="hljs js">router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125;&#125;)</code></pre></div></li><li><p>注意：</p><ul><li><p><strong>如果提供了 <code>path</code>，<code>params</code> 会被忽略</strong>，需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">userID</span>:<span class="hljs-number">1</span>&#125;&#125;)</code></pre></div></li><li><p>下面这种 <code>path</code> 和 <code>params</code> 同时存在的情况中，<code>params</code> 不生效</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;1&#x27;</span>&#125;&#125;)</code></pre></div></li></ul></li></ul><h2 id="10-2-replace"><a href="#10-2-replace" class="headerlink" title="10.2 replace"></a>10.2 replace</h2><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><h2 id="10-3-back"><a href="#10-3-back" class="headerlink" title="10.3 back"></a>10.3 back</h2><p>后退一步：</p><div class="code-wrapper"><pre><code class="hljs js">router.<span class="hljs-title function_">back</span>()</code></pre></div><h2 id="10-4-forward"><a href="#10-4-forward" class="headerlink" title="10.4 forward"></a>10.4 forward</h2><p>前进一步：</p><div class="code-wrapper"><pre><code class="hljs js">router.<span class="hljs-title function_">forward</span>()</code></pre></div><h2 id="10-5-go"><a href="#10-5-go" class="headerlink" title="10.5 go"></a>10.5 go</h2><p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 在浏览器记录中前进一步，等同于 history.forward()</span>router.<span class="hljs-title function_">go</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">// 后退一步记录，等同于 history.back()</span>router.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>)<span class="hljs-comment">// 前进 3 步记录</span>router.<span class="hljs-title function_">go</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">// 如果 history 记录不够用，那就默默地失败呗</span>router.<span class="hljs-title function_">go</span>(-<span class="hljs-number">100</span>)router.<span class="hljs-title function_">go</span>(<span class="hljs-number">100</span>)</code></pre></div><h1 id="十一、缓存路由组件"><a href="#十一、缓存路由组件" class="headerlink" title="十一、缓存路由组件"></a>十一、缓存路由组件</h1><p>默认情况下在切换路由链接时，前一个路由组件对象会被销毁掉。下次切换回来时，又是一个新的路由组件对象。反复切换时，开销较大。使用 <code>keep-alive</code> Vue 内置组件包裹 <code>router-view</code> 可以保证在来回切换路由时，路由组件对象不会被销毁掉而被缓存起来，节省了开销。</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;keep-alive&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre></div><ul><li><a href="https://cn.vuejs.org/v2/api/#keep-alive">https://cn.vuejs.org/v2/api/#keep-alive</a></li></ul><h1 id="十二、两个新的生命周期钩子"><a href="#十二、两个新的生命周期钩子" class="headerlink" title="十二、两个新的生命周期钩子"></a>十二、两个新的生命周期钩子</h1><h2 id="12-1-activated"><a href="#12-1-activated" class="headerlink" title="12.1 activated"></a>12.1 activated</h2><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>被 keep-alive 缓存的组件激活时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li></ul><h2 id="12-2-deactivated"><a href="#12-2-deactivated" class="headerlink" title="12.2 deactivated"></a>12.2 deactivated</h2><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>被 keep-alive 缓存的组件失活时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li></ul><h1 id="十三、路由守卫"><a href="#十三、路由守卫" class="headerlink" title="十三、路由守卫"></a>十三、路由守卫</h1><p><code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的，单个路由独享的， 或者组件级的。</p><p><strong>参数或查询的改变并不会触发进入&#x2F;离开的导航守卫</strong>。可以通过监视 $route 对象来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。</p><h2 id="13-1-全局前置路由守卫"><a href="#13-1-全局前置路由守卫" class="headerlink" title="13.1 全局前置路由守卫"></a>13.1 全局前置路由守卫</h2><div class="code-wrapper"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...</span>&#125;)</code></pre></div><ul><li><code>to</code>：即将要进入的目标路由对象</li><li><code>from</code>：正要离开的路由对象</li><li><code>next</code>：调用该方法来 <strong>resolve</strong> 这个钩子。并且要确保严格调用一次。<ul><li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li><li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://v3.router.vuejs.org/zh/api/#to"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://v3.router.vuejs.org/zh/api/#router-push"><code>router.push</code></a> 中的选项。</li><li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://v3.router.vuejs.org/zh/api/#router-onerror"><code>router.onError()</code></a> 注册过的回调。</li></ul></li></ul><h2 id="13-2-全局后置路由守卫"><a href="#13-2-全局后置路由守卫" class="headerlink" title="13.2 全局后置路由守卫"></a>13.2 全局后置路由守卫</h2><div class="code-wrapper"><pre><code class="hljs js">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;&#125;)</code></pre></div><h2 id="13-3-独享路由守卫"><a href="#13-3-独享路由守卫" class="headerlink" title="13.3 独享路由守卫"></a>13.3 独享路由守卫</h2><p>在路由配置上直接定义 beforeEnter 守卫</p><div class="code-wrapper"><pre><code class="hljs js">&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/AboutView.vue&#x27;</span>),    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;        <span class="hljs-title function_">next</span>()    &#125;&#125;,</code></pre></div><h2 id="13-4-组件内的路由守卫"><a href="#13-4-组件内的路由守卫" class="headerlink" title="13.4 组件内的路由守卫"></a>13.4 组件内的路由守卫</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Foo</span> = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">`...`</span>,  <span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span>    <span class="hljs-comment">// 不！能！获取组件实例 `this`</span>    <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span>  &#125;,  <span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span>    <span class="hljs-comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>    <span class="hljs-comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>    <span class="hljs-comment">// 可以访问组件实例 `this`</span>  &#125;,  <span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span>    <span class="hljs-comment">// 可以访问组件实例 `this`</span>  &#125;&#125;</code></pre></div><p>可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><div class="code-wrapper"><pre><code class="hljs js">beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;  <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;    <span class="hljs-comment">// 通过 `vm` 访问组件实例</span>  &#125;)&#125;</code></pre></div><h2 id="13-5-完整的导航解析流程"><a href="#13-5-完整的导航解析流程" class="headerlink" title="13.5 完整的导航解析流程"></a>13.5 完整的导航解析流程</h2><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h1 id="十四、hash-模式和-history-模式"><a href="#十四、hash-模式和-history-模式" class="headerlink" title="十四、hash 模式和 history 模式"></a>十四、hash 模式和 history 模式</h1><h2 id="14-1-hash模式"><a href="#14-1-hash模式" class="headerlink" title="14.1 hash模式"></a>14.1 hash模式</h2><p>url 中会有一个 <code>#</code>，例如：<code>http://localhost:8080/#/user/1</code></p><h2 id="14-2-history-模式"><a href="#14-2-history-模式" class="headerlink" title="14.2 history 模式"></a>14.2 history 模式</h2><p>开启 history 模式：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,  <span class="hljs-attr">routes</span>: [...]&#125;)</code></pre></div><p>在 history 模式下，url 中没有 <code>#</code> ，例如：<code>http://localhost:8080/user/1</code>。但是这需要后端的支持，不然会出现访问 url 返回 404 的情况。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
      <tag>Vue Router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue2】Vuex笔记</title>
    <link href="/archives/7a98a4dd.html"/>
    <url>/archives/7a98a4dd.html</url>
    
    <content type="html"><![CDATA[<h1 id="一、Vuex-介绍"><a href="#一、Vuex-介绍" class="headerlink" title="一、Vuex 介绍"></a>一、Vuex 介绍</h1><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><p>简言之，Vuex 可以管理一些数据，以便所有组件共享。</p><h1 id="二、Vuex-工作原理图"><a href="#二、Vuex-工作原理图" class="headerlink" title="二、Vuex 工作原理图"></a>二、Vuex 工作原理图</h1><p><img src="/images/Vuex%E7%AC%94%E8%AE%B0/vuex-16477676604351.png" alt="Vuex工作原理图"></p><h1 id="三、Vuex-使用"><a href="#三、Vuex-使用" class="headerlink" title="三、Vuex 使用"></a>三、Vuex 使用</h1><h2 id="3-1-安装-Vuex"><a href="#3-1-安装-Vuex" class="headerlink" title="3.1 安装 Vuex"></a>3.1 安装 Vuex</h2><p>NPM 安装</p><div class="code-wrapper"><pre><code class="hljs bash">npm install vuex@3 --save//Vue2 对应 Vuex3</code></pre></div><h2 id="3-2-在-Vue-项目中使用-Vuex"><a href="#3-2-在-Vue-项目中使用-Vuex" class="headerlink" title="3.2 在 Vue 项目中使用 Vuex"></a>3.2 在 Vue 项目中使用 Vuex</h2><p>以实现计数功能为例：</p><p><img src="/images/Vuex%E7%AC%94%E8%AE%B0/image-20220319191059347.png" alt="image-20220319191059347"></p><p>在 src&#x2F;store&#x2F;index.js 中：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;  <span class="hljs-attr">state</span>: &#123;      <span class="hljs-attr">count</span>:<span class="hljs-number">0</span><span class="hljs-comment">// 状态</span>  &#125;,  <span class="hljs-attr">mutations</span>: &#123;      <span class="hljs-title function_">HANDLE_ADD</span>(<span class="hljs-params">state, num</span>) &#123;<span class="hljs-comment">// 显式改变state的mutation</span>         state.<span class="hljs-property">count</span> += num      &#125;  &#125;,&#125;)</code></pre></div><p>在 src&#x2F;main.js 中：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><span class="hljs-comment">// 引入store</span><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  store,<span class="hljs-comment">// 将store注入vue</span>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><p>在 src&#x2F;componentsChild.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;count:&#123;&#123; count &#125;&#125;&lt;/h1&gt;    &lt;input v-model.number=&quot;num&quot;&gt;    &lt;button @click=&quot;handleClick&quot;&gt;点击count++&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child&quot;,  data() &#123;    return &#123;        num: 1    &#125;  &#125;,  computed: &#123;    count() &#123;      return this.$store.state.count    &#125;  &#125;,  methods: &#123;    handleClick() &#123;      this.$store.commit(&#x27;HANDLE_ADD&#x27;,this.num)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><p>在 App.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;Child&gt;&lt;/Child&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;@/components/Child&quot;;export default &#123;  name: &#x27;App&#x27;,  components: &#123;    Child,  &#125;&#125;&lt;/script&gt;</code></pre></div><h2 id="3-3-State"><a href="#3-3-State" class="headerlink" title="3.3 State"></a>3.3 State</h2><p>state 中保存需要用 vuex 来管理的数据。</p><p>在 src&#x2F;store&#x2F;index.js  中：（Vuex）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">state</span>: &#123;<span class="hljs-attr">count</span>:<span class="hljs-number">0</span><span class="hljs-comment">//交给 Vuex 管理的数据</span>&#125;,</code></pre></div><p>在 Child.vue 中：（组件）</p><div class="code-wrapper"><pre><code class="hljs vue">computed: &#123;    count() &#123;    return this.$store.state.count    &#125;&#125;,</code></pre></div><h2 id="3-4-Mutations"><a href="#3-4-Mutations" class="headerlink" title="3.4 Mutations"></a>3.4 Mutations</h2><blockquote><p>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p></blockquote><blockquote><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p></blockquote><p>在 src&#x2F;store&#x2F;index.js中</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">HANDLE_ADD</span>(<span class="hljs-params">state, num</span>) &#123;<span class="hljs-comment">//此处的 num 被称为载荷。如果需要传参较多，载荷应该为含有多个字段的对象</span>    state.<span class="hljs-property">count</span> += num    &#125;&#125;</code></pre></div><p>不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 <code>increment</code> 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <strong>store.commit</strong> 方法：</p><p>在 Child.vue 中</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;HANDLE_ADD&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>)<span class="hljs-comment">//组件中提交 mutation</span>    &#125;&#125;</code></pre></div><p>注意：</p><ul><li>一条重要的原则就是要记住 <strong>mutation 必须是同步函数</strong>。异步操作放入 <strong>action</strong> 中。</li><li>一般把 mutation 中的函数名写成大写。</li></ul><h2 id="3-5-Actions"><a href="#3-5-Actions" class="headerlink" title="3.5 Actions"></a>3.5 Actions</h2><blockquote><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul></blockquote><p>在 src&#x2F;store&#x2F;index.js 中</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">actions</span>: &#123;    <span class="hljs-title function_">handleAdd</span>(<span class="hljs-params">context,num</span>)&#123;        context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;HANDLE_ADD&#x27;</span>,num)    &#125;&#125;,</code></pre></div><p>注意：</p><ul><li><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p></li><li><p>Action 通过 <code>store.dispatch</code> 方法触发，在 Child.vue 中</p><div class="code-wrapper"><pre><code class="hljs vue">methods: &#123;    handleClick() &#123;    this.$store.dispatch(&#x27;handleAdd&#x27;,this.num)    &#125;&#125;</code></pre></div></li><li><p>Action 中可以执行<strong>异步操作</strong>。<code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise。</p></li></ul><h2 id="3-6-Getters"><a href="#3-6-Getters" class="headerlink" title="3.6 Getters"></a>3.6 Getters</h2><blockquote><p>有时候我们需要从 store 中的 state 中派生出一些状态。比如 count 的10倍。</p></blockquote><p><img src="/images/Vuex%E7%AC%94%E8%AE%B0/image-20220319193429568.png" alt="image-20220319193429568"><br>在 Child.vue 中：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;  bigCount () &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> * <span class="hljs-number">10</span>  &#125;&#125;</code></pre></div><blockquote><p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 接受 state 作为其第一个参数：</p></blockquote><p>在 store&#x2F;index.js 中：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;    <span class="hljs-attr">state</span>: &#123;        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>    &#125;,    <span class="hljs-attr">mutations</span>: &#123;        <span class="hljs-title function_">HANDLE_ADD</span>(<span class="hljs-params">state, num</span>) &#123;            state.<span class="hljs-property">count</span> += num        &#125;    &#125;,    <span class="hljs-attr">getters</span>: &#123;        <span class="hljs-title function_">bigCount</span>(<span class="hljs-params">state</span>)&#123;<span class="hljs-comment">// bigCount 是 state 中 count 的 10 倍</span>            <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">10</span>        &#125;    &#125;,&#125;)</code></pre></div><ul><li><p>Getter 也可以接受其他 getter 作为第二个参数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">getters</span>: &#123;    <span class="hljs-title function_">bigCount</span>(<span class="hljs-params">state</span>)&#123;        <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">10</span>    &#125;,    <span class="hljs-title function_">largeCount</span>(<span class="hljs-params">state, getters</span>)&#123;<span class="hljs-comment">// largeCount 等于 state 中 count 加上 getters 中的 bigCount</span>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> + getters.<span class="hljs-property">bigCount</span>    &#125;&#125;,</code></pre></div><p><img src="/images/Vuex%E7%AC%94%E8%AE%B0/image-20220319194434725.png" alt="image-20220319194434725"></p></li></ul><h1 id="四、组件绑定的辅助函数"><a href="#四、组件绑定的辅助函数" class="headerlink" title="四、组件绑定的辅助函数"></a>四、组件绑定的辅助函数</h1><h2 id="4-1-mapState"><a href="#4-1-mapState" class="headerlink" title="4.1 mapState"></a>4.1 mapState</h2><blockquote><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p></blockquote><h3 id="4-1-1-对象写法"><a href="#4-1-1-对象写法" class="headerlink" title="4.1.1 对象写法"></a>4.1.1 对象写法</h3><p>在 Child.vue 中</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;count:&#123;&#123; count &#125;&#125;&lt;/h1&gt;    &lt;input v-model.number=&quot;num&quot;&gt;    &lt;button @click=&quot;handleClick&quot;&gt;点击count+num&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from &#x27;vuex&#x27;//借助 mapState 简化state在computed中的写法export default &#123;  name: &quot;Child&quot;,  data() &#123;    return &#123;      num: 1    &#125;  &#125;,  computed: &#123;    ...mapState(&#123;count:&#x27;count&#x27;&#125;)// mapState 在 computed 中的第一种写法：对象写法  &#125;,  methods: &#123;    handleClick() &#123;      this.$store.commit(&#x27;HANDLE_ADD&#x27;, this.num)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><p>注意：</p><ul><li>对象写法中第一个 <code>count</code> 指的是在这个组件中使用的名称，第二个 <code>&#39;count&#39;</code> 指的是在 Vuex 中 state 的 key 值。即映射 <code>this.count</code> 为 <code>store.state.count</code></li><li><code>mapState</code> 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？使用对象展开运算符即<code>...</code></li></ul><h3 id="4-1-2-数组写法"><a href="#4-1-2-数组写法" class="headerlink" title="4.1.2 数组写法"></a>4.1.2 数组写法</h3><blockquote><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p></blockquote><div class="code-wrapper"><pre><code class="hljs vue">computed: &#123;...mapState([&#x27;count&#x27;])//映射 this.count 为 store.state.count&#125;</code></pre></div><h2 id="4-2-mapGetters"><a href="#4-2-mapGetters" class="headerlink" title="4.2 mapGetters"></a>4.2 mapGetters</h2><p>用法等同于 mapState：</p><p>在 Child.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;count:&#123;&#123; count &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;bigCount:&#123;&#123; bigCount &#125;&#125;&lt;/h1&gt;    &lt;input v-model.number=&quot;num&quot;&gt;    &lt;button @click=&quot;handleClick&quot;&gt;点击count+num&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState,mapGetters&#125; from &#x27;vuex&#x27;export default &#123;  name: &quot;Child&quot;,  data() &#123;    return &#123;      num: 1    &#125;  &#125;,  computed: &#123;    ...mapState([&#x27;count&#x27;]),    ...mapGetters([&#x27;bigCount&#x27;])  &#125;,  methods: &#123;    handleClick() &#123;      this.$store.commit(&#x27;HANDLE_ADD&#x27;, this.num)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><p>效果：</p><p><img src="/images/Vuex%E7%AC%94%E8%AE%B0/image-20220319193751731.png" alt="image-20220319193751731"></p><h2 id="4-3-mapMutations"><a href="#4-3-mapMutations" class="headerlink" title="4.3 mapMutations"></a>4.3 mapMutations</h2><p>在 Child.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;count:&#123;&#123; count &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;bigCount:&#123;&#123; bigCount &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;largeCount:&#123;&#123; largeCount &#125;&#125;&lt;/h1&gt;    &lt;input v-model.number=&quot;num&quot;&gt;    &lt;button @click=&quot;handleCommit(num)&quot;&gt;点击commit&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapGetters, mapMutations&#125; from &#x27;vuex&#x27;export default &#123;  name: &quot;Child&quot;,  data() &#123;    return &#123;      num: 1    &#125;  &#125;,  computed: &#123;    ...mapState([&#x27;count&#x27;]),    ...mapGetters([&#x27;bigCount&#x27;, &#x27;largeCount&#x27;])  &#125;,  methods: &#123;    ...mapMutations(&#123;handleCommit: &#x27;HANDLE_ADD&#x27;&#125;),  &#125;&#125;&lt;/script&gt;</code></pre></div><h2 id="4-4-mapActions"><a href="#4-4-mapActions" class="headerlink" title="4.4 mapActions"></a>4.4 mapActions</h2><p>在 Child.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;count:&#123;&#123; count &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;bigCount:&#123;&#123; bigCount &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;largeCount:&#123;&#123; largeCount &#125;&#125;&lt;/h1&gt;    &lt;input v-model.number=&quot;num&quot;&gt;    &lt;button @click=&quot;handleCommit(num)&quot;&gt;点击commit&lt;/button&gt;    &lt;button @click=&quot;handleDispatch(num)&quot;&gt;点击dispatch&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapGetters, mapActions, mapMutations&#125; from &#x27;vuex&#x27;export default &#123;  name: &quot;Child&quot;,  data() &#123;    return &#123;      num: 1    &#125;  &#125;,  computed: &#123;    ...mapState([&#x27;count&#x27;]),    ...mapGetters([&#x27;bigCount&#x27;, &#x27;largeCount&#x27;])  &#125;,  methods: &#123;    ...mapMutations(&#123;handleCommit: &#x27;HANDLE_ADD&#x27;&#125;),    ...mapActions(&#123;handleDispatch: &#x27;handleAdd&#x27;&#125;),  &#125;&#125;&lt;/script&gt;</code></pre></div><h1 id="五、模块化"><a href="#五、模块化" class="headerlink" title="五、模块化"></a>五、模块化</h1><h2 id="5-1-模块化实现"><a href="#5-1-模块化实现" class="headerlink" title="5.1 模块化实现"></a>5.1 模块化实现</h2><blockquote><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p></blockquote><p>在 src&#x2F;store 下新建一个文件夹，命名为 modules。在 modules 下新建一个 countAbout.js 用于存放和计数相关的 store 相关子模块。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    <span class="hljs-attr">state</span>: &#123;        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>    &#125;,    <span class="hljs-attr">getters</span>: &#123;        <span class="hljs-title function_">bigCount</span>(<span class="hljs-params">state</span>) &#123;            <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">10</span>        &#125;,        <span class="hljs-title function_">largeCount</span>(<span class="hljs-params">state, getters</span>) &#123;            <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> + getters.<span class="hljs-property">bigCount</span>        &#125;    &#125;,    <span class="hljs-attr">mutations</span>: &#123;        <span class="hljs-title function_">HANDLE_ADD</span>(<span class="hljs-params">state, num</span>) &#123;            state.<span class="hljs-property">count</span> += num        &#125;    &#125;,    <span class="hljs-attr">actions</span>: &#123;        <span class="hljs-title function_">handleAdd</span>(<span class="hljs-params">context, num</span>) &#123;            context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;HANDLE_ADD&#x27;</span>, num)        &#125;    &#125;&#125;</code></pre></div><p>在 src&#x2F;store&#x2F;index.js 中：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">import</span> countAbout <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store/modules/countAbout&quot;</span>;<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;    <span class="hljs-attr">modules</span>: &#123;        countAbout    &#125;&#125;)</code></pre></div><h2 id="5-2-命名空间"><a href="#5-2-命名空间" class="headerlink" title="5.2 命名空间"></a>5.2 命名空间</h2><p>在模块中使用 <code>namespaced:true</code> 开启命名空间。</p><p>在 countAbout.js 中：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,    <span class="hljs-attr">state</span>: &#123;        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>    &#125;,    <span class="hljs-attr">getters</span>: &#123;        <span class="hljs-title function_">bigCount</span>(<span class="hljs-params">state</span>) &#123;            <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">10</span>        &#125;,        <span class="hljs-title function_">largeCount</span>(<span class="hljs-params">state, getters</span>) &#123;            <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> + getters.<span class="hljs-property">bigCount</span>        &#125;    &#125;,    <span class="hljs-attr">mutations</span>: &#123;        <span class="hljs-title function_">HANDLE_ADD</span>(<span class="hljs-params">state, num</span>) &#123;            state.<span class="hljs-property">count</span> += num        &#125;    &#125;,    <span class="hljs-attr">actions</span>: &#123;        <span class="hljs-title function_">handleAdd</span>(<span class="hljs-params">context, num</span>) &#123;            context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;HANDLE_ADD&#x27;</span>, num)        &#125;    &#125;&#125;</code></pre></div><p>在 Child.vue 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;count:&#123;&#123; count &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;bigCount:&#123;&#123; bigCount &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;largeCount:&#123;&#123; largeCount &#125;&#125;&lt;/h1&gt;    &lt;input v-model.number=&quot;num&quot;&gt;    &lt;button @click=&quot;handleCommit(num)&quot;&gt;点击commit&lt;/button&gt;    &lt;button @click=&quot;handleDispatch(num)&quot;&gt;点击dispatch&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapGetters, mapActions, mapMutations&#125; from &#x27;vuex&#x27;export default &#123;  name: &quot;Child&quot;,  data() &#123;    return &#123;      num: 1    &#125;  &#125;,  computed: &#123;    ...mapState(&#x27;countAbout&#x27;, [&#x27;count&#x27;]),    ...mapGetters(&#x27;countAbout&#x27;, [&#x27;bigCount&#x27;, &#x27;largeCount&#x27;])  &#125;,  methods: &#123;    ...mapMutations(&#x27;countAbout&#x27;,&#123;handleCommit:&#x27;HANDLE_ADD&#x27;&#125;),    ...mapActions(&#x27;countAbout&#x27;,&#123;handleDispatch:&#x27;handleAdd&#x27;&#125;),  &#125;&#125;&lt;/script&gt;</code></pre></div><h1 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h1><ul><li><a href="https://v3.vuex.vuejs.org/zh/">https://v3.vuex.vuejs.org/zh/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
      <tag>Vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue2】Vue笔记</title>
    <link href="/archives/adf5c49.html"/>
    <url>/archives/adf5c49.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-Vue-核心"><a href="#第一章-Vue-核心" class="headerlink" title="第一章 Vue 核心"></a>第一章 Vue 核心</h1><h2 id="1-1-Vue-demo"><a href="#1-1-Vue-demo" class="headerlink" title="1.1 Vue demo"></a>1.1 Vue demo</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        //容器        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello &#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">            <span class="hljs-comment">//关闭生产环境的提示</span></span><span class="language-javascript">            <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;</span><span class="language-javascript"></span><span class="language-javascript">            <span class="hljs-comment">//创建Vue的实例</span></span><span class="language-javascript">            <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">                <span class="hljs-comment">//指定当前Vue实例为哪个容器服务，值通常为css选择器字符串</span></span><span class="language-javascript">                <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#root&quot;</span>,</span><span class="language-javascript"></span><span class="language-javascript">                <span class="hljs-comment">//data中存放数据，数据供el指定的容器使用</span></span><span class="language-javascript">                <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">                    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;vue&quot;</span>,</span><span class="language-javascript">                &#125;,</span><span class="language-javascript">            &#125;);</span><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><ul><li><p>想要Vue工作，就必须创建一个Vue的实例，且要传入一个配置对象</p></li><li><p>root容器  代码仍然需要符合html规范，不过混入了Vue的语法</p></li><li><p>root容器中的代码被称为Vue模板</p></li><li><p>容器和Vue实例需要一一对应</p></li><li><p><code>&#123;&#123; &#125;&#125;</code>中写js表达式。表达式会生成一个值，放在任何需要值的地方</p></li><li><p>data中的数据发生变化时，模板中用到该数据中的地方也会发生改变</p></li></ul><h2 id="1-2-模板语法"><a href="#1-2-模板语法" class="headerlink" title="1.2 模板语法"></a>1.2 模板语法</h2><h3 id="1-2-1-插值语法"><a href="#1-2-1-插值语法" class="headerlink" title="1.2.1 插值语法"></a>1.2.1 插值语法</h3><ul><li><p>写法：<code>&#123;&#123; &#125;&#125;</code>中插入<strong>表达式</strong>，可以读取data中的属性</p><div class="code-wrapper"><pre><code class="hljs html">//模板中<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello &#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>//data中data:&#123;msg: &quot;vue&quot;,&#125;</code></pre></div></li><li><p>功能：插值表达式用在标签体中，用于解析标签体内容</p></li></ul><h3 id="1-2-2-指令语法"><a href="#1-2-2-指令语法" class="headerlink" title="1.2.2 指令语法"></a>1.2.2 指令语法</h3><h4 id="例如-v-bind"><a href="#例如-v-bind" class="headerlink" title="例如 v-bind"></a>例如 v-bind</h4><ul><li><p>写法：<code>v-bind:href = &quot;xxx&quot;</code>，href可以替换成任一属性名，<code>xxx</code>是js表达式。<code>v-bind:</code> 可以简写为 <code>:</code></p><div class="code-wrapper"><pre><code class="hljs html">//模板中<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span> &gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//data中data:&#123;url: &quot;https://www.baidu.com&quot;,&#125;</code></pre></div></li><li><p>功能：v-bind 可以给标签中任何一个属性动态绑定值</p></li></ul><h2 id="1-3-数据绑定"><a href="#1-3-数据绑定" class="headerlink" title="1.3 数据绑定"></a>1.3 数据绑定</h2><h3 id="1-3-1-单向数据绑定-v-bind"><a href="#1-3-1-单向数据绑定-v-bind" class="headerlink" title="1.3.1 单向数据绑定 v-bind"></a>1.3.1 单向数据绑定 v-bind</h3><ul><li>数据只能从data流向页面。data中的数据发生变化，页面上对应的数据会变化。但是页面上的数据变化，data中对应的数据不会变化。</li></ul><h3 id="1-3-2-双向数据绑定-v-model"><a href="#1-3-2-双向数据绑定-v-model" class="headerlink" title="1.3.2 双向数据绑定 v-model"></a>1.3.2 双向数据绑定 v-model</h3><ul><li>写法：<code>v-model:value = &quot;xxx&quot;</code>。<code>v-model:value</code>可以简写成<code>v-model</code></li><li>功能：数据不仅能从data流向页面，还可以从页面流向data。页面上的数据和data中对应的数据双向绑定。两者其中一个发生变化，另一个同时进行变化。</li><li>备注：<ul><li>v-model只能用在表单类元素中</li><li><code>v-model:value</code>可以简写成<code>v-model</code>，因为v-model默认收集的就是value的值</li></ul></li></ul><h3 id="补充：el和data的两种写法"><a href="#补充：el和data的两种写法" class="headerlink" title="补充：el和data的两种写法"></a>补充：el和data的两种写法</h3><h4 id="1-el的两种写法"><a href="#1-el的两种写法" class="headerlink" title="1. el的两种写法"></a>1. el的两种写法</h4><ol><li>写在Vue的配置对象中</li><li>使用<code>$mount</code>挂载</li></ol><h4 id="2-data的两种写法"><a href="#2-data的两种写法" class="headerlink" title="2. data的两种写法"></a>2. data的两种写法</h4><ol><li><p>对象式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,    <span class="hljs-attr">data</span>:&#123;    msg :<span class="hljs-string">&#x27;vue&#x27;</span>    &#125;&#125;);</code></pre></div></li><li><p>函数式。但是，由Vue管理的函数不能写成箭头函数，因为箭头函数没有自己的this，就会向外查找，找到的是全局的window。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<span class="hljs-comment">//this是Vue实例对象</span>        <span class="hljs-keyword">return</span> &#123;            msg :<span class="hljs-string">&#x27;vue&#x27;</span>        &#125;    &#125;  &#125;);</code></pre></div></li></ol><h2 id="1-4-MVVM模型"><a href="#1-4-MVVM模型" class="headerlink" title="1.4 MVVM模型"></a>1.4 MVVM模型</h2><ul><li>M：Model，data中的数据</li><li>V：View，模板代码</li><li>VM：ViewModel，Vue实例</li></ul><h2 id="1-5-数据代理"><a href="#1-5-数据代理" class="headerlink" title="1.5 数据代理"></a>1.5 数据代理</h2><ul><li><p>通过一个对象代理对另一个对象中属性的操作</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,&#125;;<span class="hljs-keyword">let</span> obj_proxy = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj_proxy, <span class="hljs-string">&quot;x&quot;</span>, &#123;    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> obj.<span class="hljs-property">x</span>;    &#125;,    <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>)&#123;        obj.<span class="hljs-property">x</span> = val    &#125;&#125;);obj_proxy.<span class="hljs-property">x</span> = <span class="hljs-number">200</span></code></pre></div><p>在以上的例子中，通过<code>obj_proxy</code>代理对<code>obj</code>中属性<code>x</code>的读写</p></li></ul><h2 id="1-6-Vue中的数据代理"><a href="#1-6-Vue中的数据代理" class="headerlink" title="1.6 Vue中的数据代理"></a>1.6 Vue中的数据代理</h2><p><img src="/images/Vue%E7%AC%94%E8%AE%B0/image-20211209232047513.png" alt="image-20211209232047513"></p><ul><li>通过vm对象来代理data对象中属性的操作，方便操作data中的数据</li><li>原理：通过<code>Object.defineProperty()</code>把data对象中所有属性添加到vm上，为每一个添加到vm上的属性都指定getter和setter，在getter和setter中去读写data中的属性。</li></ul><h2 id="1-7-事件"><a href="#1-7-事件" class="headerlink" title="1.7 事件"></a>1.7 事件</h2><h3 id="1-7-1-事件处理"><a href="#1-7-1-事件处理" class="headerlink" title="1.7.1 事件处理"></a>1.7.1 事件处理</h3><ul><li><p>写法：<code>v-on:xxx</code>，<code>xxx</code>是事件类型。<code>v-on:xxx</code>可以简写成<code>＠xxx</code></p></li><li><p>事件的回调写在methods中，最终会出现在vm上</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//模板中</span>&lt;button @click=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;不传参数&lt;/button&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick1(0)&quot;</span>&gt;</span>传参数,不保留event<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick2(0,$event)&quot;</span>&gt;</span>传参数,保留event<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="hljs-comment">//js中</span><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;&#125;;&#125;,    <span class="hljs-attr">methods</span>: &#123;        <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event);        &#125;,        <span class="hljs-title function_">handleClick1</span>(<span class="hljs-params">num</span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);        &#125;,        <span class="hljs-title function_">handleClick2</span>(<span class="hljs-params">num, event</span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num, event);        &#125;,   &#125;,&#125;);</code></pre></div></li><li><p>不给事件处理函数传参数时，默认传入event事件对象</p></li><li><p>给事件处理函数传参，参数列表中默认不保留event事件对象</p></li><li><p>给事件处理函数传参，可以使用<code>$</code>进行占位，保留event对象</p></li><li><p>vm中的data会做数据代理、数据劫持，但是在methods中的函数不会做数据代理</p></li></ul><h3 id="1-7-2-Vue中的事件修饰符"><a href="#1-7-2-Vue中的事件修饰符" class="headerlink" title="1.7.2 Vue中的事件修饰符"></a>1.7.2 Vue中的事件修饰符</h3><ol><li><p><code>prevent</code>：阻止默认事件</p><div class="code-wrapper"><pre><code class="hljs html">//阻止默认事件后 只会执行handleClick() 页面不会跳转<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>    点击跳转<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div></li><li><p><code>stop</code>：阻止事件冒泡</p><div class="code-wrapper"><pre><code class="hljs html">//阻止事件冒泡后 只会执行handleClick1() 不会执行handleClick2()//因为使用了.prevent 所以页面不会跳转<span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick2&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">&quot;handleClick1&quot;</span>&gt;</span>        点击跳转    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p><code>once</code>：事件只触发一次</p><div class="code-wrapper"><pre><code class="hljs html">//事件只会触发一次 第二次点击div时 事件不会触发<span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;alert(&#x27;hello  vue&#x27;)&quot;</span>&gt;</span>div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p><code>capture</code>：使用事件的捕获模式</p><div class="code-wrapper"><pre><code class="hljs html">//默认情况下 捕获阶段不会触发事件 也就是先执行handleClick1() 然后执行handleClick2()//使用事件的捕获模式 捕获阶段会触发事件 也就是先执行handleClick2() 然后执行handleClick1()<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;border:1px solid red;width: 200px ;height: 200px;&#x27;</span> @<span class="hljs-attr">click</span> = <span class="hljs-string">&#x27;handleClick2&#x27;</span>&gt;</span>    div2    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;border:1px solid green;width: 100px ;height: 100px;&#x27;</span>  @<span class="hljs-attr">click</span> = <span class="hljs-string">&#x27;handleClick1&#x27;</span>&gt;</span>        div1    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p><code>self</code>：只有event.target是当前操作的元素时才触发事件</p><div class="code-wrapper"><pre><code class="hljs html">//默认情况下 handleClick()会触发两次 其中事件冒泡到div上时 event.target仍是button //加上.self后 事件的event.target不是当前元素时不会触发事件 handleClick()只触发一次 <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><span class="hljs-tag">     <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid red; width: 200px; height: 200px&quot;</span></span><span class="hljs-tag">     @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;handleClick&quot;</span></span><span class="hljs-tag">     &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>点击按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p><code>passive</code>：事件的默认行为立即执行，无需等待事件回调执行完毕</p><ul><li>默认情况下，事件动作触发，之后执行事件的回调函数，回调结束后，事件的默认行为才开始执行</li><li>使用<code>.passive</code>后，事件的默认行为立即执行，无需等待事件的回调函数</li></ul></li></ol><h3 id="1-7-3-键盘事件"><a href="#1-7-3-键盘事件" class="headerlink" title="1.7.3 键盘事件"></a>1.7.3 键盘事件</h3><ul><li><p>Vue中常用的按键别名如下：</p><ul><li>回车：enter</li><li>删除：delete</li><li>退出：esc</li><li>空格：space</li><li>换行：tab</li><li>上：up</li><li>下：down</li><li>左：left</li><li>右：right</li></ul><div class="code-wrapper"><pre><code class="hljs html">//只有在enter键抬起之后 showInfo()才会触发 此处的enter是别名<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;按下回车提示输入&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;showInfo”/&gt;</span></span></code></pre></div></li><li><p>Vue中没有提供别名的按键，可以使用原始的key值去绑定，但是要注意转为短横线命名方式</p></li><li><p>系统修饰键的用法比较特殊：ctrl、alt、shift、meta</p><ul><li><p>在配合keyup使用时，按下修饰键的同时，再按下其他按键，随后释放其他按键，事件才会触发</p><div class="code-wrapper"><pre><code class="hljs html">//ctrl+任意键按下后抬起都会触发事件<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">keyup.ctrl</span>=<span class="hljs-string">&quot;showInfo&quot;</span> /&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//只有 ctrl+y 按下后抬起 才会触发事件<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">keyup.ctrl.y</span>=<span class="hljs-string">&quot;showInfo&quot;</span> /&gt;</span></code></pre></div></li><li><p>在配合keydown使用时，正常触发事件</p></li></ul></li></ul><h2 id="1-8-计算属性"><a href="#1-8-计算属性" class="headerlink" title="1.8 计算属性"></a>1.8 计算属性</h2><h3 id="1-8-1-一个姓名拼接案例"><a href="#1-8-1-一个姓名拼接案例" class="headerlink" title="1.8.1 一个姓名拼接案例"></a>1.8.1 一个姓名拼接案例</h3><ul><li><p>使用methods的方式实现姓名拼接demo</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    姓:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text &quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    姓名:&#123;&#123;fullName()&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;<span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;&quot;</span>,        &#125;;    &#125;,    <span class="hljs-attr">methods</span>: &#123;        <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>;        &#125;,    &#125;,&#125;);</code></pre></div></li><li><p>注意：只要data中的数据发生变化，Vue就会重新解析模板，页面中所有用到该数据的地方都会发生变化。在上面的demo中，页面上输入姓或者名后，因为<code>fullName()</code>用到了发生改变的数据，所以Vue会重新调用<code>fullName()</code></p></li></ul><h3 id="1-8-2-使用计算属性重写上述案例"><a href="#1-8-2-使用计算属性重写上述案例" class="headerlink" title="1.8.2 使用计算属性重写上述案例"></a>1.8.2 使用计算属性重写上述案例</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    姓:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text &quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    姓名:&#123;&#123;fullName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;</span><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">                <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;&quot;</span>,</span><span class="language-javascript">                <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;&quot;</span>,</span><span class="language-javascript">            &#125;;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">computed</span>: &#123;</span><span class="language-javascript">             <span class="hljs-attr">fullName</span>:&#123;</span><span class="language-javascript">                 <span class="hljs-comment">//获取计算属性fullName的值时调用</span></span><span class="language-javascript">                 <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span><span class="language-javascript">                     <span class="hljs-comment">//Vue已经将this的指向调整成了vm</span></span><span class="language-javascript">                     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>;</span><span class="language-javascript">                 &#125;,</span><span class="language-javascript">                 <span class="hljs-comment">//设置fullName的值时调用</span></span><span class="language-javascript">                 <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>)&#123;</span><span class="language-javascript">             arr = newVal.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)</span><span class="language-javascript">                     <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = arr[<span class="hljs-number">0</span>];</span><span class="language-javascript">                     <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = arr[arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>];</span><span class="language-javascript">        &#125;</span><span class="language-javascript">             &#125;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//如果只有getter，没有setter，可以简写如下：</span><span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>;&#125;,</code></pre></div><ul><li><p>将同一函数定义为方法还是计算属性，相同点和不同点在哪里？</p><blockquote><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。</p></blockquote><blockquote><p>这就意味着只要 <code>lastName</code>和 <code>firstName</code>还没有发生改变，多次访问 <code>fullName</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p></blockquote></li><li><p>什么时候调用计算属性？</p><ol><li>初次读取<code>fullName</code>时</li><li>所依赖的数据发生变化时</li></ol></li><li><p>计算属性会直接出现在vm上，直接读取即可。</p></li></ul><h2 id="1-9-监视属性"><a href="#1-9-监视属性" class="headerlink" title="1.9 监视属性"></a>1.9 监视属性</h2><h3 id="1-9-1-一个监视属性的案例"><a href="#1-9-1-一个监视属性的案例" class="headerlink" title="1.9.1 一个监视属性的案例"></a>1.9.1 一个监视属性的案例</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>今天天气很&#123;&#123;info&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;flag = !flag&quot;</span>&gt;</span>点击切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;</span><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">                <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span>,</span><span class="language-javascript">                <span class="hljs-attr">info</span>:<span class="hljs-string">&#x27;&#x27;</span></span><span class="language-javascript">            &#125;;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">watch</span>: &#123;</span><span class="language-javascript">            <span class="hljs-attr">flag</span>: &#123;</span><span class="language-javascript">                <span class="hljs-comment">//初始化时 让handler调用一下</span></span><span class="language-javascript">                <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,</span><span class="language-javascript">                <span class="hljs-comment">//当flag发生变化时 调用handler</span></span><span class="language-javascript">                <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal,oldVal</span>) &#123;</span><span class="language-javascript">                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal,oldVal)</span><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">info</span> = newVal?<span class="hljs-string">&#x27;凉爽&#x27;</span>:<span class="hljs-string">&#x27;炎热&#x27;</span></span><span class="language-javascript">                &#125;,</span><span class="language-javascript">            &#125;,</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;</span><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">                <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span>,</span><span class="language-javascript">                <span class="hljs-attr">info</span>: <span class="hljs-string">&quot;&quot;</span>,</span><span class="language-javascript">            &#125;;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-comment">//第二种写法</span></span><span class="language-javascript">    vm.$watch(<span class="hljs-string">&quot;flag&quot;</span>, &#123;</span><span class="language-javascript">        <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,</span><span class="language-javascript">        <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;</span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal);</span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">info</span> = newVal ? <span class="hljs-string">&quot;凉爽&quot;</span> : <span class="hljs-string">&quot;炎热&quot;</span>;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li>当监视属性变化时，回调函数自动调用，进行相关操作</li><li>监视的属性可以是data中的属性，也可以是计算属性。无论监视哪种属性，属性必须要存在。</li></ul><h3 id="1-9-2-深度监视"><a href="#1-9-2-深度监视" class="headerlink" title="1.9.2 深度监视"></a>1.9.2 深度监视</h3><div class="code-wrapper"><pre><code class="hljs html">//点击按钮 obj内的数据发生了变化 但是Vue无法检测到<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>obj中的a的值是&#123;&#123;obj.a&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;obj.a++&quot;</span>&gt;</span>点击让a加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>obj中的b的值是&#123;&#123;obj.b&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;obj.b++&quot;</span>&gt;</span>点击让b加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">obj</span>: &#123;                <span class="hljs-attr">a</span>: <span class="hljs-number">100</span>,                <span class="hljs-attr">b</span>: <span class="hljs-number">200</span>,            &#125;,        &#125;;    &#125;,    <span class="hljs-attr">watch</span>: &#123;        <span class="hljs-comment">//监视对象，即使对象中的属性值发生了变化，由于地址值没有变化，Vue无法成功检测到</span>        <span class="hljs-string">&quot;obj&quot;</span>: &#123;            <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) &#123;                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj改变了&quot;</span>);            &#125;,        &#125;,    &#125;,&#125;);</code></pre></div><ul><li><p>在上面这种情况中，即使<code>obj.a</code>或者<code>obj.b</code>变化，Vue也无法检测得到。因为obj中数据的地址值没有改变。</p></li><li><p>如果想让Vue检测到对象内的属性值的变化（深度监视），需要开启<code>deep</code>配置项（watch默认不开启深度监视）。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//深度监视，可以监视多级结构中所有属性的变化。</span><span class="hljs-attr">watch</span>: &#123;    <span class="hljs-comment">//监视对象</span>    <span class="hljs-attr">obj</span>: &#123;        <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>,            <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj改变了&quot;</span>);        &#125;,    &#125;,&#125;,</code></pre></div></li><li><p>Vue对数组的监听是浅监听，也就是它只能监听到数组的长度或者有无的变化。无法监视数组中的元素的变化，深度监视也不可以。</p></li><li><p>如果不需要<code>immediate</code>和<code>deep</code>配置项，可以简写监视属性的形式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<span class="hljs-title function_">flag</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal);<span class="hljs-variable language_">this</span>.<span class="hljs-property">info</span> = newVal ? <span class="hljs-string">&quot;凉爽&quot;</span> : <span class="hljs-string">&quot;炎热&quot;</span>;&#125;,&#125;,</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//不可以写成箭头函数，因为可能造成this的指向有问题</span>vm.$watch(<span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">newVal, oldVal</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">info</span> = newVal ? <span class="hljs-string">&quot;凉爽&quot;</span> : <span class="hljs-string">&quot;炎热&quot;</span>;&#125;);</code></pre></div></li></ul><h2 id="1-10-计算属性和监视属性对比"><a href="#1-10-计算属性和监视属性对比" class="headerlink" title="1.10 计算属性和监视属性对比"></a>1.10 计算属性和监视属性对比</h2><ul><li><p>computed能完成的功能，watch都能完成</p></li><li><p>如果函数中没有异步操作，对于相同的功能，使用计算属性更简洁</p></li><li><p>计算属性中无法执行异步操作，这时需要监视属性来做</p></li><li><p>注意：1. 所被Vue管理的函数，最好写成普通函数。这样this的指向才是vm或组件实例对象。2. 所有不被Vue管理的函数（定时器回调函数、ajax回调函数等），最好写成箭头函数。这样this的指向才是vm或组件实例对象。</p></li></ul><h2 id="1-11-class和style绑定"><a href="#1-11-class和style绑定" class="headerlink" title="1.11 class和style绑定"></a>1.11 class和style绑定</h2><h3 id="1-11-1-绑定class样式"><a href="#1-11-1-绑定class样式" class="headerlink" title="1.11.1 绑定class样式"></a>1.11.1 绑定class样式</h3><ol><li><p>字符串写法</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.basic</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;&#125;<span class="hljs-selector-class">.sad</span> &#123;    <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">2</span>, <span class="hljs-number">197</span>, <span class="hljs-number">2</span>);    <span class="hljs-attribute">background-color</span>: gray;&#125;<span class="hljs-selector-class">.normal</span> &#123;    <span class="hljs-attribute">background-color</span>: skyblue;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;style&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeStyle&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">style</span>: <span class="hljs-string">&quot;normal&quot;</span>,        &#125;;    &#125;,    <span class="hljs-attr">methods</span>: &#123;        <span class="hljs-title function_">changeStyle</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span> === <span class="hljs-string">&quot;normal&quot;</span> ? <span class="hljs-string">&quot;sad&quot;</span> : <span class="hljs-string">&quot;normal&quot;</span>;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;changeStyle&quot;</span>);        &#125;,    &#125;,&#125;);</code></pre></div><p>适用于字符串的类名不确定，需要动态指定</p></li><li><p>第一种数组写法</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.s1</span> &#123;    <span class="hljs-attribute">background-color</span>: yellowgreen;&#125;<span class="hljs-selector-class">.s2</span> &#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;    <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">10px</span> red;&#125;<span class="hljs-selector-class">.s3</span> &#123;    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;styleArr&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeStyle&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">styleArr</span>: [<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-string">&quot;s2&quot;</span>, <span class="hljs-string">&quot;s3&quot;</span>],        &#125;;    &#125;,&#125;);</code></pre></div><p>适用于要绑定的样式个数不确定，名字也不确定</p></li><li><p>第二种数组写法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[s1 ,s2, s3]&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeStyle&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">s1</span>: <span class="hljs-string">&quot;s1&quot;</span>,            <span class="hljs-attr">s2</span>: <span class="hljs-string">&quot;s2&quot;</span>,            <span class="hljs-attr">s3</span>: <span class="hljs-string">&quot;s3&quot;</span>,        &#125;;    &#125;&#125;);</code></pre></div></li><li><p>第一种对象写法</p><div class="code-wrapper"><pre><code class="hljs ruby">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-symbol">:class=<span class="hljs-string">&quot;styleObj&quot;</span>&gt;test&lt;/div&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">styleObj</span>: &#123;                <span class="hljs-attr">s1</span>: <span class="hljs-literal">true</span>,                <span class="hljs-attr">s2</span>: <span class="hljs-literal">true</span>,                <span class="hljs-attr">s3</span>: <span class="hljs-literal">true</span>,            &#125;,        &#125;;    &#125;,&#125;);</code></pre></div><p>适用于要绑定的样式名字、个数都确定，但是用动态决定用还是不用</p></li><li><p>第二种对象写法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;s1,s2,s3&#125;&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">s1</span>: <span class="hljs-literal">true</span>,            <span class="hljs-attr">s2</span>: <span class="hljs-literal">true</span>,            <span class="hljs-attr">s3</span>: <span class="hljs-literal">true</span>,        &#125;;    &#125;,&#125;);</code></pre></div></li></ol><h3 id="1-11-2-绑定style样式"><a href="#1-11-2-绑定style样式" class="headerlink" title="1.11.2 绑定style样式"></a>1.11.2 绑定style样式</h3><ol><li><p>第一种对象写法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;fontStyle&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">fontStyle</span>: &#123;                <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;50px&quot;</span>,            &#125;,        &#125;;    &#125;,&#125;);</code></pre></div></li><li><p>第二种对象写法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;fontSize:size+&#x27;px&#x27;&#125;&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">size</span>:<span class="hljs-number">50</span>        &#125;;    &#125;,&#125;);</code></pre></div></li><li><p>数组写法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleArr&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">styleArr</span>: [                &#123;                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;50px&quot;</span>,                    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span>,                &#125;,                &#123;                    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;green&quot;</span>,                &#125;,            ],        &#125;;    &#125;,&#125;);</code></pre></div></li></ol><h2 id="1-12-条件渲染v-if-v-show"><a href="#1-12-条件渲染v-if-v-show" class="headerlink" title="1.12 条件渲染v-if v-show"></a>1.12 条件渲染v-if v-show</h2><h3 id="1-12-1-v-show条件渲染"><a href="#1-12-1-v-show条件渲染" class="headerlink" title="1.12.1 v-show条件渲染"></a>1.12.1 v-show条件渲染</h3><ol><li><p>写法：<code>v-show = &#39;true&#39;</code>或<code>v-show = &#39;false&#39;</code>，例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;block&#x27;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&#x27;false&#x27;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p>原理：存在于DOM上，但是在<code>&lt;div&gt;</code>上增加一个<code>style=&quot;display: none;&quot;</code></p></li></ol><h3 id="1-12-2-v-if条件渲染-和v-else-if、-v-else"><a href="#1-12-2-v-if条件渲染-和v-else-if、-v-else" class="headerlink" title="1.12.2 v-if条件渲染 和v-else-if、 v-else"></a>1.12.2 v-if条件渲染 和v-else-if、 v-else</h3><ol><li><p>写法：<code>v-if = &#39;true&#39;</code>或<code>v-if = &#39;false&#39;</code>，例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;block&#x27;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&#x27;false&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;block&#x27;</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">if</span>=<span class="hljs-string">&#x27;false&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;block&#x27;</span> <span class="hljs-attr">v-else</span>&gt;</span>test3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p>原理：DOM上不生成该<code>&lt;div&gt;</code></p></li><li><p><code>v-if</code>、<code>v-else-if</code>、<code>v-else</code>必须连续使用，中间不允许其他的<code>&lt;div&gt;</code>打断</p></li></ol><h3 id="1-12-3-怎么选择v-show-和-v-if"><a href="#1-12-3-怎么选择v-show-和-v-if" class="headerlink" title="1.12.3 怎么选择v-show 和 v-if"></a>1.12.3 怎么选择v-show 和 v-if</h3><ul><li>显示和隐藏切换的频率较高时，使用<code>v-show</code></li><li>显示和隐藏切换的频率较低时，使用<code>v-if</code></li></ul><h3 id="1-13-4-template"><a href="#1-13-4-template" class="headerlink" title="1.13.4 template"></a>1.13.4 template</h3><ul><li><p>想一次控制多个div，可以在多个<code>&lt;div&gt;</code>外再包一个<code>&lt;div&gt;</code>，但是这种办法破坏了页面的结构（多了一层div）。解决方法：使用<code>&lt;template&gt;</code>。例：</p><div class="code-wrapper"><pre><code class="hljs html">//使用div<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&#x27;false&#x27;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>//使用template<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&#x27;false&#x27;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div></li></ul><h2 id="1-14-列表渲染v-for"><a href="#1-14-列表渲染v-for" class="headerlink" title="1.14 列表渲染v-for"></a>1.14 列表渲染v-for</h2><h3 id="1-14-1-遍历列表"><a href="#1-14-1-遍历列表" class="headerlink" title="1.14.1 遍历列表"></a>1.14.1 遍历列表</h3><ol><li><p>第一种形式：key用id值</p><div class="code-wrapper"><pre><code class="hljs armasm">姓名:<span class="hljs-built_in">p1</span> 年龄:<span class="hljs-number">18</span>姓名:<span class="hljs-built_in">p2</span> 年龄:<span class="hljs-number">19</span>姓名:<span class="hljs-built_in">p3</span> 年龄:<span class="hljs-number">20</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;p in person&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;p.id&quot;</span>&gt;</span>        姓名:&#123;&#123;p.name&#125;&#125; 年龄:&#123;&#123;p.age&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-attr">person</span>: [            &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;p1&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;,            &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;p2&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span> &#125;,            &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;p3&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,        ],    &#125;;&#125;,</code></pre></div></li><li><p>第二种形式：key用index值</p><div class="code-wrapper"><pre><code class="hljs armasm">姓名:<span class="hljs-built_in">p1</span> 年龄:<span class="hljs-number">18</span>姓名:<span class="hljs-built_in">p2</span> 年龄:<span class="hljs-number">19</span>姓名:<span class="hljs-built_in">p3</span> 年龄:<span class="hljs-number">20</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) in person&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>    姓名:&#123;&#123;p.name&#125;&#125; 年龄:&#123;&#123;p.age&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div></li></ol><h3 id="1-14-2-遍历对象"><a href="#1-14-2-遍历对象" class="headerlink" title="1.14.2 遍历对象"></a>1.14.2 遍历对象</h3><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>-<span class="hljs-number">100</span><span class="hljs-attribute">b</span>-<span class="hljs-number">200</span><span class="hljs-attribute">c</span>-<span class="hljs-number">300</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,key) in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-attr">obj</span>: &#123;            <span class="hljs-attr">a</span>: <span class="hljs-number">100</span>,            <span class="hljs-attr">b</span>: <span class="hljs-number">200</span>,            <span class="hljs-attr">c</span>: <span class="hljs-number">300</span>,        &#125;,    &#125;;&#125;</code></pre></div><h3 id="1-14-3-遍历字符串"><a href="#1-14-3-遍历字符串" class="headerlink" title="1.14.3 遍历字符串"></a>1.14.3 遍历字符串</h3><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">q</span> - <span class="hljs-number">0</span><span class="hljs-attribute">w</span> - <span class="hljs-number">1</span><span class="hljs-attribute">e</span> - <span class="hljs-number">2</span><span class="hljs-attribute">r</span> - <span class="hljs-number">3</span><span class="hljs-attribute">t</span> - <span class="hljs-number">4</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(s,index) in str&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>        &#123;&#123;s&#125;&#125; - &#123;&#123;index&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>() &#123;</span><span class="hljs-class">    <span class="hljs-title">return</span> &#123;</span><span class="hljs-class">        <span class="hljs-title">str</span>: &quot;<span class="hljs-title">qwert</span>&quot;,</span><span class="hljs-class">    &#125;;</span>&#125;</code></pre></div><h3 id="1-14-4-遍历指定次数"><a href="#1-14-4-遍历指定次数" class="headerlink" title="1.14.4 遍历指定次数"></a>1.14.4 遍历指定次数</h3><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>-<span class="hljs-number">0</span><span class="hljs-attribute">2</span>-<span class="hljs-number">1</span><span class="hljs-attribute">3</span>-<span class="hljs-number">2</span><span class="hljs-attribute">4</span>-<span class="hljs-number">3</span><span class="hljs-attribute">5</span>-<span class="hljs-number">4</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(num,index) in 5&quot;</span>&gt;</span>&#123;&#123;num&#125;&#125;-&#123;&#123;index&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><h2 id="1-15-v-for与key的原理"><a href="#1-15-v-for与key的原理" class="headerlink" title="1.15 v-for与key的原理"></a>1.15 v-for与key的原理</h2><h3 id="1-15-1-一个案例"><a href="#1-15-1-一个案例" class="headerlink" title="1.15.1 一个案例"></a>1.15.1 一个案例</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&#x27;add&#x27;</span>&gt;</span>点击添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;item.id&#x27;</span>&gt;</span>        &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;txet&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;index&#x27;</span>&gt;</span>        &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;txet&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">items</span>: [                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;p1&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;,                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;p2&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span> &#125;,                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;p3&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,            ],        &#125;;    &#125;,    <span class="hljs-attr">methods</span>: &#123;        <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;            <span class="hljs-keyword">const</span> temp = &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;p4&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">21</span>&#125;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">unshift</span>(temp)        &#125;    &#125;,&#125;);</code></pre></div><p>在输入框中输入一些信息，当点击按钮后，以<code>item.id</code>作为key的DOM不会发生错乱，但是以<code>index</code>作为key的DOM发生了错乱</p><h3 id="1-15-2-遍历链表时key的作用"><a href="#1-15-2-遍历链表时key的作用" class="headerlink" title="1.15.2 遍历链表时key的作用"></a>1.15.2 遍历链表时key的作用</h3><p><img src="/../images/Vue%E7%AC%94%E8%AE%B0/uTools_1640181813084.png" alt="uTools_1640181813084"></p><p><img src="/../images/Vue%E7%AC%94%E8%AE%B0/uTools_1640181987262.png" alt="uTools_1640181987262"></p><ol><li><p>key是虚拟DOM对象的标识，当状态中的数据发生变时，Vue会根据<strong>新数据</strong>生成<strong>新的虚拟DOM</strong>。随后vue进行<strong>新虚拟DOM</strong>与<strong>旧虚拟DOM</strong>的差异比较,比较规则如下:</p><ul><li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>①若虚拟DOM中内容没变，直接使用之前的真实DOM<br>②若虚拟DOM中内容变了，则生成新的真实DOM,随后替换掉页面中之前的真实DOM</p></li><li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key：<br>创建新的真实DOM，随后渲染到到页面</p></li></ul></li><li><p>用 index作为key可能会引发的问题:</p><ul><li>若对数据进行：逆序添加、逆序删除等破坏顺序操作会产生没有必要的真实DOM更新&#x3D;&#x3D;&gt;界面效果没问题,但效率低。</li><li>如果结构中还包含输入类的DOM：会产生错误DOM更新&#x3D;&#x3D;&gt;界面有问题</li></ul></li><li><p>开发中如何选择key?</p><ul><li><p>最好使用每条数据的<strong>唯一标识</strong>作为key，比如id、手机号、身份证号、学号等唯一值。</p></li><li><p>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示使用index作为key是没有问题的。</p></li></ul></li><li><p>如果遍历时不写key，vue会自动把index作为key</p></li></ol><h2 id="1-16-Vue数据监测原理"><a href="#1-16-Vue数据监测原理" class="headerlink" title="1.16 Vue数据监测原理"></a>1.16 Vue数据监测原理</h2><p>Vue会监视data中所有层次的数据</p><h3 id="1-16-1-Vue监测对象数据"><a href="#1-16-1-Vue监测对象数据" class="headerlink" title="1.16.1 Vue监测对象数据"></a>1.16.1 Vue监测对象数据</h3><ol><li>通过setter实现监视，且套在new Vue时就传入要监视的数据</li><li>对象中后添加的属性，Vue默认不做响应式处理；如需给后添加的属性做响应式处理，需要用<code>Vue.set()</code>或<code>vm.$set()</code></li></ol><h3 id="1-16-2-Vue监测数组数据"><a href="#1-16-2-Vue监测数组数据" class="headerlink" title="1.16.2 Vue监测数组数据"></a>1.16.2 Vue监测数组数据</h3><div class="code-wrapper"><pre><code class="hljs html">//点击按钮后，页面上的数据没有发生变化，说明vue没有监测到<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;click&#x27;</span>&gt;</span>点击修改数据第一项<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in items&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125; - &#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">items</span>: [<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>],        &#125;;    &#125;,    <span class="hljs-attr">methods</span>: &#123;        <span class="hljs-title function_">click</span>(<span class="hljs-params"></span>)&#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;p&#x27;</span>        &#125;    &#125;,&#125;);</code></pre></div><ul><li>直接通过索引值修改数组，Vue无法监测到这种变化。因为Vue不是靠setter监视数组数据变化的。</li><li>调用可以修改数组的7个方法，Vue会监测到变化。也可以用Vue.set()或者vm.$set()修改数组<ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul></li><li>Vue包裹了修改数组的7个方法，先调用原方法，再重新解析模板更新DOM。</li></ul><h2 id="1-17-Vue-set-与vm-set"><a href="#1-17-Vue-set-与vm-set" class="headerlink" title="1.17 Vue.set()与vm.$set()"></a>1.17 Vue.set()与vm.$set()</h2><h3 id="1-17-1-API"><a href="#1-17-1-API" class="headerlink" title="1.17.1 API"></a>1.17.1 API</h3><blockquote><h3 id="Vue-set-target-propertyName-x2F-index-value"><a href="#Vue-set-target-propertyName-x2F-index-value" class="headerlink" title="Vue.set( target, propertyName&#x2F;index, value )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-set">Vue.set( target, propertyName&#x2F;index, value )</a></h3><ul><li><p><strong>参数</strong>：</p></li><li><p><code>&#123;Object | Array&#125; target</code></p></li><li><p><code>&#123;string | number&#125; propertyName/index</code></p></li><li><p><code>&#123;any&#125; value</code></p></li><li><p><strong>返回值</strong>：设置的值。</p></li><li><p><strong>用法</strong>：</p></li></ul><p> 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 <code>this.myObject.newProperty = &#39;hi&#39;</code>)</p><ul><li><strong>注意</strong>：对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</li></ul></blockquote><blockquote><h3 id="vm-set-target-propertyName-x2F-index-value"><a href="#vm-set-target-propertyName-x2F-index-value" class="headerlink" title="vm.$set( target, propertyName&#x2F;index, value )"></a><a href="https://cn.vuejs.org/v2/api/#vm-set">vm.$set( target, propertyName&#x2F;index, value )</a></h3><ul><li><p><strong>参数</strong>：</p></li><li><p><code>&#123;Object | Array&#125; target</code></p></li><li><p><code>&#123;string | number&#125; propertyName/index</code></p></li><li><p><code>&#123;any&#125; value</code></p></li><li><p><strong>返回值</strong>：设置的值。</p></li><li><p><strong>用法</strong>：</p></li></ul><p> 这是全局 <code>Vue.set</code> 的<strong>别名</strong>。</p></blockquote><h3 id="1-17-2-例子"><a href="#1-17-2-例子" class="headerlink" title="1.17.2 例子"></a>1.17.2 例子</h3><ul><li>案例：点击按钮，向obj上增加一个响应式的属性</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;handleClick&#x27;</span>&gt;</span>添加属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,key) in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span>        &#123;&#123;key&#125;&#125; -- &#123;&#123;value&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">obj</span>: &#123;                <span class="hljs-attr">a</span>: <span class="hljs-number">100</span>,                <span class="hljs-attr">b</span>: <span class="hljs-number">200</span>,                <span class="hljs-attr">c</span>: <span class="hljs-number">300</span>,            &#125;,        &#125;;    &#125;,    <span class="hljs-attr">methods</span>: &#123;        <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>)&#123;            <span class="hljs-comment">// this.obj.d = 400 //不是响应式的</span>            <span class="hljs-comment">// Vue.set(this.obj,&#x27;d&#x27;,400)//使用Vue.set()</span>            <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">400</span>)<span class="hljs-comment">//使用vm.$set()</span>        &#125;    &#125;,&#125;);</code></pre></div><h3 id="1-17-3-注意"><a href="#1-17-3-注意" class="headerlink" title="1.17.3 注意"></a>1.17.3 注意</h3><ul><li><p>对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">400</span>) <span class="hljs-comment">//错误</span><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">400</span>) <span class="hljs-comment">//错误</span></code></pre></div></li></ul><h2 id="1-18-数据劫持"><a href="#1-18-数据劫持" class="headerlink" title="1.18 数据劫持"></a>1.18 数据劫持</h2><ul><li><code>vm._data</code> 不等于传入的data，而是经过了处理，这种处理叫做数据劫持</li></ul><h2 id="1-19-过滤器"><a href="#1-19-过滤器" class="headerlink" title="1.19 过滤器"></a>1.19 过滤器</h2><ol><li>定义：自定义过滤器，用于常见的文本格式化。</li><li>语法：<ul><li>注册全局过滤器：<code>Vue.filter(name,callback)</code></li><li>注册局部过滤器：<code>new Vue(filters:&#123; &#125;)</code></li><li>插值中使用过滤器：<code>&#123;&#123; message | capitalize &#125;&#125;</code></li><li>v-bind中使用过滤器：<code>&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</code></li></ul></li><li>注意：<ul><li>过滤器本质上是js函数，可以接受额外参数（默认第一个参数是原本的数据），多个过滤器可以串联</li><li>不会改变原来的数据，产生的是新数据</li></ul></li></ol><div class="code-wrapper"><pre><code class="hljs html">//用计算属性和过滤器实现日期的格式化<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    &#123;&#123;timestamp&#125;&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    &#123;&#123;fmt&#125;&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    &#123;&#123;timestamp | timeFormater&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),        &#125;;    &#125;,    <span class="hljs-attr">filters</span>:&#123;        <span class="hljs-title function_">timeFormater</span>(<span class="hljs-params">timestamp</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-title function_">dayjs</span>(timestamp).<span class="hljs-title function_">format</span>(                <span class="hljs-string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>            );        &#125;    &#125;,    <span class="hljs-attr">computed</span>: &#123;        <span class="hljs-title function_">fmt</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-title function_">dayjs</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timestamp</span>).<span class="hljs-title function_">format</span>(                <span class="hljs-string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>            );        &#125;,    &#125;,&#125;);</code></pre></div><h2 id="1-20-其他内置指令"><a href="#1-20-其他内置指令" class="headerlink" title="1.20 其他内置指令"></a>1.20 其他内置指令</h2><p>之前提到的指令：</p><ul><li><code>v-bind</code>：单向数据绑定，简写：<code>:</code></li><li><code>v-model</code>：双向数据绑定</li><li><code>v-for</code>：遍历数组、对象、字符串</li><li><code>v-on</code>：绑定监听事件，简写：<code>@</code></li><li><code>v-if</code> <code>v-else-if</code> <code>v-else</code>：条件渲染</li><li><code>v-show</code>：条件渲染</li></ul><h3 id="1-20-1-v-text"><a href="#1-20-1-v-text" class="headerlink" title="1.20.1 v-text"></a>1.20.1 v-text</h3><blockquote><ul><li><strong>预期</strong>：<code>string</code></li></ul><ul><li><strong>详细</strong>：</li></ul><p> 更新元素的 <code>textContent</code>。如果要更新部分的 <code>textContent</code>，需要使用 <code>&#123;&#123; Mustache &#125;&#125;</code> 插值。</p><ul><li><strong>示例</strong>：</li></ul> <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-comment">&lt;!-- 和下面的一样 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div></blockquote><ul><li>注意：v-text会替换掉节点中的内容</li></ul><h3 id="1-20-2-v-html"><a href="#1-20-2-v-html" class="headerlink" title="1.20.2 v-html"></a>1.20.2 v-html</h3><blockquote><ul><li><p><strong>预期</strong>：<code>string</code></p></li><li><p><strong>详细</strong>：</p></li></ul><p> 更新元素的 <code>innerHTML</code>。<strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong>。如果试图使用 <code>v-html</code> 组合模板，可以重新考虑是否通过使用组件来替代。</p><ul><li><strong>示例</strong>：</li></ul> <div class="code-wrapper"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> v-html=<span class="hljs-string">&quot;html&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre></div></blockquote><blockquote><ul><li><p>在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</p></li><li><p>在<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>里，<code>scoped</code> 的样式不会应用在 <code>v-html</code> 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 <code>v-html</code> 的内容设置带作用域的 CSS，你可以替换为 <a href="https://vue-loader.vuejs.org/en/features/css-modules.html">CSS Modules</a> 或用一个额外的全局 <code>&lt;style&gt;</code> 元素手动设置类似 BEM 的作用域策略。</p></li></ul></blockquote><h3 id="1-20-3-v-cloak"><a href="#1-20-3-v-cloak" class="headerlink" title="1.20.3 v-cloak"></a>1.20.3 v-cloak</h3><blockquote><ul><li><p><strong>不需要表达式</strong></p></li><li><p><strong>用法</strong>：</p></li></ul><p> 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] &#123; display: none &#125;</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p><ul><li><strong>示例</strong>：</li></ul> <div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span> &#123;  <span class="hljs-attribute">display</span>: none;&#125;</code></pre></div> <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-cloak</span>&gt;</span>  &#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p> 不会显示，直到编译结束。</p></blockquote><h3 id="1-20-4-v-once"><a href="#1-20-4-v-once" class="headerlink" title="1.20.4 v-once"></a>1.20.4 v-once</h3><blockquote><ul><li><p><strong>不需要表达式</strong></p></li><li><p><strong>详细</strong>：</p></li></ul><p> 只渲染元素和组件<strong>一次</strong>。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p> <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 单个元素 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-comment">&lt;!-- 有子元素 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-once</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>comment<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 组件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-once</span> <span class="hljs-attr">:comment</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-comment">&lt;!-- `v-for` 指令--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in list&quot;</span> <span class="hljs-attr">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><ul><li><p><strong>参考</strong>：</p></li><li><p><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E6%8F%92%E5%80%BC">数据绑定语法- 插值</a></p></li><li><p><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E9%80%9A%E8%BF%87-v-once-%E5%88%9B%E5%BB%BA%E4%BD%8E%E5%BC%80%E9%94%80%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%84%E4%BB%B6">组件 - 对低开销的静态组件使用 <code>v-once</code></a></p></li></ul></blockquote><h3 id="1-20-5-v-pre"><a href="#1-20-5-v-pre" class="headerlink" title="1.20.5 v-pre"></a>1.20.5 v-pre</h3><blockquote><ul><li><p><strong>不需要表达式</strong></p></li><li><p><strong>用法</strong>：</p></li></ul><p> 跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p><ul><li><strong>示例</strong>：</li></ul> <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div></blockquote><h2 id="1-21-自定义指令"><a href="#1-21-自定义指令" class="headerlink" title="1.21 自定义指令"></a>1.21 自定义指令</h2><p>注册局部自定义指令：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>需求1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前的n值是: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>放大10倍后的n值是: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-big</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>点击n+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>需求2<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-fbind:value</span>=<span class="hljs-string">&quot;n&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">n</span>: <span class="hljs-number">1</span>,            <span class="hljs-attr">input</span>: <span class="hljs-string">&quot;&quot;</span>,        &#125;;    &#125;,    <span class="hljs-attr">directives</span>: &#123;        <span class="hljs-comment">//什么时候调用？</span>        <span class="hljs-comment">//1. 指令和元素成功绑定时</span>        <span class="hljs-comment">//2. 指令所在的模板被重新解析时调用</span>        <span class="hljs-title function_">big</span>(<span class="hljs-params">element, binding</span>) &#123;            element.<span class="hljs-property">innerText</span> = binding.<span class="hljs-property">value</span> * <span class="hljs-number">10</span>;        &#125;,                <span class="hljs-attr">fbind</span>:&#123;            <span class="hljs-comment">//指令和元素成功绑定时</span>            <span class="hljs-comment">//注意：此处的this是window</span>            <span class="hljs-title function_">bind</span>(<span class="hljs-params">el,binding</span>)&#123;                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)                el.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span>            &#125;,            <span class="hljs-comment">//指令所在的元素被插入页面时</span>            <span class="hljs-title function_">inserted</span>(<span class="hljs-params">el,binding</span>)&#123;                el.<span class="hljs-title function_">focus</span>()            &#125;,            <span class="hljs-comment">//指令所在得到模板被重新解析时</span>            <span class="hljs-title function_">update</span>(<span class="hljs-params">el,binding</span>)&#123;                <span class="hljs-comment">// console.log(&#x27;update&#x27;)</span>                <span class="hljs-comment">// console.log(&#x27;&#x27;)</span>                el.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span>            &#125;        &#125;    &#125;,&#125;);</code></pre></div><p>注册全局自定义指令：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;  <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span>  <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;    <span class="hljs-comment">// 聚焦元素</span>    el.<span class="hljs-title function_">focus</span>()  &#125;&#125;)</code></pre></div><h2 id="1-22-生命周期"><a href="#1-22-生命周期" class="headerlink" title="1.22 生命周期"></a>1.22 生命周期</h2><p><img src="https://cn.vuejs.org/images/lifecycle.png"></p><p>挂载流程：</p><ul><li><p><code>init events &amp; lifecycle</code>。初始化：生命周期、时间，但是数据代理还未开始。</p></li><li><p><code>beforeCreate</code>。此时：无法通过vm访问到data中的数据和methods中的方法。</p></li><li><p><code>init injections &amp; reactivity</code>。初始化：数据监测、数据代理。</p></li><li><p><code>created</code>。此时：可以通过vm访问到data中的数据和methods中的方法。</p></li><li><p>Vue开始解析模板，生成虚拟DOM，页面还不能显示解析好的内容。</p></li><li><p><code>beforeMount</code>。此时：页面呈现的是未经Vue编译的DOM。此时对DOM的操作最终都不奏效。</p></li><li><p>将内存中的虚拟DOM转为真实DOM插入页面中。</p></li><li><p><code>mounted</code>。此时：页面中呈现的是经过Vue编译的DOM。此时对DOM的操作均有效但应该尽可避免。至此，初始化过程结束。一般在此时进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等初始化操作。</p></li></ul><p>更新流程：</p><ul><li><p><code>beforeUpdate</code>。此时：数据是新的，但是页面还是旧的。即：页面尚未和数据保持同步。</p></li><li><p>根据新数据形成新的虚拟DOM，随后和旧的虚拟DOM进行比较，最终完成页面的更新，即完成了Model-&gt;View的更新。</p></li><li><p><code>updated</code>。此时：数据是最新的，页面也是新的，即：页面和数据保持同步。</p></li></ul><p>销毁流程：</p><ul><li><code>beforeDestroy</code>。此时：vm中data、method等都处于可用状态，马上执行销毁流程。一般在此关闭定时器、取消订阅消息、解绑自定义事件等等收尾操作。此时对数据进行操作不会触发更新DOM</li><li><code>destroyed</code>。</li></ul><h1 id="第二章-Vue组件化编程"><a href="#第二章-Vue组件化编程" class="headerlink" title="第二章 Vue组件化编程"></a>第二章 Vue组件化编程</h1><h2 id="2-1-非单文件组件"><a href="#2-1-非单文件组件" class="headerlink" title="2.1 非单文件组件"></a>2.1 非单文件组件</h2><h3 id="2-1-1-案例"><a href="#2-1-1-案例" class="headerlink" title="2.1.1 案例"></a>2.1.1 案例</h3><ol><li>局部注册：</li></ol><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> school =  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><span class="hljs-string">                &lt;div&gt;</span><span class="hljs-string">                    &lt;h1&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h1&gt;</span><span class="hljs-string">                    &lt;h1&gt;学校地址：&#123;&#123;schoolAddr&#125;&#125;&lt;/h1&gt;</span><span class="hljs-string">                &lt;/div&gt;</span><span class="hljs-string">                `</span>,    <span class="hljs-comment">//不用写el配置项，因为最终所有的组件都会被一个vm管理，由vm决定服务于哪个容器</span>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">schoolName</span>: <span class="hljs-string">&quot;buct&quot;</span>,            <span class="hljs-attr">schoolAddr</span>: <span class="hljs-string">&quot;北三环&quot;</span>,        &#125;;    &#125;,&#125;);<span class="hljs-keyword">const</span> student =  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><span class="hljs-string">                &lt;div&gt;</span><span class="hljs-string">                    &lt;h1&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h1&gt;</span><span class="hljs-string">                    &lt;h1&gt;学生年龄：&#123;&#123;studentAge&#125;&#125;&lt;/h1&gt;</span><span class="hljs-string">                &lt;/div&gt;</span><span class="hljs-string">                `</span>,    <span class="hljs-comment">//不用写el配置项，因为最终所有的组件都会被一个vm管理，由vm决定服务于哪个容器</span>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">studentName</span>: <span class="hljs-string">&quot;tourry&quot;</span>,            <span class="hljs-attr">studentAge</span>: <span class="hljs-string">&quot;18&quot;</span>,        &#125;;    &#125;,&#125;);<span class="hljs-keyword">const</span> vm  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,    <span class="hljs-attr">components</span>:&#123;        <span class="hljs-comment">//注册组件 局部注册</span>        school,        student    &#125;&#125;)</code></pre></div><ol start="2"><li>全局注册：</li></ol><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app2&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hello = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;    <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;hello vue&#x27;</span>        &#125;    &#125;&#125;)<span class="hljs-comment">//全局注册组件，两个vm中都带有hello组件</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,hello)<span class="hljs-keyword">const</span> vm1  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app1&#x27;</span>,&#125;)<span class="hljs-keyword">const</span> vm2  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app2&#x27;</span>,&#125;)</code></pre></div><h3 id="2-1-2-几个注意点"><a href="#2-1-2-几个注意点" class="headerlink" title="2.1.2 几个注意点"></a>2.1.2 几个注意点</h3><ul><li><p>关于组件的名字：</p><ol><li>一个单词组成：（在开发者工具中组件名都是首字母大写，可以在开发者工具种修改模式）<ul><li>第一种写法：（首字母小写）school</li><li>第二种写法：（首字母大写）School</li></ul></li><li>多个单词组成：<ul><li>第一种写法：（Kebab-case）my-school</li><li>第二种写法：（CamelCase）MySchool（需要脚手架，不然报错）</li></ul></li><li>备注<ul><li>组件名应该尽可能回避HTML中已有元素的名称，比如h2、H2</li><li>可以使用name配置项指定组件在<strong>开发者工具</strong>中呈现的名字</li></ul></li></ol></li><li><p>关于组件标签：</p><ol><li>第一种写法：<code>&lt;school&gt;&lt;/school&gt;</code></li><li>第二种写法：<code>&lt;school/&gt;</code></li><li>注意：不使用脚手架时，第二种写法会导致后续的组件无法渲染</li></ol></li><li><p>定义组件的简写形式：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//不使用简写:</span><span class="hljs-keyword">const</span> school = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(options)<span class="hljs-comment">//使用简写:</span><span class="hljs-keyword">const</span> school = options</code></pre></div></li></ul><h3 id="2-1-3-组件的嵌套"><a href="#2-1-3-组件的嵌套" class="headerlink" title="2.1.3 组件的嵌套"></a>2.1.3 组件的嵌套</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//定义子组件</span><span class="hljs-keyword">const</span> student = &#123;    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><span class="hljs-string">                &lt;div&gt;</span><span class="hljs-string">                    &lt;h1&gt;学生名字：&#123;&#123;studentName&#125;&#125;&lt;/h1&gt;</span><span class="hljs-string">                    &lt;h1&gt;学生年龄：&#123;&#123;studentAge&#125;&#125;&lt;/h1&gt;</span><span class="hljs-string">                &lt;/div&gt;</span><span class="hljs-string">                `</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">studentName</span>: <span class="hljs-string">&quot;tourry&quot;</span>,            <span class="hljs-attr">studentAge</span>: <span class="hljs-number">18</span>,        &#125;;    &#125;,&#125;;<span class="hljs-comment">//定义父组件</span><span class="hljs-keyword">const</span> school = &#123;    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><span class="hljs-string">                &lt;div&gt;</span><span class="hljs-string">                    &lt;h1&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h1&gt;</span><span class="hljs-string">                    &lt;h1&gt;学校地址：&#123;&#123;schoolAddr&#125;&#125;&lt;/h1&gt;</span><span class="hljs-string">                    &lt;student&gt;&lt;/student&gt;</span><span class="hljs-string">                &lt;/div&gt;</span><span class="hljs-string">                `</span>,    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-attr">schoolName</span>: <span class="hljs-string">&quot;buct&quot;</span>,            <span class="hljs-attr">schoolAddr</span>: <span class="hljs-string">&quot;北三环&quot;</span>,        &#125;;    &#125;,    <span class="hljs-attr">components</span>:&#123;        student    &#125;&#125;;<span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,    <span class="hljs-attr">components</span>: &#123;        school    &#125;,&#125;);</code></pre></div><h2 id="2-2-VueComponent"><a href="#2-2-VueComponent" class="headerlink" title="2.2 VueComponent"></a>2.2 VueComponent</h2><ol><li><p>组件的本质是一个名为VueComponent()的构造函数，是Vue.extend</p><p>生成的。</p></li><li><p>Vue会帮助我们执行 new VueComponent(options)</p></li><li><p>每次调用Vue.extend()，得到的都是一个全新的VueComponent()</p></li><li><p>this指向：</p><ul><li>组件配置中，data()、methods中的函数、watch中的函数、computed中的函数，它们的this均是VueComponent实例对象</li><li>new Vue(options)配置中，data()、methods中的函数、watch中的函数、computed中的函数，它们的this均是Vue实例对象</li></ul></li><li><p>&#96;&#96;&#96;js<br>VueComponent.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Vue.prototype</p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"></span><span class="language-xml">## 2.3 单文件组件</span><span class="language-xml"></span><span class="language-xml">```vue</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Student&quot;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;tourry&quot;</span>,</span></span><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">&#125;;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.name</span> &#123;</span></span><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">background</span>: rebeccapurple;</span></span><span class="language-css"><span class="language-xml">&#125;</span></span><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre></div></li></ol><h1 id="第三章-Vue-高级"><a href="#第三章-Vue-高级" class="headerlink" title="第三章 Vue 高级"></a>第三章 Vue 高级</h1><h2 id="3-1-脚手架创建Vue项目"><a href="#3-1-脚手架创建Vue项目" class="headerlink" title="3.1 脚手架创建Vue项目"></a>3.1 脚手架创建Vue项目</h2><div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 全局安装Vue-clinpm install -g @vue/cli-service-global<span class="hljs-bullet">2.</span> 创建Vue项目vue create vue-project<span class="hljs-bullet">3.</span> 根据提示定制即可</code></pre></div><h2 id="3-2-特殊标签：ref"><a href="#3-2-特殊标签：ref" class="headerlink" title="3.2 特殊标签：ref"></a>3.2 特殊标签：ref</h2><blockquote><ul><li><strong>预期</strong>：<code>string</code></li></ul><p> <code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p> <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span></code></pre></div><p> 当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p><p> 关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p></blockquote><h2 id="3-3-Prop"><a href="#3-3-Prop" class="headerlink" title="3.3 Prop"></a>3.3 Prop</h2><blockquote><ul><li><p><strong>类型</strong>：<code>Array&lt;string&gt; | Object</code></p></li><li><p><strong>详细</strong>：</p></li></ul><p> props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p><p> 你可以基于对象的语法使用以下选项：</p><ul><li><code>type</code>：可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%B1%BB%E5%9E%8B">更多信息在此</a>。</li><li><code>default</code>：<code>any</code><br>为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。</li><li><code>required</code>：<code>Boolean</code><br>定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。</li><li><code>validator</code>：<code>Function</code><br>自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81">这里</a>查阅更多 prop 验证的相关信息。</li></ul></blockquote><h3 id="3-3-1-利用prop传递函数实现子组件给父组件传递消息"><a href="#3-3-1-利用prop传递函数实现子组件给父组件传递消息" class="headerlink" title="3.3.1 利用prop传递函数实现子组件给父组件传递消息"></a>3.3.1 利用prop传递函数实现子组件给父组件传递消息</h3><p>步骤：</p><ol><li>在父组件中定义函数</li><li>在子组件中使用props接收父组件定义的函数</li></ol><p>举例：</p><p>父组件：App.vue </p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;name:&#123;&#123; name &#125;&#125;&lt;/h1&gt;    &lt;School :getName=&quot;getName&quot;&gt;&lt;/School&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import School from &quot;./components/School&quot;;export default &#123;  name: &quot;App&quot;,  components: &#123;School&#125;,  data() &#123;    return &#123;      name: &#x27;&#x27;    &#125;  &#125;,  methods: &#123;    getName(name) &#123;      console.log(&#x27;父组件接受子组件传递的数据&#x27;, name)      this.name = name    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><p>子组件：School.vue</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;hello,&#123;&#123; school.name &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;hello,&#123;&#123; school.addr &#125;&#125;&lt;/h1&gt;    &lt;button @click=&quot;handleClick&quot;&gt;点击给父组件传递name&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;School&quot;,  props: [&#x27;getName&#x27;],  data() &#123;    return &#123;      school: &#123;        name: &#x27;BUCT&#x27;,        addr: &#x27;Beijing&#x27;      &#125;    &#125;  &#125;,  methods: &#123;    handleClick() &#123;      this.getName(this.school.name)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><h2 id="3-4-混入：mixin"><a href="#3-4-混入：mixin" class="headerlink" title="3.4 混入：mixin"></a>3.4 混入：mixin</h2><blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a><a href="https://cn.vuejs.org/v2/guide/mixins.html#%E5%9F%BA%E7%A1%80">基础</a></h2><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的<strong>可复用功能</strong>。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被 “混合” 进入该组件本身的选项。</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-comment">// 定义一个混入对象</span>&gt;<span class="hljs-keyword">var</span> myMixin = &#123; <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hello</span>() &#125;, <span class="hljs-attr">methods</span>: &#123;   <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello from mixin!&#x27;</span>)   &#125; &#125;&gt;&#125;&gt;<span class="hljs-comment">// 定义一个使用混入对象的组件</span>&gt;<span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123; <span class="hljs-attr">mixins</span>: [myMixin]&gt;&#125;)&gt;<span class="hljs-keyword">var</span> component = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>() <span class="hljs-comment">// =&gt; &quot;hello from mixin!&quot;</span></code></pre></div><h2 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a><a href="https://cn.vuejs.org/v2/guide/mixins.html#%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6">选项合并</a></h2><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行 “合并”。</p><p>比如，数据对象在内部会进行递归合并，并在发生冲突时以<strong>组件数据优先</strong>。</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-keyword">var</span> mixin = &#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">return</span> &#123;     <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,     <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;abc&#x27;</span>   &#125; &#125;&gt;&#125;&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <span class="hljs-attr">mixins</span>: [mixin], <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">return</span> &#123;     <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;goodbye&#x27;</span>,     <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;def&#x27;</span>   &#125; &#125;, <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>)   <span class="hljs-comment">// =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;</span> &#125;&gt;&#125;)</code></pre></div><p>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-keyword">var</span> mixin = &#123; <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;混入对象的钩子被调用&#x27;</span>) &#125;&gt;&#125;&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <span class="hljs-attr">mixins</span>: [mixin], <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件钩子被调用&#x27;</span>) &#125;&gt;&#125;)&gt;<span class="hljs-comment">// =&gt; &quot;混入对象的钩子被调用&quot;</span>&gt;<span class="hljs-comment">// =&gt; &quot;组件钩子被调用&quot;</span></code></pre></div><p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，<strong>取组件对象的键值对</strong>。</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-keyword">var</span> mixin = &#123; <span class="hljs-attr">methods</span>: &#123;   <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)   &#125;,   <span class="hljs-attr">conflicting</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;from mixin&#x27;</span>)   &#125; &#125;&gt;&#125;&gt;<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <span class="hljs-attr">mixins</span>: [mixin], <span class="hljs-attr">methods</span>: &#123;   <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)   &#125;,   <span class="hljs-attr">conflicting</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;from self&#x27;</span>)   &#125; &#125;&gt;&#125;)&gt;vm.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// =&gt; &quot;foo&quot;</span>&gt;vm.<span class="hljs-title function_">bar</span>() <span class="hljs-comment">// =&gt; &quot;bar&quot;</span>&gt;vm.<span class="hljs-title function_">conflicting</span>() <span class="hljs-comment">// =&gt; &quot;from self&quot;</span></code></pre></div><p>注意：<code>Vue.extend()</code> 也使用同样的策略进行合并。</p><h2 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a><a href="https://cn.vuejs.org/v2/guide/mixins.html#%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5">全局混入</a></h2><p>混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响<strong>每一个</strong>之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-comment">// 为自定义的选项 &#x27;myOption&#x27; 注入一个处理器。</span>&gt;<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123; <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">var</span> myOption = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">myOption</span>   <span class="hljs-keyword">if</span> (myOption) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myOption)   &#125; &#125;&gt;&#125;)&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <span class="hljs-attr">myOption</span>: <span class="hljs-string">&#x27;hello!&#x27;</span>&gt;&#125;)&gt;<span class="hljs-comment">// =&gt; &quot;hello!&quot;</span></code></pre></div><p>请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为<a href="https://cn.vuejs.org/v2/guide/plugins.html">插件</a>发布，以避免重复应用混入。</p></blockquote><h2 id="3-5-插件"><a href="#3-5-插件" class="headerlink" title="3.5 插件"></a>3.5 插件</h2><blockquote><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制 —— 一般有下面几种：</p><ol><li>添加全局方法或者 property。如：<a href="https://github.com/karol-f/vue-custom-element">vue-custom-element</a></li><li>添加全局资源：指令 &#x2F; 过滤器 &#x2F; 过渡等。如 <a href="https://github.com/vuejs/vue-touch">vue-touch</a></li><li>通过全局混入来添加一些组件选项。如 <a href="https://github.com/vuejs/vue-router">vue-router</a></li><li>添加 Vue 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li><li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 <a href="https://github.com/vuejs/vue-router">vue-router</a></li></ol><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a><a href="https://cn.vuejs.org/v2/guide/plugins.html#%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6">使用插件</a></h2><p>通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code> 启动应用之前完成：</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-comment">// 调用 `MyPlugin.install(Vue)`</span>&gt;<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">MyPlugin</span>)&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <span class="hljs-comment">// ...组件选项</span>&gt;&#125;)</code></pre></div><p>也可以传入一个可选的选项对象：</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">MyPlugin</span>, &#123; <span class="hljs-attr">someOption</span>: <span class="hljs-literal">true</span> &#125;)</code></pre></div><p><code>Vue.use</code> 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。</p><p>Vue.js 官方提供的一些插件 (例如 <code>vue-router</code>) 在检测到 <code>Vue</code> 是可访问的全局变量时会自动调用 <code>Vue.use()</code>。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 <code>Vue.use()</code>：</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-comment">// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时</span>&gt;<span class="hljs-keyword">var</span> <span class="hljs-title class_">Vue</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue&#x27;</span>)&gt;<span class="hljs-keyword">var</span> <span class="hljs-title class_">VueRouter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-router&#x27;</span>)&gt;<span class="hljs-comment">// 不要忘了调用此方法</span>&gt;<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)</code></pre></div><p><a href="https://github.com/vuejs/awesome-vue#components--libraries">awesome-vue</a> 集合了大量由社区贡献的插件和库。</p><h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a><a href="https://cn.vuejs.org/v2/guide/plugins.html#%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6">开发插件</a></h2><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p><div class="code-wrapper"><pre><code class="hljs js">&gt;<span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) &#123; <span class="hljs-comment">// 1. 添加全局方法或 property</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-property">myGlobalMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 逻辑...</span> &#125; <span class="hljs-comment">// 2. 添加全局资源</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;my-directive&#x27;</span>, &#123;   bind (el, binding, vnode, oldVnode) &#123;     <span class="hljs-comment">// 逻辑...</span>   &#125;   ... &#125;) <span class="hljs-comment">// 3. 注入组件选项</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;   <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;     <span class="hljs-comment">// 逻辑...</span>   &#125;   ... &#125;) <span class="hljs-comment">// 4. 添加实例方法</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">methodOptions</span>) &#123;   <span class="hljs-comment">// 逻辑...</span> &#125;&gt;&#125;</code></pre></div></blockquote><h2 id="3-6-局部样式：scoped"><a href="#3-6-局部样式：scoped" class="headerlink" title="3.6 局部样式：scoped"></a>3.6 局部样式：scoped</h2><div class="code-wrapper"><pre><code class="hljs vue">&lt;style scoped&gt;h1 &#123;  color: red;&#125;&lt;/style&gt;</code></pre></div><h2 id="3-7-浏览器本地存储WebStorage"><a href="#3-7-浏览器本地存储WebStorage" class="headerlink" title="3.7 浏览器本地存储WebStorage"></a>3.7 浏览器本地存储WebStorage</h2><ol><li>存储大小一般在5M左右。</li><li>通过 <code>windows.localStorage</code> 和 <code>windows.sessionStorage</code> 实现本地存储。浏览器窗口关闭后 localStorage 内容不会消失，sessionStorage 内容会消失。</li><li>API<ol><li><code>xxxStorage.setItem(&#39;key&#39;,&#39;value&#39;)</code>添加 kv</li><li><code>xxxStorage.getItem(&#39;key&#39;)</code>根据 k 获取 v</li><li><code>xxxStorage.removeItem(&#39;key&#39;)</code>删除 kv</li><li><code>xxxStorage.clear</code>清空所有 kv</li></ol></li><li>注意：如果<code>xxxStorage.getItem(&#39;key&#39;)</code>获取不到对应的 value ，会返回 null</li></ol><h2 id="3-8-组件自定义事件"><a href="#3-8-组件自定义事件" class="headerlink" title="3.8 组件自定义事件"></a>3.8 组件自定义事件</h2><p>这是一种组件间通信的方式，适用于子组件给父组件传递消息。在父组件中给子组件绑定自定义事件，并且在子组件中触发该自定义事件。</p><h3 id="3-8-1-使用-或-v-on-绑定事件"><a href="#3-8-1-使用-或-v-on-绑定事件" class="headerlink" title="3.8.1 使用 @ 或 v-on 绑定事件"></a>3.8.1 使用 <code>@</code> 或 <code>v-on</code> 绑定事件</h3><p>举例：</p><p>在父组件 App 中：使用<code>@</code>绑定自定义事件</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;h1&gt;name:&#123;&#123; name &#125;&#125;&lt;/h1&gt;    &lt;Student @get-student-name=&quot;getStudentName&quot;&gt;&lt;/Student&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &quot;./components/Student&quot;;export default &#123;  name: &quot;App&quot;,  components: &#123;Student&#125;,  data() &#123;    return &#123;      name: &#x27;&#x27;    &#125;  &#125;,  methods: &#123;    getStudentName(name) &#123;      console.log(&#x27;app收到了学生名&#x27;, name)      this.name = name    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><p>在子组件 Student 中：使用 <code>$emit</code> 触发自定义事件</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;    &lt;h1&gt;hello,&#123;&#123; name &#125;&#125;&lt;/h1&gt;    &lt;button @click=&quot;sendStudentName&quot;&gt;button&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Student&quot;,  data() &#123;    return &#123;      name: &#x27;Tourry&#x27;    &#125;  &#125;,  methods: &#123;    sendStudentName()&#123;      // 触发Student实例身上的get-student-name事件      this.$emit(&#x27;get-student-name&#x27;,this.name)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><h3 id="3-8-2-使用-ref-绑定事件"><a href="#3-8-2-使用-ref-绑定事件" class="headerlink" title="3.8.2 使用 ref 绑定事件"></a>3.8.2 使用 <code>ref</code> 绑定事件</h3><p>在组件加载完毕时绑定自定义事件，灵活性更强 。举例：</p><p>在父组件 App 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;h1&gt;name:&#123;&#123; name &#125;&#125;&lt;/h1&gt;    &lt;Student ref=&quot;student&quot;&gt;&lt;/Student&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &quot;./components/Student&quot;;export default &#123;  name: &quot;App&quot;,  components: &#123;Student&#125;,  data() &#123;    return &#123;      name: &#x27;&#x27;    &#125;  &#125;,  mounted() &#123;    this.$refs.student.$on(&#x27;get-student-name&#x27;, this.getStudentName)  &#125;&#125;&lt;/script&gt;</code></pre></div><p><strong>注意</strong>：通过 <code>this.$refs.student.$on(&#39;get-student-name&#39;, 回调)</code> 这种方式绑定自定义事件时，回调函数要么配置在 methods 中，要么使用箭头函数。因为 this 指向被绑定自定义事件的组件实例对象。</p><p>子组件 Student 同 3.8.1 节</p><h3 id="3-8-3-解绑事件"><a href="#3-8-3-解绑事件" class="headerlink" title="3.8.3 解绑事件"></a>3.8.3 解绑事件</h3><p>使用 <code>$off</code> 解绑事件。例，在子组件 Student 实例对象上中：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$off(<span class="hljs-string">&#x27;get-student-name&#x27;</span>) <span class="hljs-comment">//解绑单自定义事件</span><span class="hljs-variable language_">this</span>.$off([<span class="hljs-string">&#x27;get-student-name&#x27;</span>,<span class="hljs-string">&#x27;demo2&#x27;</span>]) <span class="hljs-comment">//解绑多个自定义事件</span><span class="hljs-variable language_">this</span>.$off()<span class="hljs-comment">//解绑所有自定义事件</span></code></pre></div><h3 id="3-8-4-使用原生事件"><a href="#3-8-4-使用原生事件" class="headerlink" title="3.8.4 使用原生事件"></a>3.8.4 使用原生事件</h3><p>组件上绑定的事件默认都是自定义事件，即使该事件的名称与原生事件名称相同，例如：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;Student ref=&quot;student&quot; @click=&quot;test&quot;&gt;&lt;/Student&gt;</code></pre></div><p>在 Student 的DOM元素上点击不会触发 ckick 事件。如果想用原生的 click 事件，需要在click 后加上修饰符 native。例如：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;Student ref=&quot;student&quot; @click.native=&quot;test&quot;&gt;&lt;/Student&gt;</code></pre></div><h2 id="3-9-全局事件总线"><a href="#3-9-全局事件总线" class="headerlink" title="3.9 全局事件总线"></a>3.9 全局事件总线</h2><p>思路：在 vm 上绑定一个 对象，所有的 vc 实例对象都能看得见这个对象并且可以调用<code>$on()</code>、 <code>$off()</code> 、<code>$emit()</code> 方法。</p><p>例子：Student 将数据 name 传递给兄弟组件 School</p><p>main.js 中：绑定 <code>$bus</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 安装全局事件总线</span>        <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span>    &#125;&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><p>School 组件中：在 <code>$bus</code> 上定义自定义事件</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;School:&#123;&#123; name &#125;&#125;&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;School&quot;,  mounted() &#123;    this.$bus.$on(&#x27;demo&#x27;, (data) =&gt; &#123;      console.log(&#x27;收到数据&#x27;, data)      this.name = data    &#125;)  &#125;,  data() &#123;    return &#123;      name: &#x27;&#x27;,    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><p>Student 组件中：触发 <code>$bus</code> 上的自定义事件，数据以参数的形式传递给了 School 组件</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Student:&#123;&#123; name &#125;&#125;&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Student&quot;,  mounted() &#123;    this.$bus.$emit(&#x27;demo&#x27;, this.name)  &#125;,  data() &#123;    return &#123;      name: &#x27;Tourry&#x27;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div><h2 id="3-10-消息订阅与发布"><a href="#3-10-消息订阅与发布" class="headerlink" title="3.10 消息订阅与发布"></a>3.10 消息订阅与发布</h2><p>思路：需要数据的组件进行消息订阅，传递数据的组件进行消息发布。</p><p>js库<a href="https://github.com/mroderick/PubSubJS">https://github.com/mroderick/PubSubJS</a></p><h2 id="3-11-nextTick"><a href="#3-11-nextTick" class="headerlink" title="3.11 nextTick()"></a>3.11 nextTick()</h2><blockquote><h3 id="Vue-nextTick-callback-context"><a href="#Vue-nextTick-callback-context" class="headerlink" title="[Vue.nextTick( callback, context] )"></a>[Vue.nextTick( <a href="https://cn.vuejs.org/v2/api/#Vue-nextTick">callback, context] )</a></h3><ul><li><p><strong>参数</strong>：</p></li><li><p><code>&#123;Function&#125; [callback]</code></p></li><li><p><code>&#123;Object&#125; [context]</code></p></li><li><p><strong>用法</strong>：</p></li></ul><p> 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p> <div class="code-wrapper"><pre><code class="hljs vue">// 修改数据vm.msg = &#x27;Hello&#x27;// DOM 还没有更新Vue.nextTick(function () &#123;  // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick()  .then(function () &#123;    // DOM 更新了  &#125;)</code></pre></div><blockquote><p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p></blockquote></blockquote><h2 id="3-12-过度与动画"><a href="#3-12-过度与动画" class="headerlink" title="3.12 过度与动画"></a>3.12 过度与动画</h2><p>js库<a href="https://github.com/animate-css/animate.css">https://github.com/animate-css/animate.css</a></p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示与隐藏&lt;/button&gt;    &lt;transition        name=&quot;animate__animated animate__bounce&quot;        appear        enter-active-class=&quot;animate__swing&quot;        leave-active-class=&quot;animate__backOutDown&quot;    &gt;      &lt;h1 v-show=&quot;isShow&quot;&gt;hello&lt;/h1&gt;    &lt;/transition&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#x27;animate.css&#x27;export default &#123;  name: &quot;School&quot;,  data() &#123;    return &#123;      isShow: false    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1 &#123;  background-color: #42b983;&#125;&lt;/style&gt;</code></pre></div><h2 id="3-12-配置代理"><a href="#3-12-配置代理" class="headerlink" title="3.12 配置代理"></a>3.12 配置代理</h2><h3 id="3-12-1-跨域"><a href="#3-12-1-跨域" class="headerlink" title="3.12.1 跨域"></a>3.12.1 跨域</h3><ol><li>浏览器同源策略：浏览器只能请求相同协议、主机名、端口号的地址。不满足这三个条件即跨域。</li><li>解决方案：<ul><li>cors：后端加特殊的请求头</li><li>jsonp</li><li>proxy</li></ul></li></ol><h3 id="3-12-2-配置代理"><a href="#3-12-2-配置代理" class="headerlink" title="3.12.2 配置代理"></a>3.12.2 配置代理</h3><p>在vue.config.js中配置devServer.proxy。</p><ol><li><p>第一种配置方式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<span class="hljs-attr">proxy</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>&#125;</code></pre></div><p>两个缺点：1. 只能配置一台代理服务器 2. 不能控制哪些接口转发</p></li><li><p>第二种配置方式（推荐）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">proxy</span>: &#123;    <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,        <span class="hljs-attr">pathRewrite</span>: &#123;            <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>        &#125;,        <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>    &#125;,    <span class="hljs-string">&#x27;/foo&#x27;</span>: &#123;        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>    &#125;&#125;</code></pre></div><p><code>/api</code>是请求的前缀，配置<code>pathRewrite</code>，使得发送到后端的请求中不再有<code>/api</code></p></li></ol><h2 id="3-12-插槽"><a href="#3-12-插槽" class="headerlink" title="3.12 插槽"></a>3.12 插槽</h2><p>作用：让父组件可以向子组件指定的位置插入 html 结构，也是一种组件间通信的方法，适用于父组件向子组件传递消息。</p><h3 id="3-12-1-默认插槽"><a href="#3-12-1-默认插槽" class="headerlink" title="3.12.1 默认插槽"></a>3.12.1 默认插槽</h3><ol><li><p>子组件 Child 中定义一个插槽，插槽在定义时可以放入默认内容，如果插槽没有被使用，则显示默认内容。</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;slot&gt;这是默认插槽内容&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></div></li><li><p>父组件 App 中使用子组件的插槽，向子组件的插槽中放入内容</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;Child&gt;      &lt;h1&gt;向子组件的插槽中放入这段文字&lt;/h1&gt;    &lt;/Child&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></div></li></ol><h3 id="3-12-2-具名插槽"><a href="#3-12-2-具名插槽" class="headerlink" title="3.12.2 具名插槽"></a>3.12.2 具名插槽</h3><ol><li><p>子组件 Child 在定义多个插槽时可以为插槽起名。</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;slot name=&quot;first&quot;&gt;first插槽的默认内容&lt;/slot&gt;    &lt;slot name=&quot;last&quot;&gt;last插槽的默认内容&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></div></li><li><p>父组件 App 将指定的内容放入指定的具名插槽</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;Child&gt;              &lt;template v-slot:first&gt;          向子组件的first插槽中放入这段文字  &lt;/template&gt;      &lt;template #last&gt;向子组件的last插槽中放入这段文字  &lt;/template&gt;    &lt;/Child&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></div></li><li><p>注意：</p><ul><li><p>只有<code>&lt;template&gt;</code>标签才可以使用具名插槽</p></li><li><p><code>v-slot:first</code>可以简写成<code>#first</code></p></li><li><p>不带<code>name</code>属性的插槽会带有隐含的名字<code>default</code></p></li></ul></li></ol><h3 id="3-12-3-作用域插槽"><a href="#3-12-3-作用域插槽" class="headerlink" title="3.12.3 作用域插槽"></a>3.12.3 作用域插槽</h3><p>数据放在子组件中，把数据传递给父组件。</p><ol><li><p>在子组件 Child 中，存有数据 msg，并想把这个数据交给父组件使用</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;slot :msg=&quot;msg&quot;&gt;first插槽的默认内容&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child&quot;,  data() &#123;    return &#123;      msg: &#x27;hello vue&#x27;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></div></li><li><p>在父组件 App 中：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;Child&gt;       // hello vue      &lt;template v-slot:default=&quot;&#123;msg&#125;&quot;&gt;        通过插槽收到子组件传递过来的数据：&#123;&#123;msg&#125;&#125;      &lt;/template&gt;    &lt;/Child&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript】JavaScript高级笔记</title>
    <link href="/archives/c2a65dc0.html"/>
    <url>/archives/c2a65dc0.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-基础总结深入"><a href="#第一章-基础总结深入" class="headerlink" title="第一章 基础总结深入"></a>第一章 基础总结深入</h1><h2 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h2><h3 id="1-1-1-分类"><a href="#1-1-1-分类" class="headerlink" title="1.1.1 分类"></a>1.1.1 分类</h3><p>简单数据类型–6种</p><ol><li><p>String：任意的字符串</p><ul><li><p>可以以双引号、单引号或者反引号开头，没有任何区别，但是必须开头和结尾的符号必须一直</p></li><li><p>toString()方法，返回当前值的字符串等价物。toString()可以接受一个底数参数，默认10进制。null和undefined没有toString()方法。如果不确定一个值是不是null或undefined，可以使用String()转型函数。String()函数规则如下：</p><ol><li>如果值有toString()方法，则调用toString()方法</li><li>如果值是null，则返回’null’；如果值是undefined，则返回’undefined’</li></ol></li><li><p>用加号操作符给值加上一个字符串’’，也可以将其转换为字符串。</p></li><li><p>用反引号表示模板字面量，会保留反引号内部的回车换行。模板字面量不是字符串，会在定义时自动求值转换成字符串。插值表达式<code>$&#123;&#125;</code>内部的变量会调用toString()方法强制转换成字符串。插值表达式中可以调用函数和方法。</p></li></ul></li><li><p>Number：任意的数字</p><ul><li><p>8进制：0开头，后面接上8进制数字（0-7）。如果0开头后面的数字中有不是8进制的数（8或9），会忽略前缀的0，后面的数值当作10进制数。严格模式下用0x开头</p></li><li><p>16进制：0x开头，后面跟上16进制的数字或字母（大小写均可）</p></li><li><p>使用8进制和16进制创建的数值再所有数学操作中都被视为10进制。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">067</span> + <span class="hljs-number">0xA</span>)  <span class="hljs-comment">//(55+10)  65</span></code></pre></div></li><li><p>NaN不等于包括自己在内的任何值。isNaN()函数接收一个参数。可以是任意数据类型，然后判断这个参数是否不是数值。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span>,<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>))   <span class="hljs-comment">//NaN true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1111</span>,<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">1111</span>))<span class="hljs-comment">//1111 false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1111&#x27;</span>,<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;11111&#x27;</span>))<span class="hljs-comment">//1111 false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;111a&#x27;</span>,<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;111a&#x27;</span>))<span class="hljs-comment">//111a true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>,<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>))<span class="hljs-comment">//aaa true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span>,<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>))<span class="hljs-comment">//true false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span>,<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">false</span>))<span class="hljs-comment">//false false</span></code></pre></div><p>isNaN也可以测试对象，先调用对象的valueOf()方法，然后再确定返回值是否可以转换为数值。如果不能再调用toString()方法，并测试返回值。</p></li><li><p>浮点数都是双精度。如果可以用整数表示，那么就用整数来存储</p></li><li><p>Number()转型函数，转换规则如下：</p><ol><li>Boolean：true转换成1，false转换成0</li><li>Number：直接返回</li><li>Null：null转换成0</li><li>Undefined：undefined转换成NaN</li><li>String：<ul><li>如果字符串包含数值字符，包括前面带正负的情况，转化成一个10进制的值。忽略前缀的0。可以是整数或者时浮点数</li><li>字符串是有效的8进制或16进制（0o或0x开头），则会转换成对应的8进制或者16进制</li><li>空串返回0</li><li>不属于以上几种情况的，返回NaN</li></ul></li></ol></li><li><p>parseInt()和parseFloat()：将字符串转为数值</p><p>parseInt()检测到第一个不是数值的字符为止，如果检测到了字符串的末尾返回数值，如果没有，就返回NaN。如果传入的不是Number类型或String类型，会直接返回NaN</p><p>paraseInt()可以接受第二个参数，用于指定底数。如果指定了底数，第一个参数字符串就不用加上前缀了</p><p>parseFloat()始终忽略前缀的0，但是parseFloat()只能解析10进制的数值，因此不能指定底数。</p></li></ul></li><li><p>Boolean：true&#x2F;false</p><ul><li><p>Boolean()转型函数，可以将所有类型的值转为相应布尔值的等价形式，转换规则如下：</p><table><thead><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>非空字符串</td><td>‘’</td></tr><tr><td>Number</td><td>非零数值（包括无穷值）</td><td>0、NaN</td></tr><tr><td>Object</td><td>任意对象</td><td>null</td></tr><tr><td>Undefined</td><td>-</td><td>undefined</td></tr></tbody></table></li><li><p>if等流控制语句会自动执行其他类型数值到布尔值的转换</p></li></ul></li><li><p>Undefined：undefined</p><ul><li><p>声明了但未初始化的变量，默认赋值undefined</p></li><li><p>对于未声明的变量只能调用typeof。对未声明的变量和声明了但是没赋初值的变量调用typeof，结果都是字符串’undefined’</p></li></ul></li><li><p>Null：null</p><ul><li><p>表示一个空对象指针，定义将来要保存对象值的变量时，建议使用null来进行初始化，不要用其他值。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>)<span class="hljs-comment">//true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> === <span class="hljs-literal">null</span>) <span class="hljs-comment">//false</span></code></pre></div></li><li><p>null和undefined的区别：undefined代表定义了但是没有初始化，null代表空对象引用，可以理解为赋值了，只不过值为null，没有实际意义。将变量的初始值赋值为null，表示将要把这个变量赋值为对象。将一个对象变量赋值为null时，运行时会释放变量的内存。</p></li></ul></li><li><p>Symbol：任意的符号</p><ul><li>Symbol()函数不能用作构造函数，与new关键字一起使用。但是可以借用Object()函数创建符号包装对象。</li><li>共享和重用符号实例可以使用全局符号注册表。Symbol.for()接受一个字符串作为键，在全局符号注册表中创建并重用符号。可以使用Symbol.keyFor()来查询全局注册表，接受符号返回该全局符号的字符串键，如果查询的不是全局符号，返回undefined。如果传给Symbol.for()的不是符号，则抛出错误。</li><li>对象字面量只能在计算属性中使用符号作为属性。Object.defineProperty()和Object.defineProperties()也可以定义符号属性。</li><li>Object.getOwnPropertyNames()返回对象实例的常规<strong>属性</strong>数组。Object.getPropertySymbols()返回对象实例的符号<strong>属性</strong>数组。上面这两个方法互斥。Object.getPropertyDescripteors()都返回常规属性和符号属性的描述符对象。Refilect.ownKeys()会返回两种类型的键。</li><li>ES6引入了一些常用内置符号，用于暴露语言内部行为。</li></ul></li></ol><p>复杂数据类型–1种</p><ol><li><p>Object：任意对象</p><ul><li>Function：一种特别的对象（可以调用执行）</li><li>Array：一种特别的对象（数值下标，内部数据有序）</li><li>对象就是一组数据和功能的集合</li></ul></li></ol><h3 id="1-1-2-判断"><a href="#1-1-2-判断" class="headerlink" title="1.1.2 判断"></a>1.1.2 判断</h3><ul><li><p>typeof操作符</p><ul><li><p>typeof返回的是数据类型的字符串表达，返回值一共有7种。没有’null’但是多个一个’function’</p><ul><li>‘undefined’</li><li>‘boolean’</li><li>‘string’</li><li>‘number’</li><li>‘object’：表示值为对象而不是函数，或者值为null。（null被认为是一个空对象的引用）</li><li>‘function’：表示值为函数</li><li>‘symbol’</li></ul></li><li><p>typeof是一个操作符而不是函数，所以不需要参数，但是可以使用参数</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> message)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(message))</code></pre></div></li><li><p>不能判断null和array类型，因为返回的都是字符串’object’</p></li></ul></li><li><p>instanceof</p><ul><li>A instanceof B：判断A是不是B的一个实例。B是一个构造函数，A是一个实例对象</li><li>可以判断对象的具体类型，一个函数还是一个数组</li></ul></li><li><p>&#x3D;&#x3D;&#x3D;</p><ul><li>可以判断undefined和null</li></ul></li></ul><h3 id="1-1-3-变量类型和数据类型的区别"><a href="#1-1-3-变量类型和数据类型的区别" class="headerlink" title="1.1.3 变量类型和数据类型的区别"></a>1.1.3 变量类型和数据类型的区别</h3><ul><li>数据类型：简单数据类型（6种）和复杂数据类型（对象）</li><li>变量类型：基本类型和引用类型</li><li>变量值：原始值和引用值</li></ul><h2 id="1-2-数据、变量、内存"><a href="#1-2-数据、变量、内存" class="headerlink" title="1.2 数据、变量、内存"></a>1.2 数据、变量、内存</h2><h3 id="1-2-1-数据"><a href="#1-2-1-数据" class="headerlink" title="1.2.1 数据"></a>1.2.1 数据</h3><ul><li>存储在内存中，代表特定信息</li></ul><h3 id="1-2-2-内存"><a href="#1-2-2-内存" class="headerlink" title="1.2.2 内存"></a>1.2.2 内存</h3><ul><li><p>可存储数据的临时空间</p></li><li><p>栈内存：全局变量和局部变量</p></li><li><p>堆内存：对象</p></li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = xxx</code></pre></div><ul><li>如果xxx是简单数据，则a内存中保存的是这个数据</li><li>如果xxx是对象，则a内存中保存的是这个对象的地址值</li></ul> <div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = xxx<span class="hljs-keyword">let</span> b = a</code></pre></div><ul><li>如果xxx是简单数据，则b内存中保存的是这个数据的值</li><li>如果xxx是对象，则b内存中保存的是对象的地址值</li></ul><h3 id="1-2-3-变量"><a href="#1-2-3-变量" class="headerlink" title="1.2.3 变量"></a>1.2.3 变量</h3><ul><li><p>可变化的量，由变量名和变量值组成</p></li><li><p>每个变量都对应一块内存，变量名用来查找对应的内存，变量值就是内存中保存的数值数据</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>&#125;;<span class="hljs-keyword">let</span> a = objobj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>) <span class="hljs-comment">//Jack</span></code></pre></div><p>obj中保存值的是{name:’Tom’}这个对象数据的地址值，<code>let a = obj</code> 这条语句的作用是将obj中保存的值（也就是对象数据的地址）拷贝一份赋值给a。obj和a中保存的内容是一样的，都是{name:’Tom’}这个对象。所以通过obj修改对象的数据后，a指向的内容是修改过的数据。</p></li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">obj</span>)&#123;obj.<span class="hljs-property">x</span> = <span class="hljs-number">200</span>&#125;<span class="hljs-title function_">f</span>(a)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">//&#123;x:200&#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">obj</span>)&#123;obj = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">200</span>&#125;&#125;<span class="hljs-title function_">f</span>(a)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">//&#123;x：100&#125;</span></code></pre></div><ul><li><p>上面第一种可以通过obj取对象的数据，并进行修改。这种修改实参也会看到对象被修改。第二种是将一个新对象的地址赋值给了obj，没有对原对象进行修改由于a变量种保存的仍然是原对象的地址值，多以a对象看不到修改后的内容。</p></li><li><p>js调用函数时传递变量参数时，是值传递还是引用传递?说法1：值传递。这个值可能是简单数据类型的值，也可能是对象的地址值。说法2：可能是值传递，也可能是引用传递（地址值）。</p></li></ul><h3 id="1-2-4-内存释放"><a href="#1-2-4-内存释放" class="headerlink" title="1.2.4 内存释放"></a>1.2.4 内存释放</h3> <div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">let</span> b = &#123;&#125;&#125;<span class="hljs-title function_">f</span>()</code></pre></div><ul><li>上面的例子中，b是局部变量。函数f()执行完后，b会自动释放，而b所指向的对象在后面的某个时刻由垃圾回收器回收。全局变量不会释放。</li></ul><h2 id="1-3-垃圾回收"><a href="#1-3-垃圾回收" class="headerlink" title="1.3 垃圾回收"></a>1.3 垃圾回收</h2><ul><li>js是使用垃圾回收的语言，通过自动内存管理实现内存分配和闲置资源回收。基本思路是，确定哪个变量不会再使用，然后释放它占用的内存。因此，垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用。</li><li>两种策略：标记清理（最常用）和引用计数</li></ul><h3 id="1-3-1-标记清理"><a href="#1-3-1-标记清理" class="headerlink" title="1.3.1 标记清理"></a>1.3.1 标记清理</h3><ul><li>变量进入上下文时，将其标记为‘进入上下文’；变量离开上下文时，将其标记为‘离开上下文’。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li></ul><h3 id="1-3-2-引用计数"><a href="#1-3-2-引用计数" class="headerlink" title="1.3.2 引用计数"></a>1.3.2 引用计数</h3><ul><li><p>当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另外一个变量，则该值得引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。 </p></li><li><p>问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">problem</span>(<span class="hljs-params"></span>)&#123;         <span class="hljs-keyword">var</span> objectA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();    <span class="hljs-keyword">var</span> objectB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();      objectA.<span class="hljs-property">someOtherObject</span> = objectB;    objectB.<span class="hljs-property">anotherObject</span> = objectA; &#125;</code></pre></div><p>在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。</p><p>在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。</p></li></ul><h2 id="1-4-内存管理"><a href="#1-4-内存管理" class="headerlink" title="1.4 内存管理"></a>1.4 内存管理</h2><ul><li>优化内存占用的最佳手段就是保证执行代码时只保存必要的数据。解除引用：如果数据不在必要，将其设置为null，从而释放其引用。解除对一个值的引用并不会自动导致相关的内存被回收。解除引用的关键在于确保相关的值不在上下文中吗，以便下次垃圾回收时会被回收。</li></ul><h1 id="第二章-对象与函数"><a href="#第二章-对象与函数" class="headerlink" title="第二章 对象与函数"></a>第二章 对象与函数</h1><h2 id="2-1-对象"><a href="#2-1-对象" class="headerlink" title="2.1 对象"></a>2.1 对象</h2><h3 id="2-1-1-对象的组成"><a href="#2-1-1-对象的组成" class="headerlink" title="2.1.1 对象的组成"></a>2.1.1 对象的组成</h3><ul><li>属性</li><li>方法</li></ul><h3 id="2-1-2-属性"><a href="#2-1-2-属性" class="headerlink" title="2.1.2 属性"></a>2.1.2 属性</h3><ul><li>属性由属性名和属性值组成，属性名一定是字符串。属性值为任意类型。</li></ul><h3 id="2-1-3-方法"><a href="#2-1-3-方法" class="headerlink" title="2.1.3 方法"></a>2.1.3 方法</h3><ul><li>一种特别的属性，属性的值是函数</li></ul><h3 id="2-1-4-访问方法"><a href="#2-1-4-访问方法" class="headerlink" title="2.1.4 访问方法"></a>2.1.4 访问方法</h3><ul><li>使用.进行访问属性，有时不能用。属性名包含特殊字符。或者是符号属性。</li><li>使用[属性名字符串]，通用</li></ul><h2 id="2-2-函数"><a href="#2-2-函数" class="headerlink" title="2.2 函数"></a>2.2 函数</h2><ul><li><p>只有函数可以执行，其他数据不可执行</p></li><li><p>定义方式：函数声明形式 函数表达式形式</p></li><li><p>调用方式：</p><ul><li>()</li><li>text.call&#x2F;apply(obj)：临时让test成为obj的方法进行调用</li></ul></li><li><p>回调函数：dom事件回调函数，定时器回调函数</p><ul><li>只定义了没有调用，最后执行了</li></ul></li><li><p>函数中的this</p><ul><li>任何函数本质上都是通过某个对象来调用的，如果没有指定即使window</li><li>所有函数内部都有一个变量this</li><li>this的值是调用函数的当前对象</li></ul></li><li><p>确定this的值</p><ul><li>test():window</li><li>p.test():p</li><li>new test():新创建的对象</li><li>p.call(obj):obj</li></ul></li><li><p>js分号问题</p><ul><li>什么时候不加分号会出现问题：小括号或中括号开头的前一条语句。</li></ul></li></ul><h1 id="第三章-原型与原型链"><a href="#第三章-原型与原型链" class="headerlink" title="第三章 原型与原型链"></a>第三章 原型与原型链</h1><h2 id="3-1-原型"><a href="#3-1-原型" class="headerlink" title="3.1 原型"></a>3.1 原型</h2><ul><li>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</li><li>原型对象中有一个属性constructor, 它指向函数对象</li><li>每个函数function都有一个prototype，即显式原型</li><li>每个实例对象都有一个<code>__proto__</code>，可称为隐式原型</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值</li></ul><h2 id="3-2-原型链"><a href="#3-2-原型链" class="headerlink" title="3.2 原型链"></a>3.2 原型链</h2><ul><li>原型链是用来查找对象的属性的，想查找变量要用到作用域链</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">test1</span> = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test1()&quot;</span>);    &#125;;&#125;<span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test2</span> = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test2()&quot;</span>);&#125;;<span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();fn.<span class="hljs-title function_">test1</span>();   <span class="hljs-comment">//test1属性在Fn的实例对象fn上</span>fn.<span class="hljs-title function_">test2</span>();   <span class="hljs-comment">//test2属性在Fn的原型对象Object空对象上</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">//toString属性在Object的原型对象上</span>fn.<span class="hljs-title function_">test3</span>();   <span class="hljs-comment">//原型链中无test3属性</span></code></pre></div><p><img src="/images/JavaScript%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/uTools_1638774048683-16388599608671.png" alt="uTools_1638774048683"></p><p>访问一个对象的属性时：</p><ol><li>先在自身属性中查找，然后返回</li><li>如果没有，沿着<code>__proto__</code>这条链向上查找，找到返回</li><li>如果最后没有找到，返回undefined</li></ol><ul><li>原型链是按照隐式原型链进行查找的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript】Promise-1-基础用法</title>
    <link href="/archives/f28bcdc5.html"/>
    <url>/archives/f28bcdc5.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-Promise-的理解和使用"><a href="#第一章-Promise-的理解和使用" class="headerlink" title="第一章 Promise 的理解和使用"></a>第一章 Promise 的理解和使用</h1><h2 id="1-1-Promise-是什么"><a href="#1-1-Promise-是什么" class="headerlink" title="1.1 Promise 是什么"></a>1.1 Promise 是什么</h2><h3 id="1-1-1-理解"><a href="#1-1-1-理解" class="headerlink" title="1.1.1 理解"></a>1.1.1 理解</h3><ul><li>Promise 是 JavaScript 中进行异步编程的新的解决方案。旧的方案是单纯使用回调函数。</li><li>从语法上讲，Promise 是一个构造函数。</li><li>从功能上讲，Promise 对象用来封装一个异步操作并获取其成功&#x2F;失败的值。</li></ul><h3 id="1-1-2-异步编程"><a href="#1-1-2-异步编程" class="headerlink" title="1.1.2 异步编程"></a>1.1.2 异步编程</h3><ul><li>fs 文件操作（node.js）</li><li>数据库操作</li><li>AJAX</li><li>定时器</li></ul><h2 id="1-2-为什么使用-Promise"><a href="#1-2-为什么使用-Promise" class="headerlink" title="1.2 为什么使用 Promise"></a>1.2 为什么使用 Promise</h2><h3 id="1-2-1-指定回调函数的方式更加灵活"><a href="#1-2-1-指定回调函数的方式更加灵活" class="headerlink" title="1.2.1 指定回调函数的方式更加灵活"></a>1.2.1 指定回调函数的方式更加灵活</h3><ul><li>旧的方案：必须在启动异步任务前指定。</li><li>Promise：启动异步任务 &#x3D;&gt; 返回 Promise 对象 &#x3D;&gt; 给 Promise 对象绑定回调函数（甚至可以在异步任务结束后指定）</li></ul><h3 id="1-2-2-支持链式调用，解决回调地狱的问题"><a href="#1-2-2-支持链式调用，解决回调地狱的问题" class="headerlink" title="1.2.2 支持链式调用，解决回调地狱的问题"></a>1.2.2 支持链式调用，解决回调地狱的问题</h3><ul><li>什么是回调地狱：回调函数嵌套回调函数</li><li>回调地狱的缺点：不便于阅读，不便于异常处理</li></ul><h1 id="第二章-了解-Promise"><a href="#第二章-了解-Promise" class="headerlink" title="第二章 了解 Promise"></a>第二章 了解 Promise</h1><h2 id="2-1-Promise-的状态"><a href="#2-1-Promise-的状态" class="headerlink" title="2.1 Promise 的状态"></a>2.1 Promise 的状态</h2><ol><li><p>pending 未决定的</p></li><li><p>resolved &#x2F; fullfilled 成功</p></li><li><p>rejected 失败</p></li></ol><ul><li><p>实例对象中的一个属性：[[PromiseState]]</p></li><li><p>状态只能由 pending 转变成 resolved 或者由 pending 转变成 rejected，且每个 Promise 对象只能改变一次</p></li><li><p>成功的结果一般叫 value，失败的结果一般叫 reason</p></li></ul><h2 id="2-2-Promise-的值"><a href="#2-2-Promise-的值" class="headerlink" title="2.2 Promise 的值"></a>2.2 Promise 的值</h2><ul><li>实例对象中的另一个属性：[[PromiseResult]]</li><li>保存着异步任务对象成功或者失败的结果</li></ul><h2 id="2-3-Promise-的基本流程"><a href="#2-3-Promise-的基本流程" class="headerlink" title="2.3 Promise 的基本流程"></a>2.3 Promise 的基本流程</h2><ol><li><p>实例化一个 Promise 对象</p></li><li><p>成功就调用 resolve() 函数</p></li><li><p>失败就调用 reject() 函数</p></li></ol><h2 id="2-4-如何使用-Promise-对象"><a href="#2-4-如何使用-Promise-对象" class="headerlink" title="2.4 如何使用 Promise 对象"></a>2.4 如何使用 Promise 对象</h2><h3 id="2-4-1-Promise-构造函数"><a href="#2-4-1-Promise-构造函数" class="headerlink" title="2.4.1 Promise() 构造函数"></a>2.4.1 Promise() 构造函数</h3><p>Promise 构造函数：<code>Promise(executor)&#123;&#125;</code></p><ul><li>executor：执行器函数 <code>(resolve, reject)=&gt;&#123;&#125;</code></li><li>resolve() 函数：内部定义成功时调用的函数</li><li>reject() 函数：内部定义失败时调用的函数</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 同步代码 ...</span>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-comment">// 成功调用</span>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;foo&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 失败调用</span>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;bar&quot;</span>);  &#125;&#125;);</code></pre></div><blockquote><p><strong>注意</strong>：执行器函数是<strong>同步调用</strong>的，立即执行。</p></blockquote><h3 id="2-4-2-Promise-prototype-then-方法"><a href="#2-4-2-Promise-prototype-then-方法" class="headerlink" title="2.4.2 Promise.prototype.then() 方法"></a>2.4.2 Promise.prototype.then() 方法</h3><p>Promise.prototype.then() 方法接收两个函数参数：onResolved 和 onRejected。</p><ul><li>onResolved() 函数：成功的回调函数 <code>(value)=&gt;&#123;&#125;</code></li><li>onRejected() 函数：失败的回调函数 <code>(reason)=&gt;&#123;&#125;</code></li><li>返回值是一个新的 Promise 对象</li></ul><div class="code-wrapper"><pre><code class="hljs javascript">p.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  &#125;,  <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);  &#125;);</code></pre></div><h3 id="2-4-3-Promise-prototype-catch-方法"><a href="#2-4-3-Promise-prototype-catch-方法" class="headerlink" title="2.4.3 Promise.prototype.catch() 方法"></a>2.4.3 Promise.prototype.catch() 方法</h3><p>Promise.prototype.catch() 方法只能接收失败的回调，不能接收成功的回调。只接受一个函数参数 onRejected。</p><ul><li>onRejected() 函数：失败的回调函数 <code>(reason)=&gt;&#123;&#125;</code></li></ul><div class="code-wrapper"><pre><code class="hljs javascript">p.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);&#125;);</code></pre></div><h3 id="2-4-4-Promise-resolve-方法"><a href="#2-4-4-Promise-resolve-方法" class="headerlink" title="2.4.4 Promise.resolve() 方法"></a>2.4.4 Promise.resolve() 方法</h3><p>Promise.resolve() 方法可以将任意值（参数 value）封装成一个的 Promise 对象（如果传入的 value 是一个 Promise 对象，那么便保留状态，因此创建出来的 Promise 对象不一定是成功状态）。</p><ul><li>value：成功的数据或一个 Promise 对象。</li><li>返回的 Promise 对象可以是成功状态也可以失败状态（传入失败状态的 Promise 对象或抛出错误时返回失败状态的对象，其余情况均返回成功状态的对象）。</li><li>用于快速创建一个 Promise 对象。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 传入一个数据，得到封装该数据的成功状态的 Promise 对象</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1);<span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 传入一个 Promise 对象，返回的 Promise 对象会保留其状态</span><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p1);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2);<span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;bar&quot;</span>));<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p3);<span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: &#x27;bar&#x27;&#125;</span><span class="hljs-comment">// Uncaught (in promise) bar</span></code></pre></div><h3 id="2-4-5-Promise-reject-方法"><a href="#2-4-5-Promise-reject-方法" class="headerlink" title="2.4.5 Promise.reject() 方法"></a>2.4.5 Promise.reject() 方法</h3><p>Promise.reject() 方法可以将任意值（参数 reason）封装成一个拒绝状态的 Promise 对象。</p><ul><li>reason：失败的数据或一个 Promise 对象。</li><li>返回的是失败状态的 Promise 对象。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 传入一个数据，返回一个失败的 Promise 对象</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p1);<span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: &#x27;foo&#x27;&#125;</span><span class="hljs-comment">// Uncaught (in promise) foo</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 传入一个 成功状态的 Promise 对象</span><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;bar&quot;</span>));<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-number">0</span>, p2);<span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: Promise&#125;</span><span class="hljs-comment">// Uncaught (in promise) Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span></code></pre></div><h3 id="2-4-6-Promise-all-方法"><a href="#2-4-6-Promise-all-方法" class="headerlink" title="2.4.6 Promise.all() 方法"></a>2.4.6 Promise.all() 方法</h3><p>Promise.all() 方法 ：</p><ul><li>接收包含 n 个 Promise 对象的数组。</li><li>返回的是一个 Promise 对象，只有参数中所有的 Promise 都成功才成功，只要由一个失败了就算失败。</li><li>成功的结果是每个 Promise 对象的结果的数组，失败的结果是第一个失败的那个 Promise 对象的失败结果。</li></ul><h3 id="2-4-7-Promise-race-方法"><a href="#2-4-7-Promise-race-方法" class="headerlink" title="2.4.7 Promise.race()  方法"></a>2.4.7 Promise.race()  方法</h3><p>Promise.race()  方法：</p><ul><li><p>接收包含 n 个 Promise 对象的数组。</p></li><li><p>返回的是一个 Promise 对象，第一个完成的 Promise 的结果状态就是最终的结果状态。（赛跑，谁先改变状态，最后的状态就是谁）</p></li></ul><h2 id="2-5-几个关键问题"><a href="#2-5-几个关键问题" class="headerlink" title="2.5 几个关键问题"></a>2.5 几个关键问题</h2><ol><li>如何改变 Promise 对象的状态<ul><li>调用 resolve() 函数，pending 转为 fullfilled 或 resolved</li><li>调用 reject() 函数，pending 转为 rejected</li><li>throw 抛出错误，pending 转为 rejected</li></ul></li><li>一个 Promise 对象指定多个成功&#x2F;失败回调函数，都会调用吗？<ul><li>都会</li></ul></li><li>Promise.prototype.then() 返回的新 Promise 对象的结果状态由什么来决定<ul><li>由指定的回调函数的执行结果来决定的。</li><li>如果抛出异常，新的 Promise 对象变为 rejected，reason 为抛出的异常。</li><li>如果返回的是非 Promise 对象的值，新的 Promise 对象变成 resolved，value 为返回的值。</li><li>如果返回的是另一个新的 Promise 对象。此 Promise 对象的结果就成为新的 Promise 对象的结果。</li></ul></li><li>Promise 异常穿透<ul><li>当使用 Promise 的 then 链式调用时，可以再最后指定失败的回调</li></ul></li><li>中断 Promise 链<ul><li>有且只有一种方式：返回一个 pending 状态的 Promise 对象</li></ul></li></ol><h1 id="第三章-async-和-await"><a href="#第三章-async-和-await" class="headerlink" title="第三章 async 和 await"></a>第三章 async 和 await</h1><h2 id="3-1-async-函数"><a href="#3-1-async-函数" class="headerlink" title="3.1 async 函数"></a>3.1 async 函数</h2><ul><li><p>函数的返回值为 Promise 对象</p></li><li><p>Promise 对象的结果由 async 函数执行的返回值决定</p><ol><li><p>如果函数的返回值是一个非 Promise 类型的数据，返回的就是成功类型的对象，并且成功的结果就是返回值</p></li><li><p>如果函数返回的是一个 Promise 类型的数据，这个 Promise 对象的结果就是 async 返回的结果</p></li><li><p>如果抛出异常，返回的结果是失败状态的，并且原因是 throw 抛出来的值</p></li></ol></li></ul><h2 id="3-2-await-表达式"><a href="#3-2-await-表达式" class="headerlink" title="3.2 await 表达式"></a>3.2 await 表达式</h2><ul><li>await 右侧的表达式一般为 Promise 对象，也可以是其他类型的值</li><li>如果表达式是 Promise 对象，await 返回的是 Promise 对象成功的值</li><li>如果表达式是其他值，直接讲此值作为 await 的返回值</li></ul><h2 id="3-3-注意"><a href="#3-3-注意" class="headerlink" title="3.3 注意"></a>3.3 注意</h2><ol><li>await 必须写在 async 函数中，但是 async 函数中可以没有 await</li><li>如果 await 的 Promise 失败了，就会抛出异常，需要用 try…catch 捕获异常</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue2】Vue基础笔记</title>
    <link href="/archives/65ab80b7.html"/>
    <url>/archives/65ab80b7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Vue笔记"><a href="#Vue笔记" class="headerlink" title="Vue笔记"></a>Vue笔记</h1><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//引入Vue<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,     </span><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;        </span><span class="language-javascript">            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span>,</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangtuo&#x27;</span>,</span><span class="language-javascript">            <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,</span><span class="language-javascript">            <span class="hljs-attr">code</span>:<span class="hljs-string">&#x27;&lt;h1&gt;标题&lt;/h1&gt; 正文 &lt;br&gt; &#x27;</span>,</span><span class="language-javascript">            <span class="hljs-attr">imgSrc</span>:<span class="hljs-string">&#x27;https://cn.vuejs.org/images/logo.svg&#x27;</span>,</span><span class="language-javascript">            <span class="hljs-attr">school</span>: &#123;<span class="hljs-attr">s1</span>: <span class="hljs-string">&#x27;清华&#x27;</span>, <span class="hljs-attr">s2</span>: <span class="hljs-string">&#x27;北大&#x27;</span>, <span class="hljs-attr">s3</span>: <span class="hljs-string">&#x27;北化&#x27;</span>&#125;,</span><span class="language-javascript">            <span class="hljs-attr">colleges</span>: [</span><span class="language-javascript">               &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">s1</span>: <span class="hljs-string">&#x27;清华&#x27;</span>, <span class="hljs-attr">s2</span>: <span class="hljs-string">&#x27;北大&#x27;</span>, <span class="hljs-attr">s3</span>: <span class="hljs-string">&#x27;北化&#x27;</span>&#125;,</span><span class="language-javascript">                &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">s1</span>: <span class="hljs-string">&#x27;清华&#x27;</span>, <span class="hljs-attr">s2</span>: <span class="hljs-string">&#x27;北大&#x27;</span>, <span class="hljs-attr">s3</span>: <span class="hljs-string">&#x27;北化&#x27;</span>&#125;,</span><span class="language-javascript">                &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">s1</span>: <span class="hljs-string">&#x27;清华&#x27;</span>, <span class="hljs-attr">s2</span>: <span class="hljs-string">&#x27;北大&#x27;</span>, <span class="hljs-attr">s3</span>: <span class="hljs-string">&#x27;北化&#x27;</span>&#125;,</span><span class="language-javascript">            ]</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">            <span class="hljs-comment">// es5写法</span></span><span class="language-javascript">            <span class="hljs-attr">fun1</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>++;<span class="hljs-comment">//this 对象指的是vue实例对象本身</span></span><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;年龄加1&quot;</span>);</span><span class="language-javascript">            &#125;,</span><span class="language-javascript">            <span class="hljs-comment">// es6写法 （简化）</span></span><span class="language-javascript">            <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>--;</span><span class="language-javascript">                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> &lt; <span class="hljs-number">1</span>)</span><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">1</span>;</span><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;年龄减1&quot;</span>);</span><span class="language-javascript">            &#125;,</span><span class="language-javascript">        &#125;</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><code>el:&quot;#app&quot;</code>:</p><ul><li>el即element </li><li>作用：指定Vue实例的作用范围。在作用范围内直接使用<code>&#123;&#123;数据名&#125;&#125;</code>（插值表达式）可以取到属性值</li><li>可以使用类选择器，但是推荐使用id选择器。注意：不要把作用域指向body或html</li></ul><p><code>data:&#123;msg:&#39;Hello World&#39;&#125;</code>:</p><ul><li>作用：给Vue实例对象绑定一系列数据</li></ul><p><code>methods: &#123;fun()&#123;&#125;&#125;</code>:</p><ul><li>作用：事件处理函数等</li></ul><h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><ul><li><p>格式：<code>&#123;&#123;数据名&#125;&#125;</code> </p><p>例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div></li><li><p>作用：把Vue实例中的数据展示到网页上</p></li><li><p>使用<code>&#123;&#123;数据名&#125;&#125;</code>时可以进行算数运算和逻辑运算，也可以使用js方法。例：<code>&#123;&#123;age+12&#125;&#125;</code>或<code>&#123;&#123;age===12&#125;&#125;</code>或<code>&#123;&#123;msg.toLowerCase()&#125;&#125;</code></p></li></ul><h2 id="v-text和v-html"><a href="#v-text和v-html" class="headerlink" title="v-text和v-html"></a>v-text和v-html</h2><ul><li><p>格式：<code>v-text=&quot;数据名&quot;</code> </p><p>例：</p></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span> 你好<span class="hljs-tag">&lt;/<span class="hljs-name">sapn</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span> html代码片段<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><ul><li><p>作用：<code>v-text</code>和 <code>v-html</code> 都可以根据属性名获取<code>data</code>中的数据，并且都会覆盖原标签中的数据</p></li><li><p><code>&#123;&#123;   &#125;&#125;</code>和v-text的区别：</p><ul><li><code>v-text</code>会覆盖掉标签中原来的内容</li><li><code>v-text</code>可以避免<strong>插值闪烁</strong></li><li><strong>插值闪烁</strong>：网络差时，使用插值表达式<code>&#123;&#123;   &#125;&#125;</code>时，加载会有延迟，网页上会显示插值表达式的代码。</li></ul></li><li><p><code>v-html</code>和<code>v-text</code>的区别：</p><ul><li><code>v-text</code>把数据内容当作文本直接展示到页面上，相当于js中的innerText</li><li><code>v-htm</code>l把数据内容当作html代码，解析html标签后渲染到对应标签内部，相当于js中的innerHtml</li></ul></li></ul><h2 id="v-on和"><a href="#v-on和" class="headerlink" title="v-on和@"></a>v-on和@</h2><ul><li><p>格式：<code>v-on:事件名=&quot;函数(参数列表)&quot;</code>    简化写法：<code>@事件名</code></p><p>例：</p></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;fun1&quot;</span>&gt;</span>年龄加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>注释：函数无参数时不用加()<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fun1&quot;</span>&gt;</span>年龄加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><ul><li><p>作用：给对应标签绑定事件</p></li><li><p>js事件三要素：</p><ul><li>事件源：发生事件的源头，指html中各种标签</li><li>事件：发生的特定动作，指的是单击、双击等动作</li><li>事件处理函数（监听器）：事件触发时的响应</li></ul></li><li><p>vue的事件处理函数统一声明在vue实例的methods属性中</p></li></ul><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><ul><li><p>vue实例中data数据值变化时，页面上的值同步发生变化</p></li><li><p>页面上的值发生变化时，vue实例中data数据值同步变化</p></li></ul><h2 id="v-bind和"><a href="#v-bind和" class="headerlink" title="v-bind和:"></a>v-bind和:</h2><ul><li><p>格式：<code>v-bind:属性名=属性值</code> 属性名是css的属性名，属性值是Vue实例中data里的数据名        简化写法  <code>:属性名</code></p><p>例:</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span>&gt;</span>注：data:&#123;imgSrc:&#x27;https://cn.vuejs.org/images/logo.svg&#x27;&#125;</code></pre></div></li><li><p>作用：绑定html标签的属性</p></li></ul><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ul><li><p>格式：<code>v-model=&quot;数据名&quot;</code></p><p>例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span></code></pre></div></li><li><p>作用：绑定form表单标签中的value属性</p></li></ul><h2 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h2><ul><li><p>格式：<code>v-if=&quot;布尔值&quot;</code>或<code>v-show=&quot;布尔值&quot;</code></p><p>例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p>作用：控制页面中的标签展示或隐藏</p></li><li><p>v-if和v-show的区别：</p><ul><li>v-if：底层操作DOM元素，添加或删除DOM控制标签显示或隐藏</li><li>v-show：底层控制CSS样式，控制标签是否展示。（推荐使用情况：数据量大，显示和隐藏切换频繁）</li></ul></li></ul><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><ul><li><p>格式：<code>v-for=&quot;(value,key,index) in items&quot;</code></p><p>例：</p><div class="code-wrapper"><pre><code class="hljs html">1.遍历对象属性<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,key,index) in school&quot;</span>&gt;</span>    &#123;&#123;value&#125;&#125;    &#123;&#123;key&#125;&#125;   &#123;&#123;index&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>2.遍历数组<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(college,index) in colleges&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;: &#123;&#123;college.s1&#125;&#125; &#123;&#123;college.s2&#125;&#125; &#123;&#123;college.s3&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p>作用：用来遍历vue实例的数据</p></li><li><p>注意：最好给v-for绑定一个唯一的key，确保正确渲染数据</p><p>例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(college,index) in colleges&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;college.id&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;: &#123;&#123;college.s1&#125;&#125; &#123;&#123;college.s2&#125;&#125; &#123;&#123;college.s3&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JavaScript】JavaScript基础笔记</title>
    <link href="/archives/3f7cd15d.html"/>
    <url>/archives/3f7cd15d.html</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript基础笔记"><a href="#JavaScript基础笔记" class="headerlink" title="JavaScript基础笔记"></a>JavaScript基础笔记</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>js是一门客户端脚本语言</p></li><li><p>运行在客户端浏览器中，每个浏览器中都有js的解析引擎</p></li><li><p>不需要编译，直接被浏览器解析执行</p></li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>增强用户的html页面的交互过程，用来控制html元素，让页面有一些动态效果</li></ul><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><ul><li>JavaScript&#x3D;ECMAScript+JavaScript特有的东西（BOM+DOM）</li></ul><h1 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h1><ul><li>客户端脚本语言标准</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="与html结合方式"><a href="#与html结合方式" class="headerlink" title="与html结合方式"></a>与html结合方式</h3><ol><li><p>内部js。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello world&quot;</span>)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li><li><p>外部js。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/a.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li></ol><ul><li>可以写在html的任意位置，但是先后顺序有区别</li><li><code>&lt;script&gt;</code>标签可以定义多个</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>单行注释：<code>//注释</code></li><li>多行注释：<code>/*注释*/</code></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>原始数据类型（基本数据类型）</p><ul><li><p><code>number</code>：数字。 整数&#x2F;小数&#x2F;NaN</p></li><li><p><code>string</code>：字符串。字符&#x2F;字符串。单引号，双引号都可</p></li><li><p><code>boolean</code>：true和false</p></li><li><p><code>null</code>：一个对象为空的占位符</p></li><li><p><code>undefined</code>：未定义。如果一个变量没有初始化值，则会被默认赋值为undefined</p></li></ul></li><li><p>引用数据类型（对象）</p><ul><li><code>object</code></li></ul></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>一块存储数据的内存空间</li><li>java是强类型的语言，js是弱类型的语言</li><li>语法：<code>var 变量名 = 初始化值;</code></li><li>查看变量的类型：<code>typeof(变量名)</code></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol><li><p>一元运算符：++ ，– ，+</p><ul><li>在js中，如果运算数不是运算符要求的类型，那么js会自动将运算数进行类型转化</li></ul><p>其它类型转number：</p><ul><li><p>string转number。按字面值进行转换，如果字符串的字面值不是数字，则转为NaN</p></li><li><p>boolean转number。true转成1，false转成0</p></li></ul></li><li><p>算数运算符：+，-，*</p></li><li><p>比较运算符：&gt;，&lt;，&gt;&#x3D;，&#x3D;&#x3D;&#x3D;（全等于）</p><p>比较方式</p><ul><li><p>类型相同，直接比较</p><ul><li>字符串：按照字典顺序比较</li></ul></li><li><p>类型不同，先进行类型转换</p></li><li><p>&#x3D;&#x3D;&#x3D;全等于。在比较之前判断类型，如果类型不同，返回false</p></li></ul></li><li><p>逻辑运算符：&amp;&amp;，||，！</p><p>其它类型转boolean：</p><ul><li><p>number：0或NaN是false，其余为true</p></li><li><p>string：空串是都是false，其余为true</p></li><li><p>null或undefined为fasle</p></li><li><p>object：都是true</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(obj)&#123;    <span class="hljs-comment">//防止空指针异常</span><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello world&quot;</span>)&#125;</code></pre></div></li><li><p>三元运算符：？ ：</p></li></ol><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ol><li>if else</li><li>switch<ol><li>java中可以接受的数据类型：byte int char string emun  ……</li><li>js中什类型都可以接受</li></ol></li><li>while</li><li>do while</li><li>for</li></ol><h3 id="js特殊语法"><a href="#js特殊语法" class="headerlink" title="js特殊语法"></a>js特殊语法</h3><ol><li>语句以;结尾，如果一行只有一条语句可以省略</li><li>变量的定义使用var关键字，也可以不使用<ul><li>用：定义变量是局部变量</li><li>不用：定义的变量是全局变量</li></ul></li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="Function：函数对象"><a href="#Function：函数对象" class="headerlink" title="Function：函数对象"></a>Function：函数对象</h4><ol><li><p>创建</p><ol><li><p>格式一（不常用）</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fun =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(形参列表，方法体)；<span class="hljs-comment">//不常用</span></code></pre></div><p>如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;alert(a+b);&quot;</span>)</code></pre></div></li><li><p>格式二</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">形参列表</span>)&#123;方法体&#125;</code></pre></div><p>如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-title function_">alert</span>(a+b);&#125;</code></pre></div></li><li><p>格式三</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-title function_">alert</span>(a+b);&#125;</code></pre></div></li></ol></li><li><p>方法</p></li><li><p>属性</p><p><code>length</code>：代表形参的个数 </p></li><li><p>特点</p><ul><li><p>方法定义时，形参的类型不用写，返回值的类型也不用写</p></li><li><p>方法名称相同时，后面的方法会覆盖前面的方法</p></li><li><p>在js中，方法的调用只与方法的名称有关，和参数的列表无关</p></li><li><p>在方法声明中有一个隐藏的内置对象（数组）：<code>arguments</code>，封装所有的实际参数</p></li></ul></li><li><p>调用</p><p>格式：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fun</span>(形参列表)</code></pre></div><p>如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fun</span>(a,b)</code></pre></div></li></ol><h4 id="Array：数组对象"><a href="#Array：数组对象" class="headerlink" title="Array：数组对象"></a>Array：数组对象</h4><ol><li><p>创建</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(元素列表)</code></pre></div><p>或：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(默认长度)</code></pre></div><p>或：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [元素列表]</code></pre></div></li><li><p>方法</p><ul><li><p><code>join(参数)</code>：将数组的元素按指定的参数拼接成字符串，默认按<code>,</code>分割</p></li><li><p><code>push(值)</code>：向array尾部添加一个元素</p></li></ul></li><li><p>特点</p><ul><li><p>js中，数组元素的类型是可变的</p></li><li><p>js中，数组的长度是可变的</p></li></ul></li></ol><h4 id="Date：日期对象"><a href="#Date：日期对象" class="headerlink" title="Date：日期对象"></a>Date：日期对象</h4><ol><li><p>创建</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> date=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</code></pre></div></li><li><p>方法</p><ul><li><p><code>toLocalString()</code>：改成本地时间格式</p></li><li><p><code>getTime()</code>：获取毫秒值，返回当前时间和1970.1.1,00:00之间的差距</p></li></ul></li></ol><h4 id="Math：数学对象"><a href="#Math：数学对象" class="headerlink" title="Math：数学对象"></a>Math：数学对象</h4><ol><li><p>创建</p><p>不用创建直接使用。Math.方法名()</p></li><li><p>方法</p><ul><li><p><code>random()</code>：返回一个0-1之间的随机数，含头不含尾</p></li><li><p><code>ceil(x)</code>：对数字向上取整</p></li><li><p><code>floor(x)</code>：对数字向下取整</p></li><li><p><code>round(x)</code>：对数字四舍五入为整数</p></li></ul></li><li><p>属性</p><p><code>PI</code></p></li></ol><h4 id="RegExp：正则表达式对象"><a href="#RegExp：正则表达式对象" class="headerlink" title="RegExp：正则表达式对象"></a>RegExp：正则表达式对象</h4><h5 id="定义字符串表达规则"><a href="#定义字符串表达规则" class="headerlink" title="定义字符串表达规则"></a>定义字符串表达规则</h5><ol><li><p>单个字符：<code>[]</code></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-attr">[a]</span> <span class="hljs-selector-attr">[ab]</span>(<span class="hljs-selector-tag">a</span>或者<span class="hljs-selector-tag">b</span>) <span class="hljs-selector-attr">[a-zA-Z0-9_]</span>(字母数字下划线)</code></pre></div><p>特殊符号：</p><ul><li><p><code>\d</code>:单个数字字符[0-9]</p></li><li><p><code>\w</code>:单个单词字符[a-zA-Z0-9_]</p></li></ul></li><li><p>量词符号：</p><ul><li><p><code>?</code>：表示出现0次或1次</p></li><li><p><code>*</code>：表示出现0次或多次</p></li><li><p><code>+</code>：表示出现1次或多次</p></li><li><p><code>&#123;m,n&#125;</code>：表示出现次数大于等于m小于等于n</p><p>m缺省表示最多n次，n缺省表示最少m次</p></li></ul></li><li><p>开始结束符号：<code>/^  表达式  $/</code></p></li></ol><h5 id="正则对象"><a href="#正则对象" class="headerlink" title="正则对象"></a>正则对象</h5><ol><li><p>创建</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;正则表达式&quot;</span>);</code></pre></div><p>或：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/正则表达式/</span>;</code></pre></div></li><li><p>方法<br>test(字符串)：验证字符串是否符合正则表达式的规范</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> flag = reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;zhangtuo&quot;</span>)</code></pre></div></li></ol><h4 id="Globle：全局对象"><a href="#Globle：全局对象" class="headerlink" title="Globle：全局对象"></a>Globle：全局对象</h4><ol><li><p>特点</p><p>在这个Globle对象中封装方法不需要对象就可以直接调用。<code>方法名()</code></p></li><li><p>方法</p><ul><li><p><code>encodeURI</code>：url编码</p></li><li><p><code>decodeURI</code>：url解码</p></li><li><p><code>encodeURIComponent</code>：url编码，编码的字符更多</p></li><li><p><code>decodeURIComponent</code>：url解码</p></li><li><p><code>parseInt()</code>：将字符串转为数字。之一判断字符是否是数字，知道不是为止，将前面的数字转为number。如果第一个字符不是数字，转为NaN</p></li></ul></li></ol><h1 id="DOM简单学习"><a href="#DOM简单学习" class="headerlink" title="DOM简单学习"></a>DOM简单学习</h1><ol><li><p>功能：控制html文档的内容</p></li><li><p>代码：获取页面标签（元素）的对象</p><p><code>document.getElementById(id值)</code>：通过元素的id获取元素对象</p></li><li><p>操作Element对象：</p><ul><li><p>修改属性值：</p><ol><li>明确获取的对象是哪一个</li><li>查看api文档，找到哪些属性可以修改</li></ol></li><li><p>修改标签体中的内容：</p><p><code>innerHTML</code>方法</p></li></ul></li></ol><h1 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h1><ol><li><p>功能：某些组件执行了某些操作之后，触发某些代码执行</p></li><li><p>如何绑定事件</p><ol><li><p>直接在html标签上，指定事件的属性，属性值是js代码</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;light&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.gif&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&quot;</span><span class="hljs-attr">我被点击了</span>&quot;);&quot;&gt;</span></code></pre></div><p>或：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;</span><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我被点击了&quot;</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;light&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.gif&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun();&quot;</span>&gt;</span></code></pre></div></li><li><p>通过js获取元素对象，指定事件属性，并设置一个函数</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;light&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.gif&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;</span><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我被点击了&quot;</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript"><span class="hljs-keyword">var</span> light=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;light&quot;</span>);</span><span class="language-javascript">    light.<span class="hljs-property">onclick</span>=fun;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li></ol></li></ol><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>Brower Object Model 浏览器对象模型</li><li>将浏览器的各个部分封装成对象</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id="Window：窗口对象"><a href="#Window：窗口对象" class="headerlink" title="Window：窗口对象"></a>Window：窗口对象</h4><ol><li><p>创建（获取）</p></li><li><p>方法</p><p>与弹出框有关的方法</p><ul><li><p><code>alert()</code>：显示一段消息和一个确认按钮的警告框</p></li><li><p><code>conform()</code>：显示一段消息和确认按钮和取消按钮的对话框</p><p>点击确定按钮返回true，点击取消按钮返回false</p></li><li><p><code>promote()</code>：显示可提示用户输入的对话框</p><p>返回值就是用户输入的值</p></li></ul><p>与打开关闭有关的方法</p><ul><li><code>open()</code>：打开一个新窗口</li><li><code>close()</code>：关闭当前窗口，谁调用就关掉谁</li></ul><p>与定时器有关的方法</p><ul><li><p><code>setTimeout()</code>：一次性定时器</p><p>参数</p><ol><li>js代码</li><li>毫秒值</li></ol><p>反返回值</p><ul><li>定时器的编号，用于取消定时器</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;alert(&quot;</span>boom<span class="hljs-string">&quot;)&quot;</span>,<span class="hljs-number">3000</span>);</code></pre></div><p>或：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = <span class="hljs-title function_">settimeout</span>(fun,<span class="hljs-number">3000</span>);<span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;boom&quot;</span>);&#125;</code></pre></div></li><li><p><code>clearTimeout()</code>：取消一次性定时器</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">clearTimeout</span>(id);</code></pre></div></li><li><p><code>setInterval()</code>：循环定时器</p></li><li><p><code>clearInterval()</code>：取消循环定时器</p></li></ul></li><li><p>属性</p><ul><li>获取其他BOM对象</li></ul><p><code>window.history</code>或<code>history</code></p><ul><li>获取DOM对象</li></ul><p><code>window.document</code>或<code>document</code></p></li><li><p>特点</p><ul><li><p>Window对象不需要创建，可以直接使用。<code>window.方法名()</code>或<code>window.属性名</code></p></li><li><p>window也可以省略，直接用<code>方法名()</code>或<code>属性名</code></p></li></ul></li></ol><h4 id="Navigation：浏览器对象（不常用）"><a href="#Navigation：浏览器对象（不常用）" class="headerlink" title="Navigation：浏览器对象（不常用）"></a>Navigation：浏览器对象（不常用）</h4><h4 id="Screen：显示器屏幕对象（不常用）"><a href="#Screen：显示器屏幕对象（不常用）" class="headerlink" title="Screen：显示器屏幕对象（不常用）"></a>Screen：显示器屏幕对象（不常用）</h4><h4 id="History：历史记录对象"><a href="#History：历史记录对象" class="headerlink" title="History：历史记录对象"></a>History：历史记录对象</h4><p>当前页面窗口访问过的页面历史记录</p><ol><li><p>创建（获取）：</p><p><code>window.history</code>或<code>history</code></p></li><li><p>方法：</p><ul><li><p><code>back()</code>：</p></li><li><p><code>forward()</code>：</p></li><li><p><code>go</code>：</p></li></ul></li><li><p>属性：</p><p><code>length</code>：返回当前窗口历史列表中的url数量</p></li></ol><h4 id="Location：地址栏对象"><a href="#Location：地址栏对象" class="headerlink" title="Location：地址栏对象"></a>Location：地址栏对象</h4><ol><li><p>创建（获取）：</p><p><code>window.location</code>或<code>location</code></p></li><li><p>方法：</p><p><code>reload()</code>：刷新页面</p></li><li><p>属性：</p><p><code>href</code>：当前地址，可以设置href属性为新地址，用来跳转到新地址</p></li></ol><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><ul><li><p>Document Object Model 文档对象模型</p></li><li><p>通过 HTML DOM，JavaScript 能够访问和改变 HTML 文档的所有元素。</p></li><li><p>HTML DOM 模型被结构化为对象树：</p><p><img src="/images/JavaScript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/U727ed90323e34510805d1d87f00eb17cP.jpg" alt="U727ed90323e34510805d1d87f00eb17cP"></p></li><li><p>W3C DOM 标准被分为 3 个不同的部分：</p><ul><li><p>Core DOM - 所有文档类型的标准模型</p><ul><li><p><code>Document</code>：文档对象</p></li><li><p><code>Element</code>：元素对象</p></li><li><p><code>Attribute</code>：属性对象</p></li><li><p><code>Text</code>：文本对象</p></li><li><p><code>Comment</code>：注释对象</p></li><li><p><code>Node</code>：节点对象，是其它五种对象的父对象</p></li></ul></li><li><p>XML DOM - XML 文档的标准模型</p></li><li><p>HTML DOM - HTML 文档的标准模型</p></li></ul></li></ul><h2 id="核心DOM模型"><a href="#核心DOM模型" class="headerlink" title="核心DOM模型"></a>核心DOM模型</h2><h3 id="Document：文档对象"><a href="#Document：文档对象" class="headerlink" title="Document：文档对象"></a>Document：文档对象</h3><ol><li><p>创建（获取）：在html dom模型中可以使用window对象获取</p><p><code>window.document</code>或<code>document</code></p></li><li><p>方法：</p><ul><li>获取Element对象：<ul><li><code>getElementById()</code>：根据id属性值获取元素对象。id属性值一般唯一</li><li><code>getElementsByTagName()</code>：根据元素名称获取元素对象们，返回的是一个数组</li><li><code>getElementsByClassName()</code>：根据class属性值获取元素对象们，返回的是一个数组</li><li><code>getElementsByName()</code>：根据name属性值获取元素对象们，返回的是一个数组</li></ul></li><li>创建其它DOM对象：<ul><li><code>createAttribute(name)</code> ：创建新的属性对象</li><li><code>createComment()</code> ：创建新的注释对象</li><li><code>createElement()</code> ：创建新的元素对象</li><li><code>createTextNode()</code>：创建新的文本对象</li></ul></li></ul></li></ol><h3 id="Element：元素对象"><a href="#Element：元素对象" class="headerlink" title="Element：元素对象"></a>Element：元素对象</h3><ol><li><p>创建（获取）：</p><p>通过document获取，见上面四种方法</p></li><li><p>方法：</p><ul><li><code>setAttribute()</code>：设置属性</li><li><code>removeAttribute()</code>：删除属性</li></ul></li></ol><h3 id="Node：节点对象"><a href="#Node：节点对象" class="headerlink" title="Node：节点对象"></a>Node：节点对象</h3><ol><li><p>特点：</p><p>所有的dom对象都可以认为是一个节点</p></li><li><p>方法：</p><p>CRUD dom树</p><ul><li><code>appendChild()</code>：向节点的子节点列表的结尾添加新的子节点。</li><li><code>removeChild()</code>：删除（并返回）当前节点的指定子节点。</li><li><code>replaceChild()</code>：用新节点替换一个子节点。</li></ul></li><li><p>属性：</p><p><code>parentNode</code>：返回节点的父节点。</p></li></ol><h2 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h2><ol><li><p>标签体的设置和获取：<code>innerHTML</code></p></li><li><p>使用html元素对象的属性</p></li><li><p>设置样式</p><ul><li>使用style属性</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>使用style属性<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">div.<span class="hljs-property">style</span>.<span class="hljs-property">border</span>=<span class="hljs-string">&quot;1px solid red&quot;</span>;</span><span class="language-javascript">div.<span class="hljs-property">style</span>.<span class="hljs-property">fonSize</span>=<span class="hljs-string">&quot;20px&quot;</span>;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li>提前定义好类选择器的样式，通过元素的className属性来设置其class的样式</li></ul></li></ol><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li><p>功能：某些组件执行了某些操作之后，触发某些代码执行</p></li><li><p>事件：某些操作，如：单击，双击，键盘按下，鼠标移动了</p></li><li><p>事件源：组件，如：按钮，文本输入框</p></li><li><p>监听器：代码</p></li><li><p>注册监听：将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发某个监听器代码</p></li><li><p>常见事件：</p><ul><li>点击事件<ul><li><code>onclick</code>：单击事件</li><li><code>ondbclick</code>：双击事件</li></ul></li><li>焦点事件<ul><li><code>onblur</code>：失去焦点</li><li><code>onfocus</code>：元素获得焦点</li></ul></li><li>加载事件<ul><li><code>onload</code>：一张图片或页面加载完成</li></ul></li><li>鼠标事件<ul><li><code>onmousedown</code>：鼠标按钮被按下</li><li><code>onmouseover</code>：鼠标移动到某元素上</li></ul></li><li>键盘事件<ul><li><code>onkeydown</code>：某个键盘按键被按下</li><li><code>onkeyup</code>：某个键盘按键被松开</li><li><code>onkeypress</code>：某个键盘按键被按下并松开。</li></ul></li><li>选择和改变<ul><li><code>onchange</code>：内容被改变</li><li><code>onselect</code>：文本被选中</li></ul></li><li>表单事件<ul><li><code>onsubmit</code>：确认按钮被点击。</li></ul></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSS】CSS基础笔记</title>
    <link href="/archives/8074a0ef.html"/>
    <url>/archives/8074a0ef.html</url>
    
    <content type="html"><![CDATA[<h1 id="CSS基础笔记"><a href="#CSS基础笔记" class="headerlink" title="CSS基础笔记"></a>CSS基础笔记</h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li><p>Cascading Style Sheets 层叠样式表</p></li><li><p>层叠：多个样式作用在同一个HTML元素上，同时生效</p></li></ul><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>功能强大</li><li>将内容展示和样式控制分离<ul><li>降低耦合度</li><li>让分工更加容易</li><li>提高效率</li></ul></li></ul><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><ul><li><p>内联样式。只在当前标签生效。在标签内使用style属性指定css代码</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span> hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p>内部样式。只在当前页面生效。在<code>&lt;head&gt;</code>标签中定义<code>&lt;style&gt;</code>标签，<code>&lt;style&gt;</code>标签的标签体就是css代码</p>  <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:blue;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></div>  <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> hello css <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p>外部样式。在所有引入css资源文件的页面有效。在<code>&lt;head&gt;</code>标签内，定义<code>&lt;link&gt;</code>标签，引入外部的资源文件。</p>  <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./css/demo.css&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></div><p>  或者,</p>  <div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;css/demo.css&quot;</span></span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><div class="code-wrapper"><pre><code class="hljs css">选择器 &#123;属性名<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>;属性名<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>;&#125;</code></pre></div><ul><li>选择器：筛选具有相同特征的元素</li><li>注意：每一对属性都要用<code>;</code>隔开，最后一对可以不用</li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><ul><li><p>选择具体的id属性值，建议在一个html页面中id值唯一</p></li><li><p>语法：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#id</span>属性值&#123;&#125;</code></pre></div></li></ul><h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><ul><li><p>选择具有相同标签名称的元素</p></li><li><p>语法：</p><div class="code-wrapper"><pre><code class="hljs css">标签名称&#123;&#125;</code></pre></div></li><li><p>注意：id选择器的优先级高于元素选择器</p></li></ul><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><ul><li><p>选择具有相同class属性值的元素</p></li><li><p>语法：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.class</span>属性值&#123;&#125;</code></pre></div></li><li><p>优先级：id选择器&gt;类选择器&gt;元素选择器</p></li></ul><h3 id="扩展选择器"><a href="#扩展选择器" class="headerlink" title="扩展选择器"></a>扩展选择器</h3><ul><li><p>选择所有元素</p><ul><li>语法：<code>*&#123;&#125;</code></li></ul></li><li><p>并集选择器</p><ul><li>语法：<code>选择器1,选择器2&#123;&#125;</code></li></ul></li><li><p>子选择器</p><ul><li>语法：<code>选择器1 选择器2&#123;&#125;</code></li></ul></li><li><p>父选择器</p><ul><li>语法：<code>选择器1&gt;选择器2&#123;&#125;</code></li></ul></li><li><p>属性选择器</p><ul><li><p>语法：元素名称[属性名&#x3D;”属性值”]</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span>&#123;boder: <span class="hljs-number">5px</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span></code></pre></div></li></ul></li><li><p>伪类选择器</p><ul><li><p>语法：<code>元素:状态&#123;&#125;</code></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*超链接初始化状态：*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;<span class="hljs-attribute">color</span>:pink;&#125;<span class="hljs-comment">/*鼠标悬浮状态：*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;    <span class="hljs-attribute">color</span>:green;&#125;<span class="hljs-comment">/*正在访问状态：*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>&#123;    <span class="hljs-attribute">color</span>:blue;&#125;<span class="hljs-comment">/*访问过状态：*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;</code></pre></div></li></ul></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="字体、文本"><a href="#字体、文本" class="headerlink" title="字体、文本"></a>字体、文本</h3><ul><li><code>font-size</code>：字体大小</li><li><code>color</code>：文本颜色</li><li><code>text-algin</code>：对其方式</li><li><code>line-height</code>：行高</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><code>background</code>：设置背景，复合属性</li></ul><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul><li><code>border</code>：设置边框，复合属性</li></ul><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><ul><li><code>width</code>：宽度</li><li><code>height</code>：高度</li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><ul><li><p>用于控制布局</p></li><li><p><code>margin</code>：外边距</p></li><li><p><code>padding</code>：内边距</p></li><li><p>内边距和外边距是相对的，内边距会影响整个盒子的大小</p></li><li><p><code>box-sizing:border-box</code>：设置盒子的属性，让<code>width</code>和<code>height</code>就是最终盒子的大小</p></li><li><p><code>float</code>：浮动</p><ul><li><code>float:left</code>：左浮动</li><li><code>float:right</code>：右浮动</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HTML】HTML基础笔记</title>
    <link href="/archives/74c0bbe.html"/>
    <url>/archives/74c0bbe.html</url>
    
    <content type="html"><![CDATA[<h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><ul><li>HTML：用于搭建基础页面，展示页面的内容</li><li>CSS：用于美化页面，布局页面</li><li>JavaScript：控制页面元素，让页面有一些动态效果</li></ul><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>Hyper Text Markup Language 超文本标记语言</li><li>标记语言，不是编程语言</li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li>围堵标签：有开始标签和结束标签。如<code>&lt;html&gt;&lt;/html&gt;</code></li><li>自闭合标签：开始标签和结束标签在一起。如<code>&lt;br/&gt;</code></li><li>标签可以嵌套</li><li>在开始标签中可以定义属性，属性由键值对构成，值需要用引号（单双都可，最好双引号）引起来。如：<code>name=&quot;value&quot;</code></li><li>标签不区分大小写，建议小写</li></ul><h2 id="文件标签"><a href="#文件标签" class="headerlink" title="文件标签"></a>文件标签</h2><ul><li><code>&lt;!DOCTYPE html&gt;</code>：定义该文档是html文档</li><li><code>&lt;html&gt;</code>：根标签</li><li><code>&lt;head&gt;</code>：头标签。用于指定html文档的一些属性。引入外部的资源<ul><li><code>&lt;title&gt;</code>：标题标签（写在根标签下）</li></ul></li><li><code>&lt;body&gt;</code>：体标签<ul><li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>：中文网页声明编码（写在体标签下）</li></ul></li></ul><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><ul><li><p><code>&lt;!-- --&gt;</code> </p><ul><li>注释标签</li></ul></li><li><p><code>&lt;br&gt;</code>或<code>&lt;br/&gt;</code>，未来强制<code>&lt;br/&gt;</code></p><ul><li>换行标签</li><li>所有连续的空格或空行都会被算作一个空格。</li></ul></li><li><p><code>&lt;h1&gt;~&lt;h6&gt;</code></p><ul><li>标题标签</li><li>从<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>字体依次减小</li></ul></li><li><p><code>&lt;p&gt;</code></p><ul><li>段落标签</li><li>段落的行数依赖于浏览器窗口的大小。如果调节浏览器窗口的大小，将改变段落中的行数。</li></ul></li><li><p><code>&lt;hr&gt;</code></p><ul><li>显示一条水平线</li><li>属性：<ul><li><code>color</code>：颜色</li><li><code>width</code>：宽度 </li><li><code>size</code>：高度</li><li><code>align</code>：对齐方式<ul><li><code>center</code>：居中</li><li><code>left</code>：左对齐</li><li><code>right</code>：右对齐</li></ul></li></ul></li></ul></li><li><p><code>&lt;b&gt;</code></p><ul><li>字体加粗</li></ul></li><li><p><code>&lt;i&gt;</code></p><ul><li>斜体</li></ul></li><li><p><code>&lt;font&gt;</code></p><ul><li><p>字体标签，已过时</p></li><li><p>属性：</p><ul><li><code>color</code>：颜色</li><li><code>size</code>：大小</li><li><code>face</code>：字体</li></ul></li></ul></li><li><p>属性定义</p><ul><li><code>color</code>：<ul><li>英文单词：<code>red</code>，<code>green</code>，<code>blue</code></li><li><code>rgb(a,b,c)</code>：a,b,c取值：0~255</li><li><code>#abc</code>：a,b,c取值：00~FF</li></ul></li><li><code>width</code>：<ul><li>数值：<code>width=20</code>，默认单位px</li><li>百分比：<code>width=50%</code>，是指占父元素的百分比</li></ul></li></ul></li></ul><h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><ul><li><p><code>&lt;img&gt;</code></p><p>属性：</p><ul><li><code>src</code><ul><li>图片的地址</li><li>相对地址：以<code>./</code>开头的路径<ul><li><code>./</code>代表当前目录  <code>./image/1.jpg</code> (如果前面没有<code>./</code>默认<code>./</code>)</li><li><code>../</code>代表上一级目录</li></ul></li><li>绝对地址：目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。</li></ul></li><li><code>alt</code><ul><li>未正确加载图片时，显示的文字</li></ul></li><li><code>align</code><ul><li>对齐方式（<code>middle</code>、<code>top</code>、<code>bottom</code>）</li><li>在HTML 4中 <code>align</code> 属性已废弃，HTML5 已不支持该属性，可以使用 CSS 代替。</li></ul></li><li><code>width</code><ul><li>宽度</li></ul></li><li><code>height</code><ul><li>高度</li></ul></li><li><code>boder</code><ul><li>边框</li></ul></li></ul></li></ul><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><ul><li><code>&lt;ol&gt;&lt;li&gt;...&lt;/li&gt;  &lt;li&gt;...&lt;/li&gt;&lt;/ol&gt;</code><ul><li>有序列表</li><li><code>type</code>属性指定有序编号的样式<ul><li><code>type=&quot;A&quot;</code>  展示ABCD</li><li><code>type=&quot;1&quot;</code>  展示1234</li></ul></li><li><code>start</code>属性指定开始的编号<ul><li><code>start=&quot;C&quot;</code> 展示CDEF</li></ul></li></ul></li><li><code>&lt;ul&gt;&lt;li&gt;...&lt;/li&gt;  &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;</code><ul><li>无序列表</li><li><code>type</code>属性指定无序小圆点的样式，<strong>已过时</strong>，建议用CSS修改<ul><li><code>type=&quot;disc&quot;</code> 展示实心圆点</li><li><code>type=&quot;circle&quot;</code> 展示空心圆圈</li><li><code>type=&quot;square&quot;</code> 展示实心矩形</li></ul></li></ul></li></ul><h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><ul><li><p><code>&lt;a&gt;</code></p><ul><li>超链接</li><li>属性：<ul><li><code>href</code> ：指定访问资源的URL</li><li><code>target</code>：指定资源的打开方式</li></ul></li><li><code>target=&quot;_self&quot;</code> 当前窗口打开</li><li><code>target=&quot;_blank&quot;</code>新窗口打开</li></ul></li><li><p>和<code>&lt;img&gt;</code>标签结合使用</p><ul><li><p><code>&lt;a href=&quot;...&quot;&gt;&lt;img src=&quot;...&quot;&gt;&lt;/a&gt;</code> </p></li><li><p>推荐用JS实现</p></li></ul></li></ul><h2 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a>块标签</h2><ul><li><code>&lt;span&gt;</code><ul><li>无含义，方便CSS控制样式</li><li>无换行</li></ul></li><li><code>&lt;div&gt;</code><ul><li>有换行</li></ul></li></ul><h2 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h2><ul><li><code>&lt;header&gt;</code><ul><li>头，无实际作用，HTML5中为了方便阅读</li></ul></li><li><code>&lt;footer&gt;</code><ul><li>尾</li></ul></li></ul><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><ul><li><p><code>&lt;table&gt;</code></p><ul><li>定义表格，放在最外边</li><li>属性：<ul><li><code>boder</code>：边框大小，显示两条线，默认无边框</li><li><code>width</code>：宽度</li><li><code>cellpadding=&quot;0&quot;</code>，单元格边距，边沿和内容之间的空白</li><li><code>cellspacing=&quot;0&quot;</code>，单元格间距，让两条线合成一条</li><li><code>bgcolor</code>：背景色</li><li><code>align</code>：对齐方式</li></ul></li></ul></li><li><p><code>&lt;tr&gt;</code></p><ul><li>定义行</li><li>属性：<ul><li><code>boder</code>：边框大小，显示两条线</li><li><code>bgcolor</code>：背景色</li><li><code>align</code>：对齐方式<ul><li><code>aligin=&quot;center&quot;</code> ，整行中每个数据都居中</li></ul></li></ul></li></ul></li><li><p><code>&lt;td&gt;</code></p><ul><li>定义每行的数据</li><li>属性：<ul><li><code>colspan=&quot;2&quot;</code>，占两列</li></ul></li></ul></li><li><p><code>&lt;th&gt;</code></p><ul><li>定义表头单元格</li></ul></li><li><p><code>&lt;caption&gt;</code></p><ul><li>定义表格标题</li></ul></li><li><p><code>&lt;thead&gt;</code></p><ul><li>定义表格头部分，方遍CSS控制样式</li></ul></li><li><p><code>&lt;tfoot&gt;</code></p><ul><li>定义表格尾部分，方便CSS控制样式</li></ul></li></ul><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><ul><li><p><code>&lt;form&gt;</code></p><ul><li>表单，定义采集用户数据的范围</li><li>属性：<ul><li><code>action</code>：指定提交数据的URL</li><li><code>method</code>：指定提交方式，一共7种，常用2种<ul><li><code>get</code>：<ul><li>请求参数会在地址栏中显示，封装到请求行中</li><li>请求参数的大小是有限制的</li><li>不安全</li></ul></li><li><code>post</code>：<ul><li>请求参数会封装在请求体中（HTTP）</li><li>请求参数的大小是没有限制的</li><li>安全</li></ul></li></ul></li></ul></li><li>表单项(如<code>&lt;imput&gt;</code>、<code>&lt;select&gt;</code>)中的数据要想被提交，必须指定其<strong>name</strong>属性</li></ul></li><li><p><code>&lt;input&gt;</code></p><ul><li>输入标签，可以通过<strong>type</strong>属性改变显示的样式</li><li><code>&lt;lable&gt;</code>标签，指定输入项的文字信息<ul><li><code>&lt;lable&gt;</code>标签<strong>for</strong>属性的值，需要与该<code>&lt;lable&gt;</code>标签的所提示<code>&lt;input&gt;</code>标签<strong>id</strong>属性的值一致。对应后鼠标点击<code>&lt;lable&gt;</code>标签会获取<code>&lt;input&gt;</code>标签的焦点。</li></ul></li></ul><p>在<code>&lt;input&gt;</code>标签中，<code>type</code>属性的值不同会显示不同样式：</p><ul><li><code>type=&quot;text&quot;</code><ul><li>文本输入框，默认宽度20</li><li><strong>checked</strong>属性指定默认值，其值是显示出来的</li><li><strong>placeholder</strong>属性指定提示信息，其值在内容变化后消失</li></ul></li><li><code>type=&quot;password&quot;</code><ul><li>密码输入框，密文显示</li><li><strong>checked</strong>属性指定默认值，其值是显示出来的</li><li><strong>placeholder</strong>属性指定提示信息，其值在内容变化后消失</li></ul></li><li><code>type=&quot;radio&quot;</code><ul><li>单选框，需要<strong>name</strong>属性和<strong>value</strong>属性</li><li>多个单选框要想实现单选效果，<strong>name</strong>属性的值应该相同</li><li>给单选框指定<strong>value</strong>属性，用于提交数据</li><li><strong>checked</strong>属性指定默认值，checked可以没有值</li></ul></li><li><code>type=&quot;checkbox&quot;</code><ul><li>复选框，需要<strong>name</strong>属性和<strong>value</strong>属性</li><li>多个复选框要想实现复选效果，<strong>name</strong>属性的值应该相同</li><li>给复选框指定<strong>value</strong>属性，用于提交数据</li><li><strong>checked</strong>属性指定默认值，checked可以没有值</li></ul></li><li><code>type=&quot;file&quot;</code><ul><li>文件，需要配合JS</li></ul></li><li><code>type=&quot;hidden&quot;</code><ul><li>隐藏域，用于提交提示信息</li></ul></li><li><code>type=&quot;submit&quot;</code><ul><li>提交按钮，用于提交表单</li></ul></li><li><code>type=&quot;button&quot;</code><ul><li>普通按钮，需要配合JS</li></ul></li><li><code>type=&quot;img&quot;</code><ul><li>图片提交按钮，可以提交表单</li><li><strong>src</strong>属性，指定图片的路径</li></ul></li><li><code>type=&quot;date&quot;</code><ul><li>日期：年月日</li></ul></li><li><code>type=&quot;datetime-local&quot;</code></li><li>日期：年月日时分</li><li><code>type=&quot;number&quot;</code><ul><li>只能输入数字</li></ul></li></ul></li><li><p><code>&lt;select&gt;</code></p><ul><li>下拉列表，放在外边定义下拉列表的范围</li><li><code>&lt;option&gt;</code>标签：下拉列表的每一项<ul><li>给<code>&lt;option&gt;</code>指定<strong>value</strong>属性，用于提交数据</li></ul></li><li><strong>selected</strong>属性指定默认值，selected可以没有值</li></ul></li><li><p><code>&lt;textarea&gt;</code></p><ul><li>文本域</li><li>属性：<ul><li><code>cols</code>：指定行数</li><li><code>rows</code>：指定列数</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献阅读03-基于改进TextRank的关键词抽取算法</title>
    <link href="/archives/bd3bc374.html"/>
    <url>/archives/bd3bc374.html</url>
    
    <content type="html"><![CDATA[<h1 id="基于改进TextRank的关键词抽取算法-张莉婧"><a href="#基于改进TextRank的关键词抽取算法-张莉婧" class="headerlink" title="基于改进TextRank的关键词抽取算法_张莉婧"></a>基于改进TextRank的关键词抽取算法_张莉婧</h1><h1 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h1><p><a href="https://tsg.buct.edu.cn/https/77726476706e69737468656265737421fbf952d2243e635930068cb8/KCMS/detail/detail.aspx?dbname=cjfd2016&filename=byxb201604013&dbcode=cjfq">论文地址</a>（需要北化校园网）</p><h2 id="论文思路与笔记"><a href="#论文思路与笔记" class="headerlink" title="论文思路与笔记"></a>论文思路与笔记</h2><h3 id="一、问题的描述"><a href="#一、问题的描述" class="headerlink" title="一、问题的描述"></a>一、问题的描述</h3><ul><li><p>关键词提取的概念：关键词抽取就是从一篇文档中抽取出能表达文章主题的词组</p></li><li><p>关键词提取的分类：有监督的和无监督</p></li><li><p>TFIDF算法基本思想：若某个词或短语在一篇文章中出现的次数较高( 即 TF 的值较高) ，但在其他文章中很少出现，我们就认为该词或者短语具有很好的分类能力，将其称为该篇文章的关键词。</p></li><li><p>TFIDF算法的缺点：TFIDF 算法没有涉及语义间的关系和词语本身的特性。</p></li><li><p>TFIDF算法的改进：</p><ul><li>徐振强等通过引入词语的分布均衡度和首次出现位置等特征，提出了一种改进的 TF－IDF 算法。其改进后的算法虽然有了一定的提高，但这种效果只有在提取长篇文章关键词时才表现得明显，对于提取短篇文章的关键词效果并不明显。</li><li>张雯将TFIDF 算法与基于语义关系的TextRank算法相结合，提出了 TFIDF -TextRank 算法，但该方法在提高准确率的同时增加了时间的消耗。</li></ul></li><li><p>TextRank算法，TextRank算法的不足</p></li><li><p>TextRank算法的改进：</p><ul><li>罗庆平在原有的 TextRank算法中加入了词语位置权重，既考虑了语义间的关系，又考虑了词语本身的位置，显著提高了关键词的准确率。但其单独考虑词语位置的权重不够全面，人为确定的权重也不够准确。</li><li>本文将 TFIDF 算法、词语位置、词语长度以及词性 4 种属性结合，采用 G1 赋权法进行以上属性的权重计算，将得到的“综合权重”与 TextRank算法结合，对 TextRank算法进行了改进。即：TextRank-CM算法</li></ul></li></ul><h3 id="二、数学模型"><a href="#二、数学模型" class="headerlink" title="二、数学模型"></a>二、数学模型</h3><h4 id="TextRank算法"><a href="#TextRank算法" class="headerlink" title="TextRank算法"></a>TextRank算法</h4><ul><li>TextRank 算法是一种基于图模型的关键词抽取算法。该算法的核心是衡量图中每个点的全局权重。而权重又通过连接这个点与其他点的边决定。与此同时，全局权重越大的点，与其连接的边的效力也越高。</li><li>TextRank算法的公式、调节系数</li></ul><h4 id="TextRank-CM-算法"><a href="#TextRank-CM-算法" class="headerlink" title="TextRank-CM 算法"></a>TextRank-CM 算法</h4><ul><li>将词语本身的属性及最经典的 TFIDF 算法引入TextRank 算法中，并通过 G1 赋权法对各属性赋予不同的权重</li></ul><h3 id="三、算法描述"><a href="#三、算法描述" class="headerlink" title="三、算法描述"></a>三、算法描述</h3><h3 id="四、实验分析"><a href="#四、实验分析" class="headerlink" title="四、实验分析"></a>四、实验分析</h3><ul><li><p>数据集：知网论文100篇</p></li><li><p>结论：准确率、召回率和F值均有所提升，时间开销更大</p></li></ul><h3 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h3><ul><li>针对中文关键词抽取准确度的问题，提出了TFIDF -TextRank  算法。该算法通过 G1 赋权法对词语的属性及TFIDF 值的权重进行了优化，并将其作 为 TextRank算 法 的 初 始 权 重，对 原 始 的TextRank算法进行了改进。TFIDF -TextRank 算法在提高关键词抽取准确率的同时增加了时间的消耗。所以，下一步将研究如何缩短时间。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
      <tag>文献</tag>
      
      <tag>关键词提取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【考研】2020年北化计算机考研经验分享</title>
    <link href="/archives/9dc8f4d8.html"/>
    <url>/archives/9dc8f4d8.html</url>
    
    <content type="html"><![CDATA[<h1 id="北化考研经验分享"><a href="#北化考研经验分享" class="headerlink" title="北化考研经验分享"></a>北化考研经验分享</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul><li>北化考本校专硕，科目数二英二数据结构，属于所有学校中计算机考研的最低配。再加上考本校的buff，可以说buff叠满、考研难度最小。</li></ul><h2 id="初试"><a href="#初试" class="headerlink" title="初试"></a>初试</h2><h3 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h3><h4 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h4><ul><li>《肖秀荣考研政治知识点精讲精练》</li><li>《肖秀荣考研政治1000题》</li><li>《肖秀荣考研政治冲刺8套卷》</li><li>《肖秀荣考研政治预测4套卷》</li><li>《考研政治冲刺背诵笔记》（徐涛）</li><li>《考研政治形势与政策及当代世界政治与经济》（徐涛）</li></ul><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><ul><li>徐涛强化班</li><li>徐涛冲刺班</li></ul><h4 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h4><ul><li>政治是四门考试中投入产出比最高的一门。政治成绩77分。开始时间不要太早，如果其他科目复习进度较快，时间不紧张的话，9月开始就可以；如果其他科目复习进度较慢，时间紧张的话，10月开始完全够用，但是，这也就需要每天在政治上花更多的时间，并且要有更好的记忆力。个人推荐9月开始，每天大概一个半小时。</li><li>推荐徐涛老师的视频课程，徐涛老师的视频课程风趣幽默，且把政治这门较为枯燥的课程讲解的比较透彻。基础班不用看，完全浪费时间，从强化班开始看。参考书推荐肖秀荣的精讲精练。不用担心肖秀荣的参考书和徐涛老师的视频不配套的问题，课程和参考书绝大多数时候是完全匹配的，只有少数的章节内容的提法不一样，但是大体的思想是一样的。</li><li>在看完视频课的每一章节之后，紧接着写肖秀荣的1000题中这章的题，只做选择题（包括单选和多选）就可以，大题完全不需要写，如果你时间非常充裕，可以看看大题的思路，但是背下来大题的答案就非常没有必要了。由于政治这门课的特点，可能听视频课的时候很容易溜号走神。如果你发现自己总是走神，那么可以在听课的同时对照着写一下肖秀荣的1000题，这样可以很有效的控制自己集中注意力。考研政治选择题大多都是细碎的知识点，要在平时的学习中多多记忆，多多背诵。</li><li>强化班听完后可以听一下冲刺班，用到的参考书是徐涛的冲刺背诵笔记（薄薄一小本）。冲刺班的主要目的是梳理思路，强化政治课程的脉络框架，还有就是把所有出现的会议、文章、标志性事件进行梳理，强化记忆。这个阶段主要是梳理、加深记忆。考研政治的选择题大多靠平时的积累，背诵。</li><li>形势与政策的内容大多与当年发生的重大事件有关，徐涛的《考研政治形势与政策及当代世界政治与经济》基本都会涵盖，拿到这本薄薄的小册子之后，快速过一遍。记不住也没关系，形势与政策的内容在肖八肖四的选择题中会有所体现。</li><li>政治的重点在于肖八肖四。2021年考研政治大题几乎都可以在肖四上面找到原题。肖老在考研大题的出题思路上把握的非常准确。（肖老，yyds！）11月肖八上市之后，快速刷完肖八的选择题，大题可以先放放。时间充裕，看看大题的思路。12月肖四上市，这时候不管政治复习到什么程度，都应该放下政治的其他学习，全力攻克肖四。选择题控制时间，练习准确度；对于大题，直接开背。如果时间很充足，肖八的大题也可以看一看。在政治考试前，最好做到肖四的四套大题滚瓜烂熟。考试中如果出现原题，直接开始默写，就算没有出现原题，心里也对答题的思路有基本的方法论。</li></ul><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><h4 id="参考书-1"><a href="#参考书-1" class="headerlink" title="参考书"></a>参考书</h4><ul><li>《张剑黄皮书历年考研英语真题》</li></ul><h4 id="视频-1"><a href="#视频-1" class="headerlink" title="视频"></a>视频</h4><ul><li>唐迟语法课</li><li>唐迟阅读的逻辑（讲的是历年阅读真题）</li><li>刘晓燕写作课（讲的是如何写出属于自己的模板）</li></ul><h4 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h4><ul><li>六月之前，背单词背单词背单词。词汇量是考研英语的基础，十分重要，需要长线准备，直到上考场前都要坚持背单词。我用的是单词软件——墨墨背单词。软件中选择一本要背的单词书（我选择的是恋词，虽然我没有买这本书），然后设定好每天要背诵的词汇量，然后每天坚持打卡。初期每天30个50个，然后慢慢增加。我英语二拿了79分，这和前期坚持背单词是离不开的。</li><li>墨墨背单词这款软件可能需要你付费，我当时花了80元左右，但是我觉得还是很值得的，这款软件我现在还在用。如果你使用其他的单词软件也完全可以，最重要的是坚持背单词，坚持坚持坚持。用软件背单词有两个重要原则，一是坚持，不要放松；二是实事求是，看到这个单词会就是会，记不起来就是不会，不要看到单词觉得有点印象就算自己会了。</li><li>关于背单词，我当时（2月份）买了英语单词红宝书，当时打算攻克每天一个单元，但是我发现很难坚持下去。我不建议去刷恋恋有词这门单词课，我当时看了18年经典版的十几个单元，感觉记忆效果很差。而且这门课的老师讲课风格我很不喜欢，感觉废话连篇。这门课的精髓在于词根词缀，如果感兴趣并且时间特别充裕的话可以快速过一遍。</li><li>进入6月，最主要是攻克语法和长难句。唐迟老师的语法课程深入浅出，适合有一点点语法基础的同学。如果说连最最基础的主谓宾都不清楚的话建议去买一本句句真研，再配合与之配套的视频课。句句真研这本书适合一点基础都没有的同学慢慢学习语法知识，我当时买了一本，发现实在太基础了，根本看不下去。如果你有一点点英语水平，看看唐迟的语法课完全够了。</li><li>如果你的单词完整的背过1-2遍，并且有了一定的语法功底，那么就可以开始做阅读真题了。由于我考的是英语二，英语真题较少，所以我也买了英语一的真题。先做英语一再做英语二，做完英语一之后应对英语二游刃有余。建议先看唐迟的阅读方法课（1-2节，用早年的真题讲解考研阅读的方法论），对考研阅读的文章结构、题型等有了基本的了解并且对唐迟的阅读做题方法十分了解之后，可以开始做真题阅读。早些年的阅读可以不控制每篇阅读的时间，力求读懂文章的每句话，筛选出文章中出现的生词。</li><li>读懂文章后，可以用唐迟的方法，先看问题，再看文章中与之对应的段落，分析每道题的题型（主旨题、细节题、作者态度题等等）。快速回忆这种题型的解题思路，并得出答案。每天吃透1-2篇阅读，包括长难句、生词、行文逻辑。当你做了几年阅读之后，可以开始刻意控制做阅读的时间，提高自己的阅读速度和准确率。</li><li>作文听刘晓燕老师的作文课，根据课程内容整理出自己的模板（包括大作文，小作文）。我当时看了下王江涛的作文书，模板太多了背不下来就放弃了。根据刘晓燕作文课来整理自己自己的模板完全够用。小三门可看可不看，单词量足够的话，临场发挥完全可以。用真题练练手就行。</li><li>真题留出几套等到考前全真模拟，感受下自己的答题速度。</li></ul><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="参考书-2"><a href="#参考书-2" class="headerlink" title="参考书"></a>参考书</h4><ul><li><p>《汤家凤高数辅导讲义》</p></li><li><p>《汤家凤1800题》</p></li><li><p>《李、王-考研数学全书基础篇》</p></li><li><p>《李、王-线性代数辅导讲义》</p></li><li><p>《李、王-考研数学全书》</p></li><li><p>《李永乐最后6套卷》</p></li></ul><h4 id="视频-2"><a href="#视频-2" class="headerlink" title="视频"></a>视频</h4><ul><li>汤家凤高数基础班</li><li>汤家凤高数提高班</li><li>李永乐线代基础班</li><li>李永乐线代提高班</li><li>汤家凤真题</li></ul><h4 id="经验-2"><a href="#经验-2" class="headerlink" title="经验"></a>经验</h4><ul><li>早早打基础，越早越好，六月前看完汤家凤基础班，做完1800题中的高数部分看完李永乐的线代基础班，做完1800题中的线代部分。实事求是，不要着急。视频课要看懂，记好笔记。1800题很基础，争取每一道都不放过。刚开始有点劝退，放平心态，之后做着会轻松点。</li><li>六月左右开始听提高班的课程，刷1800题里提高篇。同时看考研数学复习全书，这本书要好好看，理解吃透。</li><li>10月开始做真题，每天一套，做完看答案，可以参考下别的老师（比如张宇）的真题答案，体会下不同的思路。</li><li>11月左右各种押题卷开始上市，建议有时间都做一做。我当时对于数学心态大崩，看到数学非常头痛，基础不是很好，也没怎么刷押题卷，最后的分数少的可怜。</li><li>建议多看看其它学长学姐的经验贴，我没资格跟大家分享数学经验。</li></ul><h3 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h3><h4 id="参考书-3"><a href="#参考书-3" class="headerlink" title="参考书"></a>参考书</h4><ul><li>《王道数据结构》</li><li>《严蔚敏数据结构教材》</li><li>《842真题》</li></ul><h4 id="视频-3"><a href="#视频-3" class="headerlink" title="视频"></a>视频</h4><ul><li>《王道数据结构》</li></ul><h4 id="经验-3"><a href="#经验-3" class="headerlink" title="经验"></a>经验</h4><ul><li>北化专业课只考数据结构，所以不用复习的太早，7月左右开始就够用了。王道书从头到尾刷一遍，不会的题不用死抠。北化的大题不会太难，达不到王道难题那种程度。第一遍看王道书要细致，配合每一节的课后题理解每个知识点和答题方法。最好准备一个本子或者一沓A4用来写大题的代码。</li><li>第二遍快速过一遍王道书和每一节之前错的题目。配合着考纲来学习，考纲中不涉及的可以忽略过去。第二遍最好把模板代码背下来，考试题大多都是模板题或者对模板题稍加修改即可。</li><li>大概10月开始做真题。真题我是从往届学长那里买的。王道其它帖子里会有学长学姐的群。价格略贵，120+，而且内容错误很多。做真题时会发现有些知识点王道中是没有的，比如矩阵三元组。这时我们需要配合《严蔚敏数据结构》来补充这些知识点。</li><li>真题中可能用到离散数学的知识，但是不会多。建议把离散数学中关系理论有关的知识过一遍。每年的真题题型和数目都可能发生小变动，但是知识点一直都是考纲中的内容。</li></ul><h2 id="复试"><a href="#复试" class="headerlink" title="复试"></a>复试</h2><ul><li>时间2021年4月初，形式是线上复试，只有面试，10min。用的是腾讯会议，双机位。每组5名老师，轮流提问。学生看不到老师，只能听到老师们的声音。</li><li>先抽两个必答题，必答题一道是计组一道是操作系统。然后每个老师开始随机问问题。英文问了两个问题。介绍家乡、谈谈本科最impressive的课程。然后问了成绩单上的课程。估计是我数学成绩太差，老师问了问我数学的知识。其它科目大致问了计组、操作系统、数据结构、数据库、c++、java、网络、人工智能。最后问了做过的项目和毕设。</li><li>计组、操作系统、数据结构和计网问的最多，其它问的时间比较短。项目不听介绍，直接问用了什么框架。往年复试题目有整理，看我之前的<a href="https://zhangtuo.online/2021/03/31/%E5%BE%80%E5%B9%B4%E5%A4%8D%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">blog</a>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献阅读02-TFIDF算法研究综述</title>
    <link href="/archives/3b21f69.html"/>
    <url>/archives/3b21f69.html</url>
    
    <content type="html"><![CDATA[<h1 id="TFIDF算法研究综述-施聪莺"><a href="#TFIDF算法研究综述-施聪莺" class="headerlink" title="TFIDF算法研究综述_施聪莺"></a>TFIDF算法研究综述_施聪莺</h1><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><p><a href="https://tsg.buct.edu.cn/https/77726476706e69737468656265737421fbf952d2243e635930068cb8/KCMS/detail/detail.aspx?dbname=cjfd2009&filename=jsjy2009s1057">文章地址</a>（需要北化校园网）</p><h2 id="论文结构与主要内容"><a href="#论文结构与主要内容" class="headerlink" title="论文结构与主要内容"></a>论文结构与主要内容</h2><h3 id="一、TFIDF算法历史"><a href="#一、TFIDF算法历史" class="headerlink" title="一、TFIDF算法历史"></a>一、TFIDF算法历史</h3><ul><li>IDF的首次提出、主要思想、权重的计算公式</li><li>TFIDF的首次提出、主要思想、权重的计算公式</li></ul><h3 id="二、TFIDF算法改进"><a href="#二、TFIDF算法改进" class="headerlink" title="二、TFIDF算法改进"></a>二、TFIDF算法改进</h3><h4 id="2-1-经典公式固有缺陷的改进"><a href="#2-1-经典公式固有缺陷的改进" class="headerlink" title="2.1 经典公式固有缺陷的改进"></a>2.1 经典公式固有缺陷的改进</h4><ul><li>数据集倾斜<ul><li>数据集关于类别的分布是偏斜的，各类文档数目不均衡</li><li>当某类文档相对较少时，IDF基本不起抑制作用</li><li>CTD来改进TFIDF</li></ul></li><li>类间、类内分布偏差<ul><li>考虑类间、类内分布偏差（改进1）</li></ul></li><li>其他改进<ul><li>TFIEFIWF公式（改进2）</li><li>引入方差的TFIFIWF公式（改进3）</li></ul></li></ul><h4 id="2-2-领域适应性改进"><a href="#2-2-领域适应性改进" class="headerlink" title="2.2 领域适应性改进"></a>2.2 领域适应性改进</h4><ul><li>中文组合型歧义切分<ul><li>改进TFIDF来消除中文分词中组合型歧义分割，并且对TFIDF进行了重新定义</li></ul></li><li>聊天文本权重计算<ul><li>适应短文本的处理能力</li></ul></li><li>网页权重计算<ul><li>加入网页特征因子，改进TFIDF,得到基于网页特征TFIDF算法</li></ul></li></ul><h4 id="2-3-TFIDF算法新应用领域概述"><a href="#2-3-TFIDF算法新应用领域概述" class="headerlink" title="2.3 TFIDF算法新应用领域概述"></a>2.3 TFIDF算法新应用领域概述</h4><p>特征选择、领域词典构造、用户兴趣模板构建</p><h3 id="三、实验及其分析"><a href="#三、实验及其分析" class="headerlink" title="三、实验及其分析"></a>三、实验及其分析</h3><p>提出了基于频率的TFIDF改进算法：将TFIDF中TF由特征项出现的次数改为特征项出现的频率（改进4）</p><h4 id="3-1-实验语料库"><a href="#3-1-实验语料库" class="headerlink" title="3.1 实验语料库"></a>3.1 实验语料库</h4><ul><li>复旦大学计算机信息与技术系国际数据库中心自然语言处理小组</li><li>搜狗实验室基于搜狐分类的目录</li></ul><h4 id="3-2-分类算法"><a href="#3-2-分类算法" class="headerlink" title="3.2 分类算法"></a>3.2 分类算法</h4><ul><li><p>空间向量模型先采用余弦度量的方法来计算待分类的文档与每一个类别之间的相似度然后将文档的类别判定为与其相似度最大那个类别</p></li><li><p>相似度计算式</p></li></ul><h4 id="3-3-实验结果"><a href="#3-3-实验结果" class="headerlink" title="3.3 实验结果"></a>3.3 实验结果</h4><p>文本分类系统的优劣，性能指标:</p><ul><li>召回率R<ul><li>被正确分类的文档数和被测试文档总数的比例,即该类样本被分类器正确识别的概率</li></ul></li><li>准确率P<ul><li>正确分类的文档数与被分类器识别为该类别的文档数的比率，即分类器做出正确决策的概率</li></ul></li><li>F1测试值<ul><li>2RP&#x2F;(R+P)</li></ul></li></ul><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul><li><p>TDFIDF算法的F1测试值最低，各改进算法F1测试值均有提高。</p></li><li><p>对于各项改进算法，由于在某某某方面做出了改进，所以F1测试值有所提高。</p></li><li><p>效果最好的算法时间复杂度最高。</p></li></ul><p>四、结语</p><ul><li><p>从TFIDF的多种改进算法可以看出:引入方差的TFIWFIWF算法和TFIDF频率算法优于其他几种改进算法。但是引入方差的TFIWFIWF算法计算复杂度高于TFIDF频率算法。并且TFIDF算法通常根据特定领域及需求稍作改进即能取得令人较为满意的效果。</p></li><li><p>另外通过实验数据我们也不难发现特征项权重的赋予对于文本分类的效果存在较大的影响</p></li><li><p>如何在实验中调节TFIDF的各项参数以适应实际需求,目前仍无一个通用法则,需要读者自己在实践中尝试</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
      <tag>文献</tag>
      
      <tag>关键词提取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献阅读01-新闻文本关键词提取算法研究与实现</title>
    <link href="/archives/b7cabb8d.html"/>
    <url>/archives/b7cabb8d.html</url>
    
    <content type="html"><![CDATA[<h1 id="新闻文本关键词提取算法研究与实现-田脉"><a href="#新闻文本关键词提取算法研究与实现-田脉" class="headerlink" title="新闻文本关键词提取算法研究与实现_田脉"></a>新闻文本关键词提取算法研究与实现_田脉</h1><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><ul><li><a href="https://tsg.buct.edu.cn/https/77726476706e69737468656265737421fbf952d2243e635930068cb8/KCMS/detail/detail.aspx?filename=1019863619.nh&dbname=CMFDTEMP">文章地址</a>（需要北化校园网）</li></ul><h2 id="论文结构及主要内容"><a href="#论文结构及主要内容" class="headerlink" title="论文结构及主要内容"></a>论文结构及主要内容</h2><h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><h4 id="一、研究背景及意义"><a href="#一、研究背景及意义" class="headerlink" title="一、研究背景及意义"></a>一、研究背景及意义</h4><ul><li>互联网上新闻数据高速增长，新闻标题党严重，影响用户的阅读体验</li><li>关键词的概念，关键词的应用场景，关键词提取的用处</li><li>人工关键词提取的缺点，推出新闻类关键词提取的研究意义</li></ul><h4 id="二、国内外研究现状"><a href="#二、国内外研究现状" class="headerlink" title="二、国内外研究现状"></a>二、国内外研究现状</h4><h5 id="国外研究现状"><a href="#国外研究现状" class="headerlink" title="国外研究现状"></a>国外研究现状</h5><ul><li>关键词自动提取的开始</li><li>有监督提取方法——建立语料库<ul><li>二分类方向</li><li>语言模型方向</li></ul></li><li>半监督提取方法</li><li>无监督提取方法<ul><li>基于统计的方法：TF-IDF</li><li>基于网络图的方法：TestRank</li><li>基于主题模型的方法：LDA</li></ul></li></ul><h5 id="国内研究现状"><a href="#国内研究现状" class="headerlink" title="国内研究现状"></a>国内研究现状</h5><ul><li>汉语的独特性，不能照搬英语</li><li>基于TF-IDF的改进算法</li><li>基于语义的网络图的算法</li><li>运用机器学习进行关键词提取</li></ul><h4 id="三、研究内容"><a href="#三、研究内容" class="headerlink" title="三、研究内容"></a>三、研究内容</h4><ul><li>有监督、半监督、无监督的特点；无监督关键词提取方法的分类；本文针对新闻类文本的改进</li><li>本文的研究的对象、目的；研究的主要内容、方法；研究的数据源</li><li>研究的重难点：如何将卡方检验、齐普夫定律与 TF-IDF 相结合，如何将 TF-<br>IDF，TextRank，LDA 三种关键词算法融合为新的算法模型。</li></ul><h4 id="四、组织结构"><a href="#四、组织结构" class="headerlink" title="四、组织结构"></a>四、组织结构</h4><ul><li>介绍论文每一章节的主要内容</li></ul><h3 id="第一章-关键词提取研究"><a href="#第一章-关键词提取研究" class="headerlink" title="第一章 关键词提取研究"></a>第一章 关键词提取研究</h3><h4 id="第一节-关键词提取算法介绍"><a href="#第一节-关键词提取算法介绍" class="headerlink" title="第一节  关键词提取算法介绍"></a>第一节  关键词提取算法介绍</h4><h5 id="一、TF-IDF算法"><a href="#一、TF-IDF算法" class="headerlink" title="一、TF-IDF算法"></a>一、TF-IDF算法</h5><ul><li>一种基于词频统计的方法，根据词频（TF）和逆文档频率（IDF）计算文本中词语的关键性，用于评估一个 词语对于语料库特定文本的重要程度</li><li>TF-IDF 的算法原理是：一个词语在目标文本中出现的概率越大，同时在相应的语料库其他文本中出现的概率越小，那么，该词语对于目标文本越重要，越能传达目标文本的语义</li><li>TF：词频，指某个词语在目标文本中出现的次数</li><li>IDF：逆文档频率，是指语料库中文本总数 N 与语料库中包含词 i 的所有文本数量𝑛的比值再取对数（防止分母为 0，因此对𝑛做加1 处理）</li><li>TF-IDF 的计算公式：TF-IDF&#x3D;TF*IDF；TF-IDF 值越大，对应的词语就越有可能是文本 j 的关键词</li></ul><h5 id="二、TextRank算法"><a href="#二、TextRank算法" class="headerlink" title="二、TextRank算法"></a>二、TextRank算法</h5><ul><li><p>TextRank 算法来源于 Google 的 PageRank 算法，PageRank 是一种网站排名算法，它的 PageRank 值是用来衡量网站质量的重要指标。TextRank 算法将一篇文本分割为若干组成词语，然后构建词图模型，类似于 PageRank 算法中的各个网页构成网络图。利用词语构造的网络图发掘词语之间的联系程度进行打分，从而根据分数排序提取出关键词。</p></li><li><p>构建的词图分为无权图与有权图。如果两个顶点之间有固定权重就构成了有权图。</p></li><li><p>TextRank 算法流程：<br>1）构造候选词表 S&#x3D;{c1，c2，…，cn}<br>2）由 1）的候选词表构造关键词图 G&#x3D;(V,E)，然后利用共现关系构造词图的边。假设共现窗口为 K，最多共现 K 个词语<br>3） 依据迭代法直到收敛，得到每个词语的得分<br>4）根据得分高低排序，提取前 m 个作为提取的关键词</p></li></ul><h5 id="三、LDA主题模型算法"><a href="#三、LDA主题模型算法" class="headerlink" title="三、LDA主题模型算法"></a>三、LDA主题模型算法</h5><ul><li><p>该方法的理论基础是贝叶斯理论。LDA 根据词的共现信息的分析，拟合出词语—文本—主题的分布，进而将词、文本都映射到一个语义空间中</p></li><li><p>主题模型认为每个文本拥有一个或多个主题，而每个主题都有对应的词分布，通过概率选取出主题，可以得到每个文本的分布。主题模型将没有直接联系的词语与文档使用主题将两者串联起来，一个表达三者联系的经典公式</p></li><li><p>LDA 模型的训练过程如下：<br>1）对文本分词、词性过滤、去停用词等初始化后，对所有文本中的所有词语 x，<br>随机赋予一个主题 t。<br>2）再次读取语料库，对语料库中所有词语使用 Gibbs 采样重新处理并更新。<br>3）重复 2），直到吉布斯采样收敛。<br>4）统计主题—词语的分布矩阵。<br>经过上面的训练，得到了一个 LDA 模型。接下来对新文本的主题进行预估，过<br>程如下：<br>1）对文本分词、词性过滤、去停用词等初始化后，对当前文本中的所有词语 x，<br>随机选取一个主题 t 赋予它。<br>2）读取当前文本，对其进行 Gibbs 采样，重新采样主题。<br>3）重复 2），直到吉布斯采样收敛。<br>4）统计文本—主题分布矩阵。<br>经过以上两个流程，得到了文本—主题分布矩阵和主题—词语分布矩阵。可以利<br>用这些信息计算文本与词的相似度，获得文本最相似的词语列表，最终获得文本的关<br>键词。</p></li></ul><h4 id="第二节-实验数据"><a href="#第二节-实验数据" class="headerlink" title="第二节  实验数据"></a>第二节  实验数据</h4><h5 id="一、语料库的构建"><a href="#一、语料库的构建" class="headerlink" title="一、语料库的构建"></a>一、语料库的构建</h5><ul><li>语料库需要具备全面、丰富的新闻语料特点，选取搜狗实验室提供的搜狐新闻数据集，并进行解析筛选处理作为新闻语料库。</li></ul><h5 id="二、-测试集构建"><a href="#二、-测试集构建" class="headerlink" title="二、 测试集构建"></a>二、 测试集构建</h5><ul><li>测试集涉及到需要高质量、高精度的关键词，如果全部人工标注难以实现。经广泛阅读查找发现，网易新闻网的新闻标有少量关键词，比较符合。因此可以爬取网易新闻网的新闻及关键词，然后对爬取的关键词进行人工二次加工处理，最终得到可以作为<strong>金标准</strong>的测试集。</li><li>使用 python 中 Scrapy 框架进行采集数据</li></ul><h4 id="第三节-数据处理"><a href="#第三节-数据处理" class="headerlink" title="第三节  数据处理"></a>第三节  数据处理</h4><h5 id="一、分词与词性标注"><a href="#一、分词与词性标注" class="headerlink" title="一、分词与词性标注"></a>一、分词与词性标注</h5><ul><li><p>英文分词：以空格作为分隔符</p></li><li><p>中文分词：基于字符串匹配的分词方法、基于统计的分词方法、基于语义的分词方法</p></li><li><p>词性标注：基于统计的方法和基于规则的方法。</p></li></ul><h5 id="二、去停用词"><a href="#二、去停用词" class="headerlink" title="二、去停用词"></a>二、去停用词</h5><ul><li>停用词表是一些无实际意义的虚词、助词等构成</li></ul><h5 id="三、词性过滤"><a href="#三、词性过滤" class="headerlink" title="三、词性过滤"></a>三、词性过滤</h5><ul><li>代词、连词、介词等词性的词语与新闻文本的主旨联系不大，几乎没有参考价值，因此可有将此类词性的词语直接过滤掉。</li></ul><h4 id="第四节-评测指标"><a href="#第四节-评测指标" class="headerlink" title="第四节  评测指标"></a>第四节  评测指标</h4><ul><li><p>在关键词提取的评测标准上，我们借鉴 MUC（Message Understanding Conference）信息抽<br>取的评测标准，计算准确率（Precision）、召回率（Recall）和 F1 值（F-score）这三个指标。</p></li><li><p>准确率和召回率的值在 0 到 1 之间，越接近数值 1，准确率或召回率就越高，关键词提取的效果就越好。在关键词提取时，往往会设定一个固定提取数目，这样会造成提取的数目和标注的数目不一致。Zesch提出每篇文档的关键词提取数目和标注数目一致，然后计算准确率 p，当 p 接近 1 时，表示提取的效果最好。</p></li><li><p>本章总结</p></li></ul><h3 id="第二章-基于齐普夫定律与卡方检验的新闻关键词提取"><a href="#第二章-基于齐普夫定律与卡方检验的新闻关键词提取" class="headerlink" title="第二章  基于齐普夫定律与卡方检验的新闻关键词提取"></a>第二章  基于齐普夫定律与卡方检验的新闻关键词提取</h3><ul><li><p>针对 TF-IDF 算法提取效率低和精度差的缺点，本章提出了一种基于齐普夫定律与卡方检验的 TF-IDF 改进算法。首先，根据齐普夫定律，得到不同频次词的权值，并结合卡方检验用于关键词提取。 </p></li><li><p>具体原理与应用</p></li></ul><h3 id="第三章-基于模型融合的新闻关键词提取"><a href="#第三章-基于模型融合的新闻关键词提取" class="headerlink" title="第三章  基于模型融合的新闻关键词提取"></a>第三章  基于模型融合的新闻关键词提取</h3><ul><li>模型融合就是考虑模型的差异性，得出不同的结果，并将它们的最终结果融合到一起。在关键词提取中，使用单个的提取算法虽然可以得到关键词，但是单个模型的提取精度并不高，存在很大的提升空间。</li></ul><h4 id="第一节-模型融合"><a href="#第一节-模型融合" class="headerlink" title="第一节  模型融合"></a>第一节  模型融合</h4><h5 id="一、瀑布融合"><a href="#一、瀑布融合" class="headerlink" title="一、瀑布融合"></a>一、瀑布融合</h5><ul><li><p>瀑布融合是将多个算法模型以串联的形式连接起来，每个算法类似于一个过滤器，通过不同的算法过滤从而得到最终结果。</p></li><li><p>对于瀑布融合而言，前一个算法过滤的结果将作为下一个算法过滤的输入，候选结果经过层层过滤，最终得到量少质量高的结果</p></li></ul><h5 id="二、-并行组合融合"><a href="#二、-并行组合融合" class="headerlink" title="二、   并行组合融合"></a>二、   并行组合融合</h5><ul><li>组合方法采用一组可扩展的算法，通过算法的组合，可以实现不同方式的过滤。在关键词提取上有以下几种组合方案。 <ul><li>1）串行方案：关键词提取的算法以串联的方式应用，其中前一个算法的输出数据为后一个算法提供数据输入。即上述的瀑布融合。 </li><li>2）并行方案：将几种算法应用于从原始文档中提取关键词的单独实现，然后将结果以相交的形式，取交集得到结果。 </li><li>3）投票方案：投票的方法是并行发的一种改进特例，每个术语都由关键词提取算法进行投票，以获得是否属于关键词，当它从算法中获得足够的票数时，一个术语最终才能确定为关键词。</li></ul></li></ul><h4 id="第二节-基于模型融合的新闻关键词提取设计"><a href="#第二节-基于模型融合的新闻关键词提取设计" class="headerlink" title="第二节  基于模型融合的新闻关键词提取设计"></a>第二节  基于模型融合的新闻关键词提取设计</h4><h5 id="一、-TF-IDF、TextRank、LDA-优缺点分析"><a href="#一、-TF-IDF、TextRank、LDA-优缺点分析" class="headerlink" title="一、 TF-IDF、TextRank、LDA 优缺点分析"></a>一、 TF-IDF、TextRank、LDA 优缺点分析</h5><ul><li><p>TF-IDF</p><ul><li>优点：通俗易懂，上手方便</li><li>缺点：严重依赖语料库，不能反应词语的位置信息（对于一篇新闻文本，文本首句和末尾局往往比其他位置的词语更加重要，需要赋予更高的权重，然而 TF-IDF 一视同仁的对待 )</li></ul></li><li><p>TextRank</p><ul><li>优点：不需要语料库，省略了语料库的构建</li><li>缺点：计算复杂度远远高于 TF-IDF。同时，由于与其他文本语料没有联系，也造成主题缺失</li></ul></li><li><p>LDA</p><ul><li>在某些场景下，基于文本本身的关键词提取还是不够的。需要挖掘词语与文本之间隐含的联系，比如说主题关系。</li><li>优点：将词语、文本之间通过一个网络空间联系起来，分析挖掘潜在隐含联系。</li><li>缺点：无法反馈准确的文档主题。同时 LDA 算法的运算时间较长，需要大量的实践训练，时间复杂度很高。</li></ul></li></ul><h5 id="二、-瀑布融合实验设计"><a href="#二、-瀑布融合实验设计" class="headerlink" title="二、 瀑布融合实验设计"></a>二、 瀑布融合实验设计</h5><ul><li><p>对于上述三种经典算法，两两排列组合会有六种组合。因此瀑布融合方法会有六种可行的方案，但是通过上文对三种关键词提取算法的优缺点进行详细的分析，TextRank 算法与 LDA 主题模型算法具有共同的特点是复杂度高，而 TF-IDF 算法正因为原理简单易懂，复杂度低。因此不适合将 TextRank 与 LDA 放在前面，先进行运算，这样会导致算法复杂度过高。</p></li><li><p>先使用 TF-IDF 选出更加精确的候选关键词，再进行其他算法会有助于精简</p></li><li><p>方案一：先 TF-IDF算法再 TextRank 算法</p><ul><li>输入：文本 j<br>输出：文本 j 的前 k 个关键词 <ol><li><p>对文本 j 做分词，得到词语集 t </p></li><li><p>去停用词，得到新的词语集 T </p></li><li><p>计算 TF-IDF 值 </p></li><li><p>根据 TF-IDF 值进行排序，筛选词语集 M </p></li><li><p>判断词语集 M 是否大于 50，若是，继续下一步，不然返回上一步 </p></li><li><p>将词语集 M 作为输入，输入到 TextRank 算法中，进行运算。 </p></li><li><p>提取出关键词</p></li></ol></li></ul></li><li><p>方案二：先先 TF-IDF 算法再 LDA 主题模型算法</p><ul><li>输入：文本 j<br>输出：文本 j 的前 k 个关键词 <ol><li>对文本 j 做分词，得到词语集 t </li><li>去停用词，得到新的词语集 T </li><li>计算 TF-IDF 值 </li><li>根据 TF-IDF 值进行排序，筛选词语集 M </li><li>判断词语集 M 是否大于 50，若是，继续下一步，不然返回上一步 </li><li>将词语集 M 作为输入，输入到 LDA 主题模型算法中，进行运算。 </li><li>提取出关键词</li></ol></li></ul></li></ul><h5 id="三、-并行组合融合实验设计"><a href="#三、-并行组合融合实验设计" class="headerlink" title="三、 并行组合融合实验设计"></a>三、 并行组合融合实验设计</h5><ul><li><p>并行组合融合与上文的瀑布融合的区别在于不需要关注算法组合的前后顺序，因<br>此两两组合后有三种方案： </p></li><li><p>方案一：TF-IDF 算法与 TextRank 算法并行组合（不考虑先后顺序） </p><ul><li>输入：文本 j<br>输出：文本 j 的前 k 个关键词 <ol><li><p>对文本 j 做分词，得到词语集 t </p></li><li><p>去停用词，得到新的词语集 T </p></li><li><p>词语集 T 输入到 TF-IDF 算法，得到结果 S1 </p></li><li><p>词语集 T 输入到 TextRank 算法，得到结果 S2 </p></li><li><p>将结果 S1,S2 并行投票 </p></li><li><p>提取出关键词</p></li></ol></li></ul></li><li><p>方案二：TF-IDF 算法与 LDA 主题算法并行组合（不考虑先后顺序）</p><ul><li>输入：文本 j<br>输出：文本 j 的前 k 个关键词 <ol><li>对文本 j 做分词，得到词语集 t </li><li>去停用词，得到新的词语集 T </li><li>词语集 T 输入到 TF-IDF 算法，得到结果 S1 </li><li>词语集 T 输入到 LDA 算法，得到结果 S2 </li><li>将结果 S1,S2 并行投票 </li><li>提取出关键词</li></ol></li></ul></li><li><p>方案三：LDA 主题模型算法与 TextRank 算法并行组合（不考虑先后顺序）</p><ul><li>输入：文本 j<br>输出：文本 j 的前 k 个关键词 <ol><li>对文本 j 做分词，得到词语集 t </li><li>去停用词，得到新的词语集 T </li><li>词语集 T 输入到 TextRank 算法，得到结果 S1 </li><li>词语集 T 输入到 LDA 算法，得到结果 S2 </li><li>将结果 S1,S2 并行投票 </li><li>提取出关键词</li></ol></li></ul></li></ul><h4 id="第三节-实验分析"><a href="#第三节-实验分析" class="headerlink" title="第三节  实验分析"></a>第三节  实验分析</h4><h5 id="一、-瀑布融合实验分析"><a href="#一、-瀑布融合实验分析" class="headerlink" title="一、 瀑布融合实验分析"></a>一、 瀑布融合实验分析</h5><ul><li><p><strong>金标准</strong>。对比可以发现方案一相对于方案二更加接近金标准，关键词提取性能更佳。</p></li><li><p><strong>时间效率</strong>。实验结果表明方案一时间效率优于方案二。 </p></li><li><p><strong>召回率</strong>和<strong>准确率</strong>。方案一的性能优于方案二。</p></li></ul><h5 id="二、-并行组合融合实验分析"><a href="#二、-并行组合融合实验分析" class="headerlink" title="二、 并行组合融合实验分析"></a>二、 并行组合融合实验分析</h5><p>实验结果将从下列三个方面进行分析： </p><ul><li><p>第一方面：直观对比分析：实验结果与金标准对比分析 </p><ul><li>三种方案接近</li></ul></li><li><p>第二方面：时间对比分析：三种方案提取关键词时间对比分析 </p><ul><li>方案一时间效率优于其他方案</li></ul></li><li><p>第三方面：质量对比分析：将计算三种方案的准确率与召回率并对其进行分析</p><ul><li>方案一的性能优于方案二、方案二</li></ul></li><li><p>本章总结</p></li></ul><h3 id="第四章-新闻关键词提取系统"><a href="#第四章-新闻关键词提取系统" class="headerlink" title="第四章  新闻关键词提取系统"></a>第四章  新闻关键词提取系统</h3><h4 id="第一节-开发环境及相关技术"><a href="#第一节-开发环境及相关技术" class="headerlink" title="第一节  开发环境及相关技术"></a>第一节  开发环境及相关技术</h4><ul><li>Django 框架。MVT 模式。框架的流程模式图。</li></ul><h4 id="第二节-需求分析"><a href="#第二节-需求分析" class="headerlink" title="第二节  需求分析"></a>第二节  需求分析</h4><ul><li><p>新闻关键词提取系统是一款专业的新闻文本关键词提取工具，针对新闻文本，将文本分词去停用词等步骤后得到候选关键词，进而利用词频，逆文档频率，词图，共现关系等来进行提取关键词</p></li><li><p>集成多种关键词提取算法，有常用的 TFIDF 算法，TextRank 算法，还有第二、三章最优的关键词提取算法。同时它可用于关键词提取，新闻文本分析，提取的结果对比分析等用途。</p></li></ul><h4 id="第三节-系统框架设计"><a href="#第三节-系统框架设计" class="headerlink" title="第三节  系统框架设计"></a>第三节  系统框架设计</h4><ul><li><p>系统流程设计</p></li><li><p>系统功能设计 </p></li><li><p>页面设计</p></li></ul><h4 id="第四节-系统测试及演示"><a href="#第四节-系统测试及演示" class="headerlink" title="第四节  系统测试及演示"></a>第四节  系统测试及演示</h4><ul><li><p>系统测试 </p><ul><li>单元测试</li><li>集成测试</li><li>系统测试</li><li>验收测试</li></ul></li><li><p>系统演示</p></li><li><p>本章总结</p></li></ul><h3 id="第五章-总结与展望"><a href="#第五章-总结与展望" class="headerlink" title="第五章  总结与展望"></a>第五章  总结与展望</h3><ul><li>目录顺序概括全文</li><li>语料库需要完善，停用词表需要完善</li><li>加上投票机制</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
      <tag>文献</tag>
      
      <tag>关键词提取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【考研】2020年北化计算机考研复试面试题目汇总</title>
    <link href="/archives/15e5e176.html"/>
    <url>/archives/15e5e176.html</url>
    
    <content type="html"><![CDATA[<h1 id="复试面试问题汇总"><a href="#复试面试问题汇总" class="headerlink" title="复试面试问题汇总"></a>复试面试问题汇总</h1><h2 id="更新2021年题目"><a href="#更新2021年题目" class="headerlink" title="更新2021年题目"></a>更新2021年题目</h2><ul><li><p>路由器、交换机、集线器分别工作在哪一层</p></li><li><p>搜索算法</p></li><li><p>英文介绍家乡、最喜欢的老师</p></li><li><p>数学：特征向量代表什么，相关公式</p></li><li><p>介绍项目</p></li><li><p>数据库三范式</p></li><li><p>机组、操作系统 … …</p></li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul><li>计算机语言发展史<ul><li>三个阶段：机器语言，汇编语言，高级语言</li><li>机器语言：机器能识别的010101代码</li><li>汇编语言：把01010指令映射成助记符，如加法指令ADD,减法指令SUB</li><li>高级语言：抽象层次更高，更接近人类的语言，便于编程和学习</li></ul></li><li>什么是大数据<ul><li>大量、高速、增长快、低密度的数据，等待人去从大量数据中挖掘有价值的部分</li></ul></li><li>物联网和大数据的区别<ul><li>物联网：万物互联，机器与机器通过网络链接起来，典型应用：智能家居</li><li>大数据：大量、高速、增长快、低密度的数据，等待人去从大量数据中挖掘有价值的部分</li></ul></li><li>AlphaGo和深蓝<ul><li>深蓝算法的核心是基于暴力穷举，生成所有可能的走法，然后执行尽可能深的搜索，并不断对局面进行评估，尝试找出最佳走法</li><li>AlphaGo的核心算法基于深度强化学习</li></ul></li><li>病毒的特性<ul><li>传播性、隐蔽性、感染性、潜伏性、可激发性、表现性或破坏性</li></ul></li><li>数字和模拟的区别<ul><li>模拟数据：传感器采集得到的<strong>连续变化</strong>的值</li><li>数字数据：模拟数据经量化后得到的<strong>离散</strong>的值</li></ul></li><li>大量数据怎么存储<ul><li>非关系型数据库、分布式存储</li></ul></li></ul><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li>自我介绍</li><li>文献翻译</li><li>大学同学毕业后去了哪里</li><li>介绍大学和专业</li><li>介绍家乡</li><li>项目中的困难</li><li>最喜欢的语言</li><li>大学时候最难忘的事</li><li>为什么选北化</li></ul><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><ul><li><p>二进制补码</p></li><li><p>超标量流水线的定义</p></li><li><p>字扩展位扩展</p></li><li><p>SRAM和DRAM</p></li><li><p>冯诺依曼体系</p></li><li><p>cache </p></li><li><p>内存的映射</p></li><li><p>浮点数加减运算</p></li><li><p>求带宽 </p></li><li><p>控制总线和地址总线</p></li><li><p>物理地址和虚拟地址</p></li><li><p>复杂指令集</p></li><li><p>5层结构</p></li><li><p>数制</p></li><li><p>微指令操作</p></li><li><p>中断，来源</p></li><li><p>桥</p></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>发展和分类<ul><li>人工操作系统</li><li>批操作系统（无交互）<ul><li>单道批操作系统（内存中只有一个作业）</li><li>多道批操作系统（内存中有多个作业）</li></ul></li><li>分时操作系统（有交互）：时间片轮转</li><li>实时操作系统：抢占式高优先级</li></ul></li><li>进程与线程的区别<ul><li>调度和拥有资源方面<ul><li>传统操作系统中，进程是独立调度和拥有资源的基本单位</li><li>引入线程后，进程仍然是拥有资源的基本单位，但是线程成了独立调度的基本单位</li></ul></li><li>并发<ul><li>传统操作系统中，进程可以并发执行</li><li>引入线程后，线程和进程都可以并发执行，系统的并发程度更高</li></ul></li><li>系统开销<ul><li>进程系统开销大</li><li>线程系统开销小</li></ul></li><li>地址空间和资源<ul><li>进程有独立的地址空间，资源不共享</li><li>同一进程中的所有进程共享进程的资源</li></ul></li><li>通信<ul><li>进程通信需要同步和互斥</li><li>同一进程不同线程之间的通信可以直接进行</li></ul></li></ul></li><li>挂起<ul><li>什么是挂起<ul><li>使进程进入静止状态。如果进程已就绪，挂起后不接受调度；如果进程正在执行，挂起后停止执行</li></ul></li><li>为什么要挂起<ul><li>用户需要，检查并修改进程</li><li>父进程请求，协调子进程</li><li>负荷调节需要，挂起不重要的进程，保证系统正常运行</li><li>操作系统需要，检查进程的资源使用情况</li></ul></li></ul></li><li>作业调度，进程调度的区别<ul><li>作业调度：把作业从外存调入内存，属于高级调度</li><li>进程调度：从进程的就绪队列中挑选合适的进程，分配cpu</li></ul></li><li>进程同步</li><li>四辆车过桥PV操作</li><li>司机售票员PV</li><li>僵尸进程，孤儿进程 </li><li>死锁<ul><li>为什么会发生死锁<ul><li>系统中有一些不可剥夺的资源，当多个进程占有资源并且请求对方的资源时，会导致所有进程都无法向前推进，这就是死锁</li></ul></li><li>死锁的4个必要条件<ul><li>互斥条件</li><li>不剥夺条件</li><li>请求与保持条件</li><li>循环等待条件</li></ul></li><li>怎么解决死锁<ul><li>预防死锁（破坏死锁的必要条件）<ul><li>破坏互斥条件（不能破坏）</li><li>破坏不剥夺条件（请求的资源得不到满足时，必须释放自己保持的资源）</li><li>破坏请求和保持条件（一次申请完所有的资源）</li><li>破坏循环等待条件（按顺序请求资源）</li></ul></li><li>避免死锁<ul><li>银行家算法</li></ul></li><li>死锁的检测和解除<ul><li>检测：资源状态图</li><li>解除：资源剥夺法，撤销进程法，进程回退法</li></ul></li></ul></li></ul></li><li>银行家算法</li><li>lru算法，需要什么硬件支持</li><li>影响请求分页机制效率的因素</li><li>段式页式</li><li>进程抖动</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>概念</li><li>时空复杂度</li><li>循环链表</li><li>查找算法</li><li>排序算法，最快最慢，稳定的有哪些，分治思想体现在哪里 </li><li>冒泡排序，最快最慢</li><li>快排复杂度，为什么，如何计算</li><li>前后序为什么不能确定二叉树，为什么需要中序</li><li>kmp</li><li>二叉树</li><li>B+</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>回溯法和分支线变</li><li>01背包</li><li>贪心</li><li>dp</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>OSI和TCP\IP的网络模型</li><li>tcp和ip的区别</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>查询语句</li><li>安全性，是什么，有什么因素<ul><li>保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏</li></ul></li><li>码、候选码（关键字）、主码（主键、主关键字）<ul><li>码：唯一标识记录的属性或属性集</li><li>候选码：唯一标识记录的属性或属性集，但是不含多余的属性</li><li>主码：候选码中任意一个都可以作为主码</li></ul></li><li>一对多，多对多</li><li>e-r图</li><li>范式<ul><li>1NF:字段不可再分</li><li>2NF:有主键，非主属性依赖于主键</li><li>3NF:非主属性不能相互依赖</li></ul></li><li>概念（数据）模型<ul><li>层次模型</li><li>网状模型</li><li>关系模型</li><li>面向对象模型</li></ul></li><li>SQL优化<ul><li>查询优化器：<ul><li>找等价的查询语句，估算代价，找出最低代价的查询语句</li><li>把查询语句转化为语法树，变化为优化形式，生产查询语句</li></ul></li></ul></li><li>事务的四个特性<ul><li>A:原子性</li><li>C:一致性</li><li>I:隔离性</li><li>D:持久性</li></ul></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul><li><p>java和c的区别</p><ul><li>编译速度：java慢，c快</li><li>操作内存：c可以直接操作内存，java不可以</li><li>指针：c有，java没有</li><li>使用场景：单独功能c效率高，java适用web应用</li></ul></li><li><p>重载</p><ul><li>多态性的一种体现方式</li><li>同名的函数的参数列表中，参数的类型和个数不同</li></ul></li><li><p>特征</p><ul><li><p>语法简单</p></li><li><p>面向对象</p></li><li><p>跨平台</p></li></ul></li><li><p>序列化</p><ul><li>实现Serializable 接口</li><li>一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型</li><li>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象</li></ul></li><li><p>动态绑定</p><ul><li>在运行时根据具体对象的类型绑定调用的数据和方法</li></ul></li><li><p>源代码—&gt;二进制字节码</p><ul><li>javac编译</li><li>jvm逐行解释—&gt;机器码</li></ul></li></ul><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul><li>静态变量<ul><li>static关键字</li><li>被static修饰后，变量或函数属于整个类而不属于他的对象</li><li>在定义时被创建，程序结束时消失</li><li>static修饰的函数只能读写static修饰的变量</li></ul></li><li>const<ul><li>常变量，定义时赋值，不可再改变</li><li>常指针，地址不可再改变，但是地址所指向的值可以改变</li><li>常成员函数，不能改变变量的值</li></ul></li><li>进制转化</li><li>内存泄露<ul><li>new出来的对象没有被及时地delete</li></ul></li><li>友元<ul><li>friend关键字</li><li>破坏封装</li><li>友元类和友元函数可以访问私有变量</li><li>友元类的所有函数都是友元函数</li></ul></li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul><li>查询文件<ul><li>find</li><li>ls列出当前目录</li></ul></li></ul><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><ul><li>式</li><li>实数是有穷集合还是无穷集合</li><li>等价关系和偏序关系</li></ul><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul><li>介绍CNN</li></ul><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><ul><li><p>A*</p></li><li><p>遗传</p></li></ul><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><ul><li>词法分析<ul><li>正则表达式-&gt;NFA-&gt;DFA-&gt;miniDFA</li></ul></li></ul><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><ul><li>软件周期</li><li>时序图</li><li>需求模型</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul><li>git版本回退</li><li>图片在table中怎么获取</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
